{"version":3,"file":"BackgroundRenderer-Dyo13YMg.js","sources":["../src/Components/Renderers/BackgroundRenderer.ts"],"sourcesContent":["import { Vector } from \"../../Helpers/Vector\";\r\n\r\nasync function drawHexGrid(context: OffscreenCanvasRenderingContext2D, gridSize: Vector, dotSize: number, lineColor: string, scale: Vector) {\r\n    const canvasWidth = context.canvas.width;\r\n    const canvasHeight = context.canvas.height;\r\n    const size = gridSize.x * Math.abs(scale.x)/2;\r\n    const width = Math.sqrt(3) * size;\r\n    const height = 2 * size;\r\n    const vertSpacing = 0.75 * height;\r\n\r\n    context.strokeStyle = lineColor;\r\n    context.lineWidth = dotSize * scale.x;\r\n    function drawHexagon(cx: number, cy: number) {\r\n        context.beginPath();\r\n        for (let i = 0; i < 6; i++) {\r\n            const angle = Math.PI / 180 * (60 * i - 30); // pointy-top\r\n            const x = cx + size * Math.cos(angle);\r\n            const y = cy + size * Math.sin(angle);\r\n            if (i === 0) context.moveTo(x, y);\r\n            else context.lineTo(x, y);\r\n        }\r\n        context.closePath();\r\n        context.shadowColor =  'rgba(0, 0, 0, 0.75)';\r\n        context.shadowBlur = 55;\r\n        context.stroke();\r\n    }\r\n    for (let row = 0; row * vertSpacing < canvasHeight + height; row++) {\r\n        const y = (canvasHeight / 2) %(3*size) + row * vertSpacing;\r\n        const offsetX = (row % 2) * (width / 2);\r\n        for (let col = 0; col * width + offsetX < canvasWidth + width; col++) {\r\n            const x = (canvasWidth / 2) % width + col * width + offsetX;\r\n            drawHexagon(x, y);\r\n            await new Promise(r => setTimeout(r, 0));\r\n        }\r\n    }\r\n    context.setTransform(1, 0, 0, 1, 0, 0);\r\n    context.shadowBlur = 0;\r\n}\r\n\r\nasync function drawGrid(context: CanvasRenderingContext2D, gridSize: Vector, dotSize: number, lineColor: string, scale: Vector) {\r\n    const canvasWidth = context.canvas.width;\r\n    const canvasHeight = context.canvas.height;\r\n\r\n    gridSize.x *= Math.abs(scale.x);\r\n    gridSize.y *= Math.abs(scale.y);\r\n    context.strokeStyle = lineColor;\r\n    context.lineWidth = dotSize * scale.x;\r\n    context.beginPath();\r\n    for (let x = (canvasWidth / 2) % gridSize.x; x <= canvasWidth; x += gridSize.x) {\r\n        context.moveTo(x, 0);\r\n        context.lineTo(x, canvasHeight);\r\n        // await new Promise(r => setTimeout(r, 10));\r\n    }\r\n\r\n    for (let y = (canvasHeight / 2) % gridSize.y; y <= canvasHeight; y += gridSize.y) {\r\n        context.moveTo(0, y);\r\n        context.lineTo(canvasWidth, y);\r\n        // await new Promise(r => setTimeout(r, 10));\r\n    }\r\n    context.stroke();\r\n    context.setTransform(1, 0, 0, 1, 0, 0);\r\n    context.shadowBlur = 0;\r\n}\r\n  \r\n\r\nasync function drawDotGrid(context: OffscreenCanvasRenderingContext2D, gridSize: Vector, dotSize: number, dotColor: string, scale: Vector) {\r\n    const canvasWidth = context.canvas.width;\r\n    const canvasHeight = context.canvas.height;\r\n\r\n    gridSize.x *= scale.x;\r\n    gridSize.y *= scale.y;\r\n    dotSize *= scale.x;\r\n    context.fillStyle = dotColor;\r\n    for (let y = (canvasHeight/2)%gridSize.y; y <= canvasHeight; y += gridSize.y) {\r\n        for (let x =  (canvasWidth/2)%gridSize.x; x <= canvasWidth; x += gridSize.x) {\r\n            context.beginPath();\r\n            context.arc(x, y, dotSize / 2, 0, Math.PI * 2);\r\n            context.fill();\r\n            context.shadowColor =  'rgba(0, 0, 0, 0.75)';\r\n            context.shadowBlur = 35;\r\n            context.stroke();\r\n        }\r\n        await new Promise(r => setTimeout(r, 0));\r\n    }\r\n    context.setTransform(1, 0, 0, 1, 0, 0);\r\n    context.shadowBlur = 0;\r\n}\r\n\r\nonmessage = async (event) => {\r\n    const offscreenCanvas = event.data.canvas;\r\n    const ctx = offscreenCanvas.getContext(\"2d\");\r\n    if (!ctx) return;\r\n\r\n    let args: any = event.data.args;\r\n    // await drawDotGrid(ctx, args[0], 0.1, args[2], args[3]);\r\n    await drawGrid(ctx, args[0], 0.075, args[2], args[3]);\r\n    // await drawHexGrid(ctx, args[0], 0.05, args[2], args[3]);\r\n};\r\n"],"names":["drawGrid","context","gridSize","dotSize","lineColor","scale","canvasWidth","canvasHeight","x","y","event","ctx","args"],"mappings":"yBAuCA,eAAeA,EAASC,EAAmCC,EAAkBC,EAAiBC,EAAmBC,EAAe,CACtH,MAAAC,EAAcL,EAAQ,OAAO,MAC7BM,EAAeN,EAAQ,OAAO,OAEpCC,EAAS,GAAK,KAAK,IAAIG,EAAM,CAAC,EAC9BH,EAAS,GAAK,KAAK,IAAIG,EAAM,CAAC,EAC9BJ,EAAQ,YAAcG,EACdH,EAAA,UAAYE,EAAUE,EAAM,EACpCJ,EAAQ,UAAU,EACT,QAAAO,EAAKF,EAAc,EAAKJ,EAAS,EAAGM,GAAKF,EAAaE,GAAKN,EAAS,EACjED,EAAA,OAAOO,EAAG,CAAC,EACXP,EAAA,OAAOO,EAAGD,CAAY,EAIzB,QAAAE,EAAKF,EAAe,EAAKL,EAAS,EAAGO,GAAKF,EAAcE,GAAKP,EAAS,EACnED,EAAA,OAAO,EAAGQ,CAAC,EACXR,EAAA,OAAOK,EAAaG,CAAC,EAGjCR,EAAQ,OAAO,EACfA,EAAQ,aAAa,EAAG,EAAG,EAAG,EAAG,EAAG,CAAC,EACrCA,EAAQ,WAAa,CACzB,CA0BA,UAAY,MAAOS,GAAU,CAEnB,MAAAC,EADkBD,EAAM,KAAK,OACP,WAAW,IAAI,EAC3C,GAAI,CAACC,EAAK,OAEN,IAAAC,EAAYF,EAAM,KAAK,KAErB,MAAAV,EAASW,EAAKC,EAAK,CAAC,EAAG,KAAOA,EAAK,CAAC,EAAGA,EAAK,CAAC,CAAC,CAExD"}