/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/@dimforge/rapier2d/coarena.js":
/*!****************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/coarena.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Coarena: () => (/* binding */ Coarena)\n/* harmony export */ });\nclass Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we don’t really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/coarena.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/control/character_controller.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/control/character_controller.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* binding */ CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* binding */ KinematicCharacterController)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nclass CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nclass KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floor’s angle.\n     */\n    setUp(vector) {\n        let rawVect = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isn’t attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldn’t be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    normalNudgeFactor() {\n        return this.raw.normalNudgeFactor();\n    }\n    /// Increase this number if your character appears to get stuck when sliding against surfaces.\n    ///\n    /// This is a small distance applied to the movement toward the contact normals of shapes hit\n    /// by the character controller. This helps shape-casting not getting stuck in an always-penetrating\n    /// state during the sliding calculation.\n    ///\n    /// This value should remain fairly small since it can introduce artificial \"bumps\" when sliding\n    /// along a flat surface.\n    setNormalNudgeFactor(value) {\n        this.raw.setNormalNudgeFactor(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floor’s normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floor’s normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslationDelta = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationDeltaApplied = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaApplied());\n            out.translationDeltaRemaining = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.translationDeltaRemaining());\n            out.toi = c.toi();\n            out.witness1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/control/character_controller.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/control/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/control/index.js ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _character_controller__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController),\n/* harmony export */   PidAxesMask: () => (/* reexport safe */ _pid_controller__WEBPACK_IMPORTED_MODULE_1__.PidAxesMask),\n/* harmony export */   PidController: () => (/* reexport safe */ _pid_controller__WEBPACK_IMPORTED_MODULE_1__.PidController)\n/* harmony export */ });\n/* harmony import */ var _character_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./character_controller */ \"./node_modules/@dimforge/rapier2d/control/character_controller.js\");\n/* harmony import */ var _pid_controller__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pid_controller */ \"./node_modules/@dimforge/rapier2d/control/pid_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_character_controller__WEBPACK_IMPORTED_MODULE_0__, _pid_controller__WEBPACK_IMPORTED_MODULE_1__]);\n([_character_controller__WEBPACK_IMPORTED_MODULE_0__, _pid_controller__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/control/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/control/pid_controller.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/control/pid_controller.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PidAxesMask: () => (/* binding */ PidAxesMask),\n/* harmony export */   PidController: () => (/* binding */ PidController)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n// TODO: unify with the JointAxesMask\n/**\n * An enum representing the possible joint axes controlled by a PidController.\n * They can be ORed together, like:\n * PidAxesMask.LinX || PidAxesMask.LinY\n * to get a pid controller that only constraints the translational X and Y axes.\n *\n * Possible axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis (3D only)\n * - `AngY`: Y angular rotation axis (3D only)\n * - `AngZ`: Z angular rotation axis\n */\nvar PidAxesMask;\n(function (PidAxesMask) {\n    PidAxesMask[PidAxesMask[\"None\"] = 0] = \"None\";\n    PidAxesMask[PidAxesMask[\"LinX\"] = 1] = \"LinX\";\n    PidAxesMask[PidAxesMask[\"LinY\"] = 2] = \"LinY\";\n    PidAxesMask[PidAxesMask[\"LinZ\"] = 4] = \"LinZ\";\n    PidAxesMask[PidAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n    // #if DIM2\n    PidAxesMask[PidAxesMask[\"AllLin\"] = 3] = \"AllLin\";\n    PidAxesMask[PidAxesMask[\"AllAng\"] = 32] = \"AllAng\";\n    // #endif\n    PidAxesMask[PidAxesMask[\"All\"] = 35] = \"All\";\n})(PidAxesMask || (PidAxesMask = {}));\n/**\n * A controller for controlling dynamic bodies using the\n * Proportional-Integral-Derivative correction model.\n */\nclass PidController {\n    constructor(params, bodies, kp, ki, kd, axes) {\n        this.params = params;\n        this.bodies = bodies;\n        this.raw = new _raw__WEBPACK_IMPORTED_MODULE_0__.RawPidController(kp, ki, kd, axes);\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    setKp(kp, axes) {\n        this.raw.set_kp(kp, axes);\n    }\n    setKi(ki, axes) {\n        this.raw.set_kp(ki, axes);\n    }\n    setKd(kd, axes) {\n        this.raw.set_kp(kd, axes);\n    }\n    setAxes(axes) {\n        this.raw.set_axes_mask(axes);\n    }\n    resetIntegrals() {\n        this.raw.reset_integrals();\n    }\n    applyLinearCorrection(body, targetPosition, targetLinvel) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(targetPosition);\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(targetLinvel);\n        this.raw.apply_linear_correction(this.params.dt, this.bodies.raw, body.handle, rawPos, rawVel);\n        rawPos.free();\n        rawVel.free();\n    }\n    // #if DIM2\n    applyAngularCorrection(body, targetRotation, targetAngVel) {\n        this.raw.apply_angular_correction(this.params.dt, this.bodies.raw, body.handle, targetRotation, targetAngVel);\n    }\n    // #endif\n    linearCorrection(body, targetPosition, targetLinvel) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(targetPosition);\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(targetLinvel);\n        let correction = this.raw.linear_correction(this.params.dt, this.bodies.raw, body.handle, rawPos, rawVel);\n        rawPos.free();\n        rawVel.free();\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(correction);\n    }\n    // #if DIM2\n    angularCorrection(body, targetRotation, targetAngVel) {\n        return this.raw.angular_correction(this.params.dt, this.bodies.raw, body.handle, targetRotation, targetAngVel);\n    }\n}\n//# sourceMappingURL=pid_controller.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/control/pid_controller.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* binding */ CCDSolver)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nclass CCDSolver {\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver();\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CoefficientCombineRule: () => (/* binding */ CoefficientCombineRule)\n/* harmony export */ });\n/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nvar CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js ***!
  \*******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedImpulseJoint: () => (/* binding */ FixedImpulseJoint),\n/* harmony export */   ImpulseJoint: () => (/* binding */ ImpulseJoint),\n/* harmony export */   JointAxesMask: () => (/* binding */ JointAxesMask),\n/* harmony export */   JointData: () => (/* binding */ JointData),\n/* harmony export */   JointType: () => (/* binding */ JointType),\n/* harmony export */   MotorModel: () => (/* binding */ MotorModel),\n/* harmony export */   PrismaticImpulseJoint: () => (/* binding */ PrismaticImpulseJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* binding */ RevoluteImpulseJoint),\n/* harmony export */   RopeImpulseJoint: () => (/* binding */ RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* binding */ SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* binding */ UnitImpulseJoint)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nvar JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n    JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n})(JointType || (JointType = {}));\nvar MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.LinX || JointAxesMask.LinY\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nvar JointAxesMask;\n(function (JointAxesMask) {\n    JointAxesMask[JointAxesMask[\"LinX\"] = 1] = \"LinX\";\n    JointAxesMask[JointAxesMask[\"LinY\"] = 2] = \"LinY\";\n    JointAxesMask[JointAxesMask[\"LinZ\"] = 4] = \"LinZ\";\n    JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n    JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n    JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nclass ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nclass UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joint’s free coordinate.\n     * @param max - The maximum bound of this joint’s free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nclass FixedImpulseJoint extends ImpulseJoint {\n}\nclass RopeImpulseJoint extends ImpulseJoint {\n}\nclass SpringImpulseJoint extends ImpulseJoint {\n}\nclass PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.LinX;\n    }\n}\nclass RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawJointAxis.AngX;\n    }\n}\nclass JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n    static rope(length, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n    // #if DIM2\n    /**\n     * Create a new joint descriptor that builds revolute joints.\n     *\n     * A revolute joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static revolute(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor1);\n        let rawA2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame1);\n                let rawFra2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(this.frame2);\n                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n                break;\n            case JointType.Rope:\n                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM2\n                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM2\n            case JointType.Revolute:\n                result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawGenericJoint.revolute(rawA1, rawA2);\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js ***!
  \***********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ImpulseJointSet: () => (/* binding */ ImpulseJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./impulse_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nclass ImpulseJointSet {\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = _impulse_joint__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _ccd_solver__WEBPACK_IMPORTED_MODULE_8__.CCDSolver),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__.CoefficientCombineRule),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.FixedMultibodyJoint),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _integration_parameters__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _island_manager__WEBPACK_IMPORTED_MODULE_9__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.JointType),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__.MultibodyJointSet),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.PrismaticMultibodyJoint),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _rigid_body__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.RopeImpulseJoint),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.SpringImpulseJoint),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _impulse_joint__WEBPACK_IMPORTED_MODULE_3__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _multibody_joint__WEBPACK_IMPORTED_MODULE_5__.UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rigid_body */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\n/* harmony import */ var _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rigid_body_set */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _integration_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./integration_parameters */ \"./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _impulse_joint__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./impulse_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint.js\");\n/* harmony import */ var _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./impulse_joint_set */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./multibody_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\n/* harmony import */ var _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./multibody_joint_set */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _coefficient_combine_rule__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coefficient_combine_rule */ \"./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _ccd_solver__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ccd_solver */ \"./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _island_manager__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./island_manager */ \"./node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__]);\n([_rigid_body__WEBPACK_IMPORTED_MODULE_0__, _rigid_body_set__WEBPACK_IMPORTED_MODULE_1__, _integration_parameters__WEBPACK_IMPORTED_MODULE_2__, _impulse_joint__WEBPACK_IMPORTED_MODULE_3__, _impulse_joint_set__WEBPACK_IMPORTED_MODULE_4__, _multibody_joint__WEBPACK_IMPORTED_MODULE_5__, _multibody_joint_set__WEBPACK_IMPORTED_MODULE_6__, _ccd_solver__WEBPACK_IMPORTED_MODULE_8__, _island_manager__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IntegrationParameters: () => (/* binding */ IntegrationParameters)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get contact_erp() {\n        return this.raw.contact_erp;\n    }\n    get lengthUnit() {\n        return this.raw.lengthUnit;\n    }\n    /**\n     * Normalized amount of penetration the engine won’t attempt to correct (default: `0.001m`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedAllowedLinearError() {\n        return this.raw.normalizedAllowedLinearError;\n    }\n    /**\n     * The maximal normalized distance separating two objects that will generate predictive contacts (default: `0.002`).\n     *\n     * This threshold considered by the physics engine is this value multiplied by the `lengthUnit`.\n     */\n    get normalizedPredictionDistance() {\n        return this.raw.normalizedPredictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set contact_natural_frequency(value) {\n        this.raw.contact_natural_frequency = value;\n    }\n    set lengthUnit(value) {\n        this.raw.lengthUnit = value;\n    }\n    set normalizedAllowedLinearError(value) {\n        this.raw.normalizedAllowedLinearError = value;\n    }\n    set normalizedPredictionDistance(value) {\n        this.raw.normalizedPredictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value) {\n        this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value) {\n        this.raw.numInternalPgsIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n    switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n    switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.raw.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/island_manager.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/island_manager.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IslandManager: () => (/* binding */ IslandManager)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nclass IslandManager {\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager();\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/island_manager.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js ***!
  \*********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FixedMultibodyJoint: () => (/* binding */ FixedMultibodyJoint),\n/* harmony export */   MultibodyJoint: () => (/* binding */ MultibodyJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* binding */ PrismaticMultibodyJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* binding */ RevoluteMultibodyJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* binding */ UnitMultibodyJoint)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\nclass MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    //\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nclass UnitMultibodyJoint extends MultibodyJoint {\n}\nclass FixedMultibodyJoint extends MultibodyJoint {\n}\nclass PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.LinX;\n    }\n}\nclass RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis.AngX;\n    }\n}\n//# sourceMappingURL=multibody_joint.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js ***!
  \*************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MultibodyJointSet: () => (/* binding */ MultibodyJointSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _multibody_joint__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multibody_joint */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nclass MultibodyJointSet {\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = _multibody_joint__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBody: () => (/* binding */ RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* binding */ RigidBodyDesc),\n/* harmony export */   RigidBodyType: () => (/* binding */ RigidBodyType)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nvar RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nclass RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translation along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, wakeUp) {\n        this.setEnabledTranslations(enableX, enableX, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    additionalSolverIterations() {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * Sets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    setSoftCcdPrediction(distance) {\n        this.rawSet.rbSetSoftCcdPrediction(this.handle, distance);\n    }\n    /**\n     * Gets the soft-CCD prediction distance for this rigid-body.\n     *\n     * See the documentation of `RigidBodyDesc.setSoftCcdPrediction` for\n     * additional details.\n     */\n    softCcdPrediction() {\n        return this.rawSet.rbSoftCcdPrediction(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM2\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(angle, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, angle, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        this.rawSet.rbSetAngvel(this.handle, vel, wakeUp);\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM2\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param angle - The kinematic rotation angle, in radians.\n     */\n    setNextKinematicRotation(angle) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    /**\n     * The velocity of the given world-space point on this rigid-body.\n     */\n    velocityAtPoint(point) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        let result = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbVelocityAtPoint(this.handle, rawPoint));\n        rawPoint.free();\n        return result;\n    }\n    // #if DIM2\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return this.rawSet.rbAngvel(this.handle);\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM2\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return this.rawSet.rbInvPrincipalInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return this.rawSet.rbPrincipalInertia(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return this.rawSet.rbEffectiveAngularInertia(this.handle);\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isn’t desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders’ contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM2\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders’ contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, wakeUp) {\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(centerOfMass);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, principalAngularInertia, wakeUp);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM2\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        this.rawSet.rbAddTorque(this.handle, torque, wakeUp);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        this.rawSet.rbApplyTorqueImpulse(this.handle, torqueImpulse, wakeUp);\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(force);\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(impulse);\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userForce() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.rawSet.rbUserForce(this.handle));\n    }\n    // #if DIM2\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body\n     * Returns zero if the rigid-body is not dynamic.\n     */\n    userTorque() {\n        return this.rawSet.rbUserTorque(this.handle);\n    }\n}\nclass RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.rotation = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM2\n        this.angvel = 0.0;\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.softCcdPrediction = 0.0;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled − If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     */\n    setLinvel(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        this.angvel = vel;\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass − The initial mass of the rigid-body to create.\n     * @param centerOfMass − The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia − The initial principal angular inertia of the rigid-body to create.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.mass = mass;\n        _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.restrictTranslations(false, false);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        this.rotationsEnabled = false;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the maximum prediction distance Soft Continuous Collision-Detection.\n     *\n     * When set to 0, soft-CCD is disabled. Soft-CCD helps prevent tunneling especially of\n     * slow-but-thin to moderately fast objects. The soft CCD prediction distance indicates how\n     * far in the object’s path the CCD algorithm is allowed to inspect. Large values can impact\n     * performance badly by increasing the work needed from the broad-phase.\n     *\n     * It is a generally cheaper variant of regular CCD (that can be enabled with\n     * `RigidBodyDesc::setCcdEnabled` since it relies on predictive constraints instead of\n     * shape-cast and substeps.\n     */\n    setSoftCcdPrediction(distance) {\n        this.softCcdPrediction = distance;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBodySet: () => (/* binding */ RigidBodySet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _rigid_body__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rigid_body */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_2__, _rigid_body__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_2__, _rigid_body__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass RigidBodySet {\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new _rigid_body__WEBPACK_IMPORTED_MODULE_3__.RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = _math__WEBPACK_IMPORTED_MODULE_2__.VectorOps.intoRaw(desc.translation);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_2__.RotationOps.intoRaw(desc.rotation);\n        let rawLv = _math__WEBPACK_IMPORTED_MODULE_2__.VectorOps.intoRaw(desc.linvel);\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_2__.VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM2\n        desc.angvel, desc.principalAngularInertia, desc.translationsEnabledX, desc.translationsEnabledY, desc.rotationsEnabled, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.softCcdPrediction, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        const body = new _rigid_body__WEBPACK_IMPORTED_MODULE_3__.RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/exports.js":
/*!****************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/exports.js ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_6__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_6__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.PhysicsPipeline),\n/* harmony export */   PidAxesMask: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_6__.PidAxesMask),\n/* harmony export */   PidController: () => (/* reexport safe */ _control__WEBPACK_IMPORTED_MODULE_6__.PidController),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _dynamics__WEBPACK_IMPORTED_MODULE_2__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps),\n/* harmony export */   Voxels: () => (/* reexport safe */ _geometry__WEBPACK_IMPORTED_MODULE_3__.Voxels),\n/* harmony export */   World: () => (/* reexport safe */ _pipeline__WEBPACK_IMPORTED_MODULE_4__.World),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/index.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./geometry */ \"./node_modules/@dimforge/rapier2d/geometry/index.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/index.js\");\n/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./init */ \"./node_modules/@dimforge/rapier2d/init.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./control */ \"./node_modules/@dimforge/rapier2d/control/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_6__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _pipeline__WEBPACK_IMPORTED_MODULE_4__, _control__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\nfunction version() {\n    return (0,_raw__WEBPACK_IMPORTED_MODULE_0__.version)();\n}\n\n\n\n\n\n\n//# sourceMappingURL=exports.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/exports.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/broad_phase.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/broad_phase.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BroadPhase: () => (/* binding */ BroadPhase)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nclass BroadPhase {\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase();\n    }\n}\n//# sourceMappingURL=broad_phase.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/broad_phase.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/collider.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/collider.js ***!
  \**************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* binding */ ActiveCollisionTypes),\n/* harmony export */   Collider: () => (/* binding */ Collider),\n/* harmony export */   ColliderDesc: () => (/* binding */ ColliderDesc),\n/* harmony export */   MassPropsMode: () => (/* binding */ MassPropsMode)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/coefficient_combine_rule.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shape */ \"./node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _shape__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _shape__WEBPACK_IMPORTED_MODULE_1__, _point__WEBPACK_IMPORTED_MODULE_2__, _toi__WEBPACK_IMPORTED_MODULE_3__, _contact__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__, _pipeline__WEBPACK_IMPORTED_MODULE_7__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nvar ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nclass Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = _shape__WEBPACK_IMPORTED_MODULE_1__.Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Set the internal cached JS shape to null.\n     *\n     * This can be useful if you want to free some memory (assuming you are not\n     * holding any other references to the shape object), or in order to force\n     * the recalculation of the JS shape (the next time the `shape` getter is\n     * accessed) from the WASM source of truth.\n     */\n    clearShapeCache() {\n        this._shape = null;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The collider’s new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body won’t be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     */\n    contactSkin() {\n        return this.colliderSet.raw.coContactSkin(this.handle);\n    }\n    /**\n     * Sets the contact skin for this collider.\n     *\n     * See the documentation of `ColliderDesc.setContactSkin` for additional details.\n     *\n     * @param thickness - The contact skin thickness.\n     */\n    setContactSkin(thickness) {\n        return this.colliderSet.raw.coSetContactSkin(this.handle, thickness);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM2\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(centerOfMass);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, principalAngularInertia);\n        rawCom.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM2\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y);\n        // #endif\n    }\n    // #if DIM2\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotation(angle) {\n        this.colliderSet.raw.coSetRotation(this.handle, angle);\n    }\n    /**\n     * Sets the rotation angle of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param angle - The rotation angle, in radians.\n     */\n    setRotationWrtParent(angle) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, angle);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a Voxels shape, this will mark the voxel at the\n     * given grid coordinates as filled or empty (depending on the `filled`\n     * argument).\n     *\n     * Each input value is assumed to be an integer.\n     *\n     * The operation is O(1), unless the provided coordinates are out of the\n     * bounds of the currently allocated internal grid in which case the grid\n     * will be grown automatically.\n     */\n    setVoxel(ix, iy, filled) {\n        this.colliderSet.raw.coSetVoxel(this.handle, ix, iy, filled);\n        // We modified the shape, invalidate it to keep our cache\n        // up-to-date the next time the user requests the shape data.\n        // PERF: this isn’t ideal for performances as this adds a\n        //       hidden, non-constant, cost.\n        this._shape = null;\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(scale);\n    }\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        let result = _point__WEBPACK_IMPORTED_MODULE_2__.PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = _toi__WEBPACK_IMPORTED_MODULE_3__.ShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, targetDistance, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(collider2Vel);\n        let result = _toi__WEBPACK_IMPORTED_MODULE_3__.ColliderShapeCastHit.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, targetDistance, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = _contact__WEBPACK_IMPORTED_MODULE_4__.ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let result = _ray__WEBPACK_IMPORTED_MODULE_5__.RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nvar MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nclass ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.identity();\n        this.translation = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n        this.restitutionCombineRule = _dynamics__WEBPACK_IMPORTED_MODULE_6__.CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = _pipeline__WEBPACK_IMPORTED_MODULE_7__.ActiveEvents.NONE;\n        this.activeHooks = _pipeline__WEBPACK_IMPORTED_MODULE_8__.ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        this.contactSkin = 0.0;\n        // #if DIM2\n        this.principalAngularInertia = 0.0;\n        this.rotationsEnabled = true;\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a shape made of voxels.\n     *\n     * @param data - Defines the set of voxels. If this is a `Int32Array` then\n     *               each voxel is defined from its (signed) grid coordinates,\n     *               with 3 (resp 2) contiguous integers per voxel in 3D (resp 2D).\n     *               If this is a `Float32Array`, each voxel will be such that\n     *               they contain at least one point from this array (where each\n     *               point is defined from 3 (resp 2) contiguous numbers per point\n     *               in 3D (resp 2D).\n     * @param voxelSize - The size of each voxel.\n     */\n    static voxels(voxels, voxelSize) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Voxels(voxels, voxelSize);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices, flags) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.TriMesh(vertices, indices, flags);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM2\n    /**\n     * Creates a new collider descriptor with a rectangular shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     */\n    static cuboid(hx, hy) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Cuboid(hx, hy);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.RoundCuboid(hx, hy, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider description with a halfspace (infinite plane) shape.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    static halfspace(normal) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.HalfSpace(normal);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(heights, scale) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.Heightfield(heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.ConvexPolygon(points, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexPolyline(vertices) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.ConvexPolygon(vertices, true);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polygon as the shape for this new collider descriptor. A\n     * border is added to that convex polygon to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polygon.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.RoundConvexPolygon(points, borderRadius, false);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const shape = new _shape__WEBPACK_IMPORTED_MODULE_1__.RoundConvexPolygon(vertices, borderRadius, true);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM2\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y) {\n        if (typeof x != \"number\" || typeof y != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM2\n        this.rotation = rot;\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled − If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the contact skin of the collider.\n     *\n     * The contact skin acts as if the collider was enlarged with a skin of width `skin_thickness`\n     * around it, keeping objects further apart when colliding.\n     *\n     * A non-zero contact skin can increase performance, and in some cases, stability. However\n     * it creates a small gap between colliding object (equal to the sum of their skin). If the\n     * skin is sufficiently small, this might not be visually significant or can be hidden by the\n     * rendering assets.\n     */\n    setContactSkin(thickness) {\n        this.contactSkin = thickness;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the collider’s shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the collider’s shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM2\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass − The mass of the collider to create.\n     * @param centerOfMass − The center-of-mass of the collider to create.\n     * @param principalAngularInertia − The principal angular inertia of the collider to create.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.copy(this.centerOfMass, centerOfMass);\n        this.principalAngularInertia = principalAngularInertia;\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule − The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/collider.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/collider_set.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/collider_set.js ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderSet: () => (/* binding */ ColliderSet)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _coarena__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../coarena */ \"./node_modules/@dimforge/rapier2d/coarena.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collider */ \"./node_modules/@dimforge/rapier2d/geometry/collider.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass ColliderSet {\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet();\n        this.map = new _coarena__WEBPACK_IMPORTED_MODULE_1__.Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new _collider__WEBPACK_IMPORTED_MODULE_3__.Collider(this, handle, null));\n            });\n        }\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = _math__WEBPACK_IMPORTED_MODULE_2__.VectorOps.intoRaw(desc.translation);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_2__.RotationOps.intoRaw(desc.rotation);\n        let rawCom = _math__WEBPACK_IMPORTED_MODULE_2__.VectorOps.intoRaw(desc.centerOfMass);\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM2\n        desc.principalAngularInertia, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, desc.contactSkin, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new _collider__WEBPACK_IMPORTED_MODULE_3__.Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/collider_set.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/contact.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/contact.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ShapeContact: () => (/* binding */ ShapeContact)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The contact info between two shapes.\n */\nclass ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/contact.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/feature.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/feature.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FeatureType: () => (/* binding */ FeatureType)\n/* harmony export */ });\n// #if DIM2\nvar FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Face\"] = 1] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 2] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/feature.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ActiveCollisionTypes),\n/* harmony export */   Ball: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _broad_phase__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   Capsule: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Capsule),\n/* harmony export */   Collider: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _collider_set__WEBPACK_IMPORTED_MODULE_4__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Cuboid),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _feature__WEBPACK_IMPORTED_MODULE_5__.FeatureType),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Heightfield),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _collider__WEBPACK_IMPORTED_MODULE_3__.MassPropsMode),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.NarrowPhase),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _point__WEBPACK_IMPORTED_MODULE_7__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Polyline),\n/* harmony export */   Ray: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _ray__WEBPACK_IMPORTED_MODULE_6__.RayIntersection),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Segment),\n/* harmony export */   Shape: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _toi__WEBPACK_IMPORTED_MODULE_8__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _contact__WEBPACK_IMPORTED_MODULE_9__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.ShapeType),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _narrow_phase__WEBPACK_IMPORTED_MODULE_1__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Triangle),\n/* harmony export */   Voxels: () => (/* reexport safe */ _shape__WEBPACK_IMPORTED_MODULE_2__.Voxels)\n/* harmony export */ });\n/* harmony import */ var _broad_phase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./broad_phase */ \"./node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _narrow_phase__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./narrow_phase */ \"./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _shape__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shape */ \"./node_modules/@dimforge/rapier2d/geometry/shape.js\");\n/* harmony import */ var _collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./collider */ \"./node_modules/@dimforge/rapier2d/geometry/collider.js\");\n/* harmony import */ var _collider_set__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./collider_set */ \"./node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__]);\n([_broad_phase__WEBPACK_IMPORTED_MODULE_0__, _narrow_phase__WEBPACK_IMPORTED_MODULE_1__, _shape__WEBPACK_IMPORTED_MODULE_2__, _collider__WEBPACK_IMPORTED_MODULE_3__, _collider_set__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_6__, _point__WEBPACK_IMPORTED_MODULE_7__, _toi__WEBPACK_IMPORTED_MODULE_8__, _contact__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js ***!
  \******************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NarrowPhase: () => (/* binding */ NarrowPhase),\n/* harmony export */   TempContactManifold: () => (/* binding */ TempContactManifold)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nclass NarrowPhase {\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nclass TempContactManifold {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw;\n    }\n    normal() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM2\n    contactTangentImpulse(i) {\n        return this.raw.contact_tangent_impulse(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/point.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/point.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PointColliderProjection: () => (/* binding */ PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* binding */ PointProjection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/**\n * The projection of a point on a collider.\n */\nclass PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nclass PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_1__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/point.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/ray.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/ray.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ray: () => (/* binding */ Ray),\n/* harmony export */   RayColliderHit: () => (/* binding */ RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* binding */ RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* binding */ RayIntersection)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _feature__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature */ \"./node_modules/@dimforge/rapier2d/geometry/feature.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/**\n * A ray. This is a directed half-line.\n */\nclass Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nclass RayIntersection {\n    constructor(timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_1__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nclass RayColliderIntersection {\n    constructor(collider, timeOfImpact, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = _feature__WEBPACK_IMPORTED_MODULE_1__.FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nclass RayColliderHit {\n    constructor(collider, timeOfImpact) {\n        this.collider = collider;\n        this.timeOfImpact = timeOfImpact;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderHit(colliderSet.get(raw.colliderHandle()), raw.timeOfImpact());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/ray.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/shape.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/shape.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ball: () => (/* binding */ Ball),\n/* harmony export */   Capsule: () => (/* binding */ Capsule),\n/* harmony export */   ConvexPolygon: () => (/* binding */ ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* binding */ Cuboid),\n/* harmony export */   HalfSpace: () => (/* binding */ HalfSpace),\n/* harmony export */   Heightfield: () => (/* binding */ Heightfield),\n/* harmony export */   Polyline: () => (/* binding */ Polyline),\n/* harmony export */   RoundConvexPolygon: () => (/* binding */ RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* binding */ RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* binding */ RoundTriangle),\n/* harmony export */   Segment: () => (/* binding */ Segment),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeType: () => (/* binding */ ShapeType),\n/* harmony export */   TriMesh: () => (/* binding */ TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* binding */ TriMeshFlags),\n/* harmony export */   Triangle: () => (/* binding */ Triangle),\n/* harmony export */   Voxels: () => (/* binding */ Voxels)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _contact__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./contact */ \"./node_modules/@dimforge/rapier2d/geometry/contact.js\");\n/* harmony import */ var _point__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _ray__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ray */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _toi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toi */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__, _toi__WEBPACK_IMPORTED_MODULE_2__, _contact__WEBPACK_IMPORTED_MODULE_3__, _point__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _raw__WEBPACK_IMPORTED_MODULE_1__, _toi__WEBPACK_IMPORTED_MODULE_2__, _contact__WEBPACK_IMPORTED_MODULE_3__, _point__WEBPACK_IMPORTED_MODULE_4__, _ray__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\nclass Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM2\n                return new Cuboid(extents.x, extents.y);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundCuboid(extents.x, extents.y, borderRadius);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Segment(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[2], vs[3]));\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM2\n                return new Triangle(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[4], vs[5]));\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM2\n                return new RoundTriangle(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[0], vs[1]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[2], vs[3]), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(vs[4], vs[5]), borderRadius);\n            // #endif\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.HalfSpace:\n                normal = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.Voxels:\n                const vox_data = rawSet.coVoxelData(handle);\n                const vox_size = rawSet.coVoxelSize(handle);\n                return new Voxels(vox_data, vox_size);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                const tri_flags = rawSet.coTriMeshFlags(handle);\n                return new TriMesh(vs, indices, tri_flags);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM2\n                return new Heightfield(heights, scale);\n            // #endif\n            // #if DIM2\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.ConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                return new ConvexPolygon(vs, false);\n            case _raw__WEBPACK_IMPORTED_MODULE_1__.RawShapeType.RoundConvexPolygon:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolygon(vs, borderRadius, false);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, targetDistance, maxToi, stopAtPenetration) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = _toi__WEBPACK_IMPORTED_MODULE_2__.ShapeCastHit.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, targetDistance, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they don’t.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos1);\n        let rawRot1 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos2);\n        let rawRot2 = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = _contact__WEBPACK_IMPORTED_MODULE_3__.ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = _point__WEBPACK_IMPORTED_MODULE_4__.PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_0__.RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.origin);\n        let rawRayDir = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = _ray__WEBPACK_IMPORTED_MODULE_5__.RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM2\n/**\n * An enumeration representing the type of a shape.\n */\nvar ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolygon\"] = 9] = \"ConvexPolygon\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 10] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 11] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundConvexPolygon\"] = 12] = \"RoundConvexPolygon\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 13] = \"HalfSpace\";\n    ShapeType[ShapeType[\"Voxels\"] = 14] = \"Voxels\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n// NOTE: this **must** match the TriMeshFlags on the rust side.\n/**\n * Flags controlling the behavior of the triangle mesh creation and of some\n * operations involving triangle meshes.\n */\nvar TriMeshFlags;\n(function (TriMeshFlags) {\n    // NOTE: these two flags are not really useful in JS.\n    //\n    // /**\n    //  * If set, the half-edge topology of the trimesh will be computed if possible.\n    //  */\n    // HALF_EDGE_TOPOLOGY = 0b0000_0001,\n    // /** If set, the half-edge topology and connected components of the trimesh will be computed if possible.\n    //  *\n    //  * Because of the way it is currently implemented, connected components can only be computed on\n    //  * a mesh where the half-edge topology computation succeeds. It will no longer be the case in the\n    //  * future once we decouple the computations.\n    //  */\n    // CONNECTED_COMPONENTS = 0b0000_0010,\n    /**\n     * If set, any triangle that results in a failing half-hedge topology computation will be deleted.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_BAD_TOPOLOGY_TRIANGLES\"] = 4] = \"DELETE_BAD_TOPOLOGY_TRIANGLES\";\n    /**\n     * If set, the trimesh will be assumed to be oriented (with outward normals).\n     *\n     * The pseudo-normals of its vertices and edges will be computed.\n     */\n    TriMeshFlags[TriMeshFlags[\"ORIENTED\"] = 8] = \"ORIENTED\";\n    /**\n     * If set, the duplicate vertices of the trimesh will be merged.\n     *\n     * Two vertices with the exact same coordinates will share the same entry on the\n     * vertex buffer and the index buffer is adjusted accordingly.\n     */\n    TriMeshFlags[TriMeshFlags[\"MERGE_DUPLICATE_VERTICES\"] = 16] = \"MERGE_DUPLICATE_VERTICES\";\n    /**\n     * If set, the triangles sharing two vertices with identical index values will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DEGENERATE_TRIANGLES\"] = 32] = \"DELETE_DEGENERATE_TRIANGLES\";\n    /**\n     * If set, two triangles sharing three vertices with identical index values (in any order)\n     * will be removed.\n     *\n     * Because of the way it is currently implemented, this methods implies that duplicate\n     * vertices will be merged. It will no longer be the case in the future once we decouple\n     * the computations.\n     */\n    TriMeshFlags[TriMeshFlags[\"DELETE_DUPLICATE_TRIANGLES\"] = 64] = \"DELETE_DUPLICATE_TRIANGLES\";\n    /**\n     * If set, a special treatment will be applied to contact manifold calculation to eliminate\n     * or fix contacts normals that could lead to incorrect bumps in physics simulation\n     * (especially on flat surfaces).\n     *\n     * This is achieved by taking into account adjacent triangle normals when computing contact\n     * points for a given triangle.\n     *\n     * /!\\ NOT SUPPORTED IN THE 2D VERSION OF RAPIER.\n     */\n    TriMeshFlags[TriMeshFlags[\"FIX_INTERNAL_EDGES\"] = 144] = \"FIX_INTERNAL_EDGES\";\n})(TriMeshFlags || (TriMeshFlags = {}));\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nclass Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.ball(this.radius);\n    }\n}\nclass HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.normal);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nclass Cuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     */\n    constructor(hx, hy) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(hx, hy);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.cuboid(this.halfExtents.x, this.halfExtents.y);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nclass RoundCuboid extends Shape {\n    // #if DIM2\n    /**\n     * Creates a new 2D rectangle.\n     * @param hx - The half width of the rectangle.\n     * @param hy - The helf height of the rectangle.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.new(hx, hy);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM2\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nclass Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nclass Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nclass Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n        let rc = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.c);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nclass RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.a);\n        let rb = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.b);\n        let rc = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.c);\n        let result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nclass Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape made of voxels.\n */\nclass Voxels extends Shape {\n    /**\n     * Creates a new shape made of voxels.\n     *\n     * @param data - Defines the set of voxels. If this is a `Int32Array` then\n     *               each voxel is defined from its (signed) grid coordinates,\n     *               with 3 (resp 2) contiguous integers per voxel in 3D (resp 2D).\n     *               If this is a `Float32Array`, each voxel will be such that\n     *               they contain at least one point from this array (where each\n     *               point is defined from 3 (resp 2) contiguous numbers per point\n     *               in 3D (resp 2D).\n     * @param voxelSize - The size of each voxel.\n     */\n    constructor(data, voxelSize) {\n        super();\n        this.type = ShapeType.Voxels;\n        this.data = data;\n        this.voxelSize = voxelSize;\n    }\n    intoRaw() {\n        let voxelSize = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.voxelSize);\n        let result;\n        if (this.data instanceof Int32Array) {\n            result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.voxels(voxelSize, this.data);\n        }\n        else {\n            result = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.voxelsFromPoints(voxelSize, this.data);\n        }\n        voxelSize.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nclass TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices, flags) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.flags = flags;\n    }\n    intoRaw() {\n        return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.trimesh(this.vertices, this.indices, this.flags);\n    }\n}\n// #if DIM2\n/**\n * A shape that is a convex polygon.\n */\nclass ConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.ConvexPolygon;\n        this.vertices = vertices;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.convexPolyline(this.vertices);\n        }\n        else {\n            return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nclass RoundConvexPolygon extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param borderRadius - The radius of the borders of this convex polygon.\n     * @param skipConvexHullComputation - If set to `true`, the input points will\n     *   be assumed to form a convex polyline and no convex-hull computation will\n     *   be done automatically.\n     */\n    constructor(vertices, borderRadius, skipConvexHullComputation) {\n        super();\n        this.type = ShapeType.RoundConvexPolygon;\n        this.vertices = vertices;\n        this.borderRadius = borderRadius;\n        this.skipConvexHullComputation = !!skipConvexHullComputation;\n    }\n    intoRaw() {\n        if (this.skipConvexHullComputation) {\n            return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.roundConvexPolyline(this.vertices, this.borderRadius);\n        }\n        else {\n            return _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nclass Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param heights - The heights of the heightfield, along its local `y` axis.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    constructor(heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.intoRaw(this.scale);\n        let rawShape = _raw__WEBPACK_IMPORTED_MODULE_1__.RawShape.heightfield(this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/shape.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/geometry/toi.js":
/*!*********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/geometry/toi.js ***!
  \*********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderShapeCastHit: () => (/* binding */ ColliderShapeCastHit),\n/* harmony export */   ShapeCastHit: () => (/* binding */ ShapeCastHit)\n/* harmony export */ });\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__]);\n_math__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The intersection between a ray and a collider.\n */\nclass ShapeCastHit {\n    constructor(time_of_impact, witness1, witness2, normal1, normal2) {\n        this.time_of_impact = time_of_impact;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeCastHit(raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nclass ColliderShapeCastHit extends ShapeCastHit {\n    constructor(collider, time_of_impact, witness1, witness2, normal1, normal2) {\n        super(time_of_impact, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ColliderShapeCastHit(colliderSet.get(raw.colliderHandle()), raw.time_of_impact(), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.witness2()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal1()), _math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/geometry/toi.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/init.js":
/*!*************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/init.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceMappingURL=init.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/init.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/math.js":
/*!*************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/math.js ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RotationOps: () => (/* binding */ RotationOps),\n/* harmony export */   Vector2: () => (/* binding */ Vector2),\n/* harmony export */   VectorOps: () => (/* binding */ VectorOps)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * A 2D vector.\n */\nclass Vector2 {\n    constructor(x, y) {\n        this.x = x;\n        this.y = y;\n    }\n}\nclass VectorOps {\n    static new(x, y) {\n        return new Vector2(x, y);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y);\n        raw.free();\n        return res;\n    }\n    static intoRaw(v) {\n        return new _raw__WEBPACK_IMPORTED_MODULE_0__.RawVector(v.x, v.y);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n    }\n}\nclass RotationOps {\n    static identity() {\n        return 0.0;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = raw.angle;\n        raw.free();\n        return res;\n    }\n    static intoRaw(angle) {\n        return _raw__WEBPACK_IMPORTED_MODULE_0__.RawRotation.fromAngle(angle);\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/math.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js ***!
  \***************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DebugRenderBuffers: () => (/* binding */ DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* binding */ DebugRenderPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__]);\n_raw__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nclass DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass DebugRenderPipeline {\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline();\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/event_queue.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/event_queue.js ***!
  \*****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* binding */ ActiveEvents),\n/* harmony export */   EventQueue: () => (/* binding */ EventQueue),\n/* harmony export */   TempContactForceEvent: () => (/* binding */ TempContactForceEvent)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n/**\n * Flags indicating what events are enabled for colliders.\n */\nvar ActiveEvents;\n(function (ActiveEvents) {\n    ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nclass TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nclass EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/event_queue.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/index.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.ActiveHooks),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.EventQueue),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__.PhysicsPipeline),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _query_pipeline__WEBPACK_IMPORTED_MODULE_6__.QueryPipeline),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__.SerializationPipeline),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _physics_hooks__WEBPACK_IMPORTED_MODULE_4__.SolverFlags),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _event_queue__WEBPACK_IMPORTED_MODULE_3__.TempContactForceEvent),\n/* harmony export */   World: () => (/* reexport safe */ _world__WEBPACK_IMPORTED_MODULE_0__.World)\n/* harmony export */ });\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./world */ \"./node_modules/@dimforge/rapier2d/pipeline/world.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./physics_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serialization_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _event_queue__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./event_queue */ \"./node_modules/@dimforge/rapier2d/pipeline/event_queue.js\");\n/* harmony import */ var _physics_hooks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./physics_hooks */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./debug_render_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./query_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__]);\n([_world__WEBPACK_IMPORTED_MODULE_0__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_1__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_2__, _event_queue__WEBPACK_IMPORTED_MODULE_3__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_5__, _query_pipeline__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n//# sourceMappingURL=index.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/index.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveHooks: () => (/* binding */ ActiveHooks),\n/* harmony export */   SolverFlags: () => (/* binding */ SolverFlags)\n/* harmony export */ });\nvar ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nvar SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/physics_hooks.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js ***!
  \**********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPipeline: () => (/* binding */ PhysicsPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\nclass PhysicsPipeline {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline();\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js":
/*!********************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js ***!
  \********************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   QueryFilterFlags: () => (/* binding */ QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* binding */ QueryPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/ray.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/point.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/toi.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _geometry__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nvar QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass QueryPipeline {\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline();\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(colliders) {\n        this.raw.update(colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderHit.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.origin);\n        let rawDir = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(_geometry__WEBPACK_IMPORTED_MODULE_2__.RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_3__.PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                       will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawVel = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = _geometry__WEBPACK_IMPORTED_MODULE_4__.ColliderShapeCastHit.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(shapePos);\n        let rawRot = _math__WEBPACK_IMPORTED_MODULE_1__.RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js ***!
  \****************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SerializationPipeline: () => (/* binding */ SerializationPipeline)\n/* harmony export */ });\n/* harmony import */ var _raw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../raw */ \"./node_modules/@dimforge/rapier2d/raw.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _world__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./world */ \"./node_modules/@dimforge/rapier2d/pipeline/world.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__]);\n([_raw__WEBPACK_IMPORTED_MODULE_0__, _math__WEBPACK_IMPORTED_MODULE_1__, _world__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nclass SerializationPipeline {\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    constructor(raw) {\n        this.raw = raw || new _raw__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline();\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = _math__WEBPACK_IMPORTED_MODULE_1__.VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return _world__WEBPACK_IMPORTED_MODULE_2__.World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/pipeline/world.js":
/*!***********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/pipeline/world.js ***!
  \***********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   World: () => (/* binding */ World)\n/* harmony export */ });\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/broad_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/narrow_phase.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../geometry */ \"./node_modules/@dimforge/rapier2d/geometry/collider_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/integration_parameters.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/island_manager.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/rigid_body_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/impulse_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/multibody_joint_set.js\");\n/* harmony import */ var _dynamics__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dynamics */ \"./node_modules/@dimforge/rapier2d/dynamics/ccd_solver.js\");\n/* harmony import */ var _math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math */ \"./node_modules/@dimforge/rapier2d/math.js\");\n/* harmony import */ var _physics_pipeline__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./physics_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/physics_pipeline.js\");\n/* harmony import */ var _query_pipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./query_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/query_pipeline.js\");\n/* harmony import */ var _serialization_pipeline__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./serialization_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/serialization_pipeline.js\");\n/* harmony import */ var _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./debug_render_pipeline */ \"./node_modules/@dimforge/rapier2d/pipeline/debug_render_pipeline.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../control */ \"./node_modules/@dimforge/rapier2d/control/character_controller.js\");\n/* harmony import */ var _control__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../control */ \"./node_modules/@dimforge/rapier2d/control/pid_controller.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_math__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__, _dynamics__WEBPACK_IMPORTED_MODULE_5__, _geometry__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _dynamics__WEBPACK_IMPORTED_MODULE_9__, _query_pipeline__WEBPACK_IMPORTED_MODULE_10__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_11__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_12__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__, _control__WEBPACK_IMPORTED_MODULE_15__]);\n([_math__WEBPACK_IMPORTED_MODULE_0__, _dynamics__WEBPACK_IMPORTED_MODULE_1__, _dynamics__WEBPACK_IMPORTED_MODULE_2__, _geometry__WEBPACK_IMPORTED_MODULE_3__, _geometry__WEBPACK_IMPORTED_MODULE_4__, _dynamics__WEBPACK_IMPORTED_MODULE_5__, _geometry__WEBPACK_IMPORTED_MODULE_6__, _dynamics__WEBPACK_IMPORTED_MODULE_7__, _dynamics__WEBPACK_IMPORTED_MODULE_8__, _dynamics__WEBPACK_IMPORTED_MODULE_9__, _query_pipeline__WEBPACK_IMPORTED_MODULE_10__, _physics_pipeline__WEBPACK_IMPORTED_MODULE_11__, _serialization_pipeline__WEBPACK_IMPORTED_MODULE_12__, _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_13__, _control__WEBPACK_IMPORTED_MODULE_14__, _control__WEBPACK_IMPORTED_MODULE_15__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nclass World {\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        this.pidControllers.forEach((controller) => controller.free());\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n        this.pidControllers = undefined;\n    }\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new _dynamics__WEBPACK_IMPORTED_MODULE_1__.IntegrationParameters(rawIntegrationParameters);\n        this.islands = new _dynamics__WEBPACK_IMPORTED_MODULE_2__.IslandManager(rawIslands);\n        this.broadPhase = new _geometry__WEBPACK_IMPORTED_MODULE_3__.BroadPhase(rawBroadPhase);\n        this.narrowPhase = new _geometry__WEBPACK_IMPORTED_MODULE_4__.NarrowPhase(rawNarrowPhase);\n        this.bodies = new _dynamics__WEBPACK_IMPORTED_MODULE_5__.RigidBodySet(rawBodies);\n        this.colliders = new _geometry__WEBPACK_IMPORTED_MODULE_6__.ColliderSet(rawColliders);\n        this.impulseJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_7__.ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new _dynamics__WEBPACK_IMPORTED_MODULE_8__.MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new _dynamics__WEBPACK_IMPORTED_MODULE_9__.CCDSolver(rawCCDSolver);\n        this.queryPipeline = new _query_pipeline__WEBPACK_IMPORTED_MODULE_10__.QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new _physics_pipeline__WEBPACK_IMPORTED_MODULE_11__.PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_12__.SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_13__.DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        this.pidControllers = new Set();\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(_math__WEBPACK_IMPORTED_MODULE_0__.VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new _serialization_pipeline__WEBPACK_IMPORTED_MODULE_12__.SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new _debug_render_pipeline__WEBPACK_IMPORTED_MODULE_13__.DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * See the documentation of the `World.lengthUnit` setter for further details.\n     */\n    get lengthUnit() {\n        return this.integrationParameters.lengthUnit;\n    }\n    /**\n     * The approximate size of most dynamic objects in the scene.\n     *\n     * This value is used internally to estimate some length-based tolerance. In particular, the\n     * values `IntegrationParameters.allowedLinearError`,\n     * `IntegrationParameters.maxPenetrationCorrection`,\n     * `IntegrationParameters.predictionDistance`, `RigidBodyActivation.linearThreshold`\n     * are scaled by this value implicitly.\n     *\n     * This value can be understood as the number of units-per-meter in your physical world compared\n     * to a human-sized world in meter. For example, in a 2d game, if your typical object size is 100\n     * pixels, set the `[`Self::length_unit`]` parameter to 100.0. The physics engine will interpret\n     * it as if 100 pixels is equivalent to 1 meter in its various internal threshold.\n     * (default `1.0`).\n     */\n    set lengthUnit(unitsPerMeter) {\n        this.integrationParameters.lengthUnit = unitsPerMeter;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12. Warmstarting is disabled.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        this.integrationParameters.switchToSmallStepsPgsSolverWithoutWarmstart();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the character’s chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new _control__WEBPACK_IMPORTED_MODULE_14__.KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    /**\n     * Creates a new PID (Proportional-Integral-Derivative) controller.\n     *\n     * @param kp - The Proportional gain applied to the instantaneous linear position errors.\n     *             This is usually set to a multiple of the inverse of simulation step time\n     *             (e.g. `60` if the delta-time is `1.0 / 60.0`).\n     * @param ki - The linear gain applied to the Integral part of the PID controller.\n     * @param kd - The Derivative gain applied to the instantaneous linear velocity errors.\n     *             This is usually set to a value in `[0.0, 1.0]` where `0.0` implies no damping\n     *             (no correction of velocity errors) and `1.0` implies complete damping (velocity errors\n     *             are corrected in a single simulation step).\n     * @param axes - The axes affected by this controller.\n     *               Only coordinate axes with a bit flags set to `true` will be taken into\n     *               account when calculating the errors and corrections.\n     */\n    createPidController(kp, ki, kd, axes) {\n        let controller = new _control__WEBPACK_IMPORTED_MODULE_15__.PidController(this.integrationParameters, this.bodies, kp, ki, kd, axes);\n        this.pidControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a PID controller from this world.\n     *\n     * @param controller - The PID controller to remove.\n     */\n    removePidController(controller) {\n        this.pidControllers.delete(controller);\n        controller.free();\n    }\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param targetDistance − If the shape moves closer to this distance from a collider, a hit\n     *                         will be returned.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast won’t immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that it’s on a path to exit that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, targetDistance, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1 − The first collider involved in the intersection.\n     * @param collider2 − The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/pipeline/world.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier.js":
/*!***************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier.js ***!
  \***************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ActiveCollisionTypes: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveCollisionTypes),\n/* harmony export */   ActiveEvents: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveEvents),\n/* harmony export */   ActiveHooks: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ActiveHooks),\n/* harmony export */   Ball: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ball),\n/* harmony export */   BroadPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.BroadPhase),\n/* harmony export */   CCDSolver: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CCDSolver),\n/* harmony export */   Capsule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Capsule),\n/* harmony export */   CharacterCollision: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CharacterCollision),\n/* harmony export */   CoefficientCombineRule: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.CoefficientCombineRule),\n/* harmony export */   Collider: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Collider),\n/* harmony export */   ColliderDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderDesc),\n/* harmony export */   ColliderSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderSet),\n/* harmony export */   ColliderShapeCastHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ColliderShapeCastHit),\n/* harmony export */   ConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ConvexPolygon),\n/* harmony export */   Cuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Cuboid),\n/* harmony export */   DebugRenderBuffers: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderBuffers),\n/* harmony export */   DebugRenderPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.DebugRenderPipeline),\n/* harmony export */   EventQueue: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.EventQueue),\n/* harmony export */   FeatureType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FeatureType),\n/* harmony export */   FixedImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedImpulseJoint),\n/* harmony export */   FixedMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.FixedMultibodyJoint),\n/* harmony export */   HalfSpace: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.HalfSpace),\n/* harmony export */   Heightfield: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Heightfield),\n/* harmony export */   ImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJoint),\n/* harmony export */   ImpulseJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ImpulseJointSet),\n/* harmony export */   IntegrationParameters: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IntegrationParameters),\n/* harmony export */   IslandManager: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.IslandManager),\n/* harmony export */   JointAxesMask: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointAxesMask),\n/* harmony export */   JointData: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointData),\n/* harmony export */   JointType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.JointType),\n/* harmony export */   KinematicCharacterController: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.KinematicCharacterController),\n/* harmony export */   MassPropsMode: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MassPropsMode),\n/* harmony export */   MotorModel: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MotorModel),\n/* harmony export */   MultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJoint),\n/* harmony export */   MultibodyJointSet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.MultibodyJointSet),\n/* harmony export */   NarrowPhase: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.NarrowPhase),\n/* harmony export */   PhysicsPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PhysicsPipeline),\n/* harmony export */   PidAxesMask: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PidAxesMask),\n/* harmony export */   PidController: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PidController),\n/* harmony export */   PointColliderProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointColliderProjection),\n/* harmony export */   PointProjection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PointProjection),\n/* harmony export */   Polyline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Polyline),\n/* harmony export */   PrismaticImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticImpulseJoint),\n/* harmony export */   PrismaticMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.PrismaticMultibodyJoint),\n/* harmony export */   QueryFilterFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryFilterFlags),\n/* harmony export */   QueryPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.QueryPipeline),\n/* harmony export */   Ray: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Ray),\n/* harmony export */   RayColliderHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderHit),\n/* harmony export */   RayColliderIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayColliderIntersection),\n/* harmony export */   RayIntersection: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RayIntersection),\n/* harmony export */   RevoluteImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteImpulseJoint),\n/* harmony export */   RevoluteMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RevoluteMultibodyJoint),\n/* harmony export */   RigidBody: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBody),\n/* harmony export */   RigidBodyDesc: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyDesc),\n/* harmony export */   RigidBodySet: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodySet),\n/* harmony export */   RigidBodyType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RigidBodyType),\n/* harmony export */   RopeImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RopeImpulseJoint),\n/* harmony export */   RotationOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RotationOps),\n/* harmony export */   RoundConvexPolygon: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundConvexPolygon),\n/* harmony export */   RoundCuboid: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundCuboid),\n/* harmony export */   RoundTriangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.RoundTriangle),\n/* harmony export */   Segment: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Segment),\n/* harmony export */   SerializationPipeline: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SerializationPipeline),\n/* harmony export */   Shape: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Shape),\n/* harmony export */   ShapeCastHit: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeCastHit),\n/* harmony export */   ShapeContact: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeContact),\n/* harmony export */   ShapeType: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.ShapeType),\n/* harmony export */   SolverFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SolverFlags),\n/* harmony export */   SpringImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.SpringImpulseJoint),\n/* harmony export */   TempContactForceEvent: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactForceEvent),\n/* harmony export */   TempContactManifold: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TempContactManifold),\n/* harmony export */   TriMesh: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMesh),\n/* harmony export */   TriMeshFlags: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.TriMeshFlags),\n/* harmony export */   Triangle: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Triangle),\n/* harmony export */   UnitImpulseJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitImpulseJoint),\n/* harmony export */   UnitMultibodyJoint: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.UnitMultibodyJoint),\n/* harmony export */   Vector2: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Vector2),\n/* harmony export */   VectorOps: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.VectorOps),\n/* harmony export */   Voxels: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.Voxels),\n/* harmony export */   World: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.World),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   version: () => (/* reexport safe */ _exports__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _exports__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./exports */ \"./node_modules/@dimforge/rapier2d/exports.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_exports__WEBPACK_IMPORTED_MODULE_0__]);\n_exports__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_exports__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceMappingURL=rapier.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/rapier.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d.js ***!
  \**********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet),\n/* harmony export */   RawColliderShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawColliderShapeCastHit),\n/* harmony export */   RawContactForceEvent: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis),\n/* harmony export */   RawJointType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline),\n/* harmony export */   RawPidController: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPidController),\n/* harmony export */   RawPointColliderProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline),\n/* harmony export */   RawRayColliderHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderHit),\n/* harmony export */   RawRayColliderIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderIntersection),\n/* harmony export */   RawRayIntersection: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShape),\n/* harmony export */   RawShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeCastHit),\n/* harmony export */   RawShapeContact: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeContact),\n/* harmony export */   RawShapeType: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawShapeType),\n/* harmony export */   RawVector: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.RawVector),\n/* harmony export */   __wbg_bind_c8359b1cba058168: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_bind_c8359b1cba058168),\n/* harmony export */   __wbg_buffer_609cc3eee51ed158: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_609cc3eee51ed158),\n/* harmony export */   __wbg_call_7cccdd69e0791ae2: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_7cccdd69e0791ae2),\n/* harmony export */   __wbg_call_833bed5770ea2041: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_833bed5770ea2041),\n/* harmony export */   __wbg_call_b8adc8b1d0a0d8eb: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_b8adc8b1d0a0d8eb),\n/* harmony export */   __wbg_length_3b4f022188ae8db6: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_3b4f022188ae8db6),\n/* harmony export */   __wbg_length_a446193dc22c12f8: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_a446193dc22c12f8),\n/* harmony export */   __wbg_new_a12002a7f91c75be: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_a12002a7f91c75be),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354),\n/* harmony export */   __wbg_newwithlength_5a5efe313cfd59f1: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_5a5efe313cfd59f1),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_10bad9bee0e9c58b: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_10bad9bee0e9c58b),\n/* harmony export */   __wbg_set_65595bdd868b3009: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_65595bdd868b3009),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   version: () => (/* reexport safe */ _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rapier_wasm2d_bg.wasm */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm\");\n/* harmony import */ var _rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__]);\n_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n(0,_rapier_wasm2d_bg_js__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm)(_rapier_wasm2d_bg_wasm__WEBPACK_IMPORTED_MODULE_1__);\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/rapier_wasm2d.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js":
/*!*************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* binding */ RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* binding */ RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* binding */ RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* binding */ RawColliderSet),\n/* harmony export */   RawColliderShapeCastHit: () => (/* binding */ RawColliderShapeCastHit),\n/* harmony export */   RawContactForceEvent: () => (/* binding */ RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* binding */ RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* binding */ RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* binding */ RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* binding */ RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* binding */ RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* binding */ RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* binding */ RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* binding */ RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* binding */ RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* binding */ RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* binding */ RawJointAxis),\n/* harmony export */   RawJointType: () => (/* binding */ RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* binding */ RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* binding */ RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* binding */ RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* binding */ RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* binding */ RawPhysicsPipeline),\n/* harmony export */   RawPidController: () => (/* binding */ RawPidController),\n/* harmony export */   RawPointColliderProjection: () => (/* binding */ RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* binding */ RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* binding */ RawQueryPipeline),\n/* harmony export */   RawRayColliderHit: () => (/* binding */ RawRayColliderHit),\n/* harmony export */   RawRayColliderIntersection: () => (/* binding */ RawRayColliderIntersection),\n/* harmony export */   RawRayIntersection: () => (/* binding */ RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* binding */ RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* binding */ RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* binding */ RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* binding */ RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* binding */ RawShape),\n/* harmony export */   RawShapeCastHit: () => (/* binding */ RawShapeCastHit),\n/* harmony export */   RawShapeContact: () => (/* binding */ RawShapeContact),\n/* harmony export */   RawShapeType: () => (/* binding */ RawShapeType),\n/* harmony export */   RawVector: () => (/* binding */ RawVector),\n/* harmony export */   __wbg_bind_c8359b1cba058168: () => (/* binding */ __wbg_bind_c8359b1cba058168),\n/* harmony export */   __wbg_buffer_609cc3eee51ed158: () => (/* binding */ __wbg_buffer_609cc3eee51ed158),\n/* harmony export */   __wbg_call_7cccdd69e0791ae2: () => (/* binding */ __wbg_call_7cccdd69e0791ae2),\n/* harmony export */   __wbg_call_833bed5770ea2041: () => (/* binding */ __wbg_call_833bed5770ea2041),\n/* harmony export */   __wbg_call_b8adc8b1d0a0d8eb: () => (/* binding */ __wbg_call_b8adc8b1d0a0d8eb),\n/* harmony export */   __wbg_length_3b4f022188ae8db6: () => (/* binding */ __wbg_length_3b4f022188ae8db6),\n/* harmony export */   __wbg_length_a446193dc22c12f8: () => (/* binding */ __wbg_length_a446193dc22c12f8),\n/* harmony export */   __wbg_new_a12002a7f91c75be: () => (/* binding */ __wbg_new_a12002a7f91c75be),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: () => (/* binding */ __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: () => (/* binding */ __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354),\n/* harmony export */   __wbg_newwithlength_5a5efe313cfd59f1: () => (/* binding */ __wbg_newwithlength_5a5efe313cfd59f1),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* binding */ __wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* binding */ __wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_10bad9bee0e9c58b: () => (/* binding */ __wbg_set_10bad9bee0e9c58b),\n/* harmony export */   __wbg_set_65595bdd868b3009: () => (/* binding */ __wbg_set_65595bdd868b3009),\n/* harmony export */   __wbg_set_wasm: () => (/* binding */ __wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* binding */ __wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* binding */ __wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* binding */ __wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* binding */ __wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* binding */ __wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* binding */ __wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* binding */ __wbindgen_throw),\n/* harmony export */   version: () => (/* binding */ version)\n/* harmony export */ });\n/* module decorator */ module = __webpack_require__.hmd(module);\nlet wasm;\nfunction __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_export_0(addHeapObject(e));\n    }\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedDataViewMemory0 = null;\n\nfunction getDataViewMemory0() {\n    if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || (cachedDataViewMemory0.buffer.detached === undefined && cachedDataViewMemory0.buffer !== wasm.memory.buffer)) {\n        cachedDataViewMemory0 = new DataView(wasm.memory.buffer);\n    }\n    return cachedDataViewMemory0;\n}\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8ArrayMemory0 = null;\n\nfunction getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n        cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n}\n/**\n * @returns {string}\n */\nfunction version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n        var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_export_1(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nlet cachedInt32ArrayMemory0 = null;\n\nfunction getInt32ArrayMemory0() {\n    if (cachedInt32ArrayMemory0 === null || cachedInt32ArrayMemory0.byteLength === 0) {\n        cachedInt32ArrayMemory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32ArrayMemory0;\n}\n\nfunction getArrayI32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getInt32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedFloat32ArrayMemory0 = null;\n\nfunction getFloat32ArrayMemory0() {\n    if (cachedFloat32ArrayMemory0 === null || cachedFloat32ArrayMemory0.byteLength === 0) {\n        cachedFloat32ArrayMemory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32ArrayMemory0;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32ArrayMemory0 = null;\n\nfunction getUint32ArrayMemory0() {\n    if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {\n        cachedUint32ArrayMemory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32ArrayMemory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32ArrayMemory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n/**\n * @enum {0 | 1 | 2}\n */\nconst RawFeatureType = Object.freeze({\n    Vertex: 0, \"0\": \"Vertex\",\n    Face: 1, \"1\": \"Face\",\n    Unknown: 2, \"2\": \"Unknown\",\n});\n/**\n * @enum {0 | 1 | 2}\n */\nconst RawJointAxis = Object.freeze({\n    LinX: 0, \"0\": \"LinX\",\n    LinY: 1, \"1\": \"LinY\",\n    AngX: 2, \"2\": \"AngX\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5}\n */\nconst RawJointType = Object.freeze({\n    Revolute: 0, \"0\": \"Revolute\",\n    Fixed: 1, \"1\": \"Fixed\",\n    Prismatic: 2, \"2\": \"Prismatic\",\n    Rope: 3, \"3\": \"Rope\",\n    Spring: 4, \"4\": \"Spring\",\n    Generic: 5, \"5\": \"Generic\",\n});\n/**\n * @enum {0 | 1}\n */\nconst RawMotorModel = Object.freeze({\n    AccelerationBased: 0, \"0\": \"AccelerationBased\",\n    ForceBased: 1, \"1\": \"ForceBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3}\n */\nconst RawRigidBodyType = Object.freeze({\n    Dynamic: 0, \"0\": \"Dynamic\",\n    Fixed: 1, \"1\": \"Fixed\",\n    KinematicPositionBased: 2, \"2\": \"KinematicPositionBased\",\n    KinematicVelocityBased: 3, \"3\": \"KinematicVelocityBased\",\n});\n/**\n * @enum {0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14}\n */\nconst RawShapeType = Object.freeze({\n    Ball: 0, \"0\": \"Ball\",\n    Cuboid: 1, \"1\": \"Cuboid\",\n    Capsule: 2, \"2\": \"Capsule\",\n    Segment: 3, \"3\": \"Segment\",\n    Polyline: 4, \"4\": \"Polyline\",\n    Triangle: 5, \"5\": \"Triangle\",\n    TriMesh: 6, \"6\": \"TriMesh\",\n    HeightField: 7, \"7\": \"HeightField\",\n    Compound: 8, \"8\": \"Compound\",\n    ConvexPolygon: 9, \"9\": \"ConvexPolygon\",\n    RoundCuboid: 10, \"10\": \"RoundCuboid\",\n    RoundTriangle: 11, \"11\": \"RoundTriangle\",\n    RoundConvexPolygon: 12, \"12\": \"RoundConvexPolygon\",\n    HalfSpace: 13, \"13\": \"HalfSpace\",\n    Voxels: 14, \"14\": \"Voxels\",\n});\n\nconst RawBroadPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawbroadphase_free(ptr >>> 0, 1));\n\nclass RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawBroadPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawBroadPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawBroadPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst RawCCDSolverFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawccdsolver_free(ptr >>> 0, 1));\n\nclass RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCCDSolverFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCCDSolverFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n}\n\nconst RawCharacterCollisionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcharactercollision_free(ptr >>> 0, 1));\n\nclass RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawCharacterCollisionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawCharacterCollisionFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawColliderSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcolliderset_free(ptr >>> 0, 1));\n\nclass RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this collider.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this collider.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this collider.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the collider along the `x` axis.\n     * - `y`: the world-space position of the collider along the `y` axis.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    coSetTranslation(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    coSetTranslationWrtParent(handle, x, y) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * Sets the rotation angle of this collider.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} angle\n     */\n    coSetRotation(handle, angle) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} angle\n     */\n    coSetRotationWrtParent(handle, angle) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * Is this collider a sensor?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The type of the shape of this collider.\n     * @param {number} handle\n     * @returns {RawShapeType}\n     */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The half-extents of this collider if it is has a cuboid shape.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * Set the half-extents of this collider if it has a cuboid shape.\n     * @param {number} handle\n     * @param {RawVector} newHalfExtents\n     */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n     * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRadius(handle) {\n        const ret = wasm.rawcolliderset_coRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newRadius\n     */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n     * The half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coHalfHeight(handle) {\n        const ret = wasm.rawcolliderset_coHalfHeight(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n     * @param {number} handle\n     * @param {number} newHalfheight\n     */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n     * The radius of the round edges of this collider.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coRoundRadius(handle) {\n        const ret = wasm.rawcolliderset_coRoundRadius(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * Set the radius of the round edges of this collider.\n     * @param {number} handle\n     * @param {number} newBorderRadius\n     */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n     * @param {number} handle\n     * @returns {Int32Array | undefined}\n     */\n    coVoxelData(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVoxelData(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayI32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coVoxelSize(handle) {\n        const ret = wasm.rawcolliderset_coVoxelSize(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} ix\n     * @param {number} iy\n     * @param {boolean} filled\n     */\n    coSetVoxel(handle, ix, iy, filled) {\n        wasm.rawcolliderset_coSetVoxel(this.__wbg_ptr, handle, ix, iy, filled);\n    }\n    /**\n     * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n     * @param {number} handle\n     * @returns {Uint32Array | undefined}\n     */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coTriMeshFlags(handle) {\n        const ret = wasm.rawcolliderset_coTriMeshFlags(this.__wbg_ptr, handle);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * The height of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {Float32Array | undefined}\n     */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_export_1(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * The scaling factor applied of this heightfield if it is one.\n     * @param {number} handle\n     * @returns {RawVector | undefined}\n     */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * The unique integer identifier of the collider this collider is attached to.\n     * @param {number} handle\n     * @returns {number | undefined}\n     */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} contact_skin\n     */\n    coSetContactSkin(handle, contact_skin) {\n        wasm.rawcolliderset_coSetContactSkin(this.__wbg_ptr, handle, contact_skin);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactSkin(handle) {\n        const ret = wasm.rawcolliderset_coContactSkin(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The friction coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The restitution coefficient of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The density of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The mass of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The volume of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The collision groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The solver groups of this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The physics hooks enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The collision types enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The events enabled for this collider.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     * @param {number} handle\n     * @returns {number}\n     */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} colliderVel\n     * @param {RawShape} shape2\n     * @param {RawVector} shape2Pos\n     * @param {RawRotation} shape2Rot\n     * @param {RawVector} shape2Vel\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} collider1Vel\n     * @param {number} collider2handle\n     * @param {RawVector} collider2Vel\n     * @param {number} target_distance\n     * @param {number} max_toi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, target_distance, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, target_distance, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} collider2handle\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} is_sensor\n     */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} restitution\n     */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} friction\n     */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} rule\n     */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} groups\n     */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} hooks\n     */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} events\n     */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} types\n     */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawShape} shape\n     */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} threshold\n     */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} density\n     */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia);\n    }\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawColliderSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawShape} shape\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} massPropsMode\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     * @param {number} density\n     * @param {number} friction\n     * @param {number} restitution\n     * @param {number} frictionCombineRule\n     * @param {number} restitutionCombineRule\n     * @param {boolean} isSensor\n     * @param {number} collisionGroups\n     * @param {number} solverGroups\n     * @param {number} activeCollisionTypes\n     * @param {number} activeHooks\n     * @param {number} activeEvents\n     * @param {number} contactForceEventThreshold\n     * @param {number} contactSkin\n     * @param {boolean} hasParent\n     * @param {number} parent\n     * @param {RawRigidBodySet} bodies\n     * @returns {number | undefined}\n     */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, contactSkin, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n     * Removes a collider from this set and wake-up the rigid-body it is attached to.\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawRigidBodySet} bodies\n     * @param {boolean} wakeUp\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Checks if a collider with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n     * @param {Function} f\n     */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawColliderShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcollidershapecasthit_free(ptr >>> 0, 1));\n\nclass RawColliderShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawColliderShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawColliderShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcollidershapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactForceEventFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactforceevent_free(ptr >>> 0, 1));\n\nclass RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactForceEventFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactForceEventFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr, 0);\n    }\n    /**\n     * The first collider involved in the contact.\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The second collider involved in the contact.\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     * @returns {RawVector}\n     */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     * @returns {number}\n     */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     * @returns {RawVector}\n     */\n    max_force_direction() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     * @returns {number}\n     */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawContactManifoldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactmanifold_free(ptr >>> 0, 1));\n\nclass RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactManifoldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactManifoldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    contact_tangent_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector | undefined}\n     */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {number}\n     */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawVector}\n     */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawContactPairFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawcontactpair_free(ptr >>> 0, 1));\n\nclass RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n        RawContactPairFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawContactPairFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @returns {RawContactManifold | undefined}\n     */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n\nconst RawDebugRenderPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdebugrenderpipeline_free(ptr >>> 0, 1));\n\nclass RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDebugRenderPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawDebugRenderPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @returns {Float32Array}\n     */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @param {RawNarrowPhase} narrow_phase\n     */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n\nconst RawDeserializedWorldFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawdeserializedworld_free(ptr >>> 0, 1));\n\nclass RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n        RawDeserializedWorldFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawDeserializedWorldFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector | undefined}\n     */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawIntegrationParameters | undefined}\n     */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n     * @returns {RawIslandManager | undefined}\n     */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n     * @returns {RawBroadPhase | undefined}\n     */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawNarrowPhase | undefined}\n     */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n     * @returns {RawRigidBodySet | undefined}\n     */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n     * @returns {RawColliderSet | undefined}\n     */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawImpulseJointSet | undefined}\n     */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n     * @returns {RawMultibodyJointSet | undefined}\n     */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n\nconst RawEventQueueFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_raweventqueue_free(ptr >>> 0, 1));\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n */\nclass RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawEventQueueFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr, 0);\n    }\n    /**\n     * Creates a new event collector.\n     *\n     * # Parameters\n     * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     * @param {boolean} autoDrain\n     */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        RawEventQueueFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * # Parameters\n     * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n     * closure should take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     * @param {Function} f\n     */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {Function} f\n     */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Removes all events contained by this collector.\n     */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n\nconst RawGenericJointFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawgenericjoint_free(ptr >>> 0, 1));\n\nclass RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n        RawGenericJointFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawGenericJointFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr, 0);\n    }\n    /**\n     * @param {number} rest_length\n     * @param {number} stiffness\n     * @param {number} damping\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * @param {number} length\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint}\n     */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * Returns `None` if any of the provided axes cannot be normalized.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @param {RawVector} axis\n     * @param {boolean} limitsEnabled\n     * @param {number} limitsMin\n     * @param {number} limitsMax\n     * @returns {RawGenericJoint | undefined}\n     */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies.\n     * @param {RawVector} anchor1\n     * @param {RawRotation} axes1\n     * @param {RawVector} anchor2\n     * @param {RawRotation} axes2\n     * @returns {RawGenericJoint}\n     */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation.\n     * @param {RawVector} anchor1\n     * @param {RawVector} anchor2\n     * @returns {RawGenericJoint | undefined}\n     */\n    static revolute(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n\nconst RawImpulseJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawimpulsejointset_free(ptr >>> 0, 1));\n\nclass RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawImpulseJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawImpulseJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the first rigid-body this joint it attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The unique integer identifier of the second rigid-body this joint is attached to.\n     * @param {number} handle\n     * @returns {number}\n     */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Sets the position of the first local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Sets the position of the second local anchor\n     * @param {number} handle\n     * @param {RawVector} newPos\n     */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * Enables and sets the joint limits\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} min\n     * @param {number} max\n     */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {RawMotorModel} model\n     */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetVel\n     * @param {number} factor\n     */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @param {number} targetPos\n     * @param {number} targetVel\n     * @param {number} stiffness\n     * @param {number} damping\n     */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawImpulseJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wake_up\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawIntegrationParametersFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawintegrationparameters_free(ptr >>> 0, 1));\n\nclass RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIntegrationParametersFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIntegrationParametersFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIntegrationParametersFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {number}\n     */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get contact_erp() {\n        const ret = wasm.rawintegrationparameters_contact_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedAllowedLinearError() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get normalizedPredictionDistance() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get minIslandSize() {\n        const ret = wasm.rawintegrationparameters_minIslandSize(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawintegrationparameters_maxCcdSubsteps(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @returns {number}\n     */\n    get lengthUnit() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set contact_natural_frequency(value) {\n        wasm.rawintegrationparameters_set_contact_natural_frequency(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedAllowedLinearError(value) {\n        wasm.rawintegrationparameters_set_normalizedAllowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set normalizedPredictionDistance(value) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set minIslandSize(value) {\n        wasm.rawintegrationparameters_set_minIslandSize(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set maxCcdSubsteps(value) {\n        wasm.rawintegrationparameters_set_maxCcdSubsteps(this.__wbg_ptr, value);\n    }\n    /**\n     * @param {number} value\n     */\n    set lengthUnit(value) {\n        wasm.rawintegrationparameters_set_lengthUnit(this.__wbg_ptr, value);\n    }\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n    switchToSmallStepsPgsSolverWithoutWarmstart() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolverWithoutWarmstart(this.__wbg_ptr);\n    }\n}\n\nconst RawIslandManagerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawislandmanager_free(ptr >>> 0, 1));\n\nclass RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n        RawIslandManagerFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawIslandManagerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawIslandManagerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each active rigid-body\n     * managed by this island manager.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n     *   set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawKinematicCharacterControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawkinematiccharactercontroller_free(ptr >>> 0, 1));\n\nclass RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawKinematicCharacterControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} offset\n     */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        RawKinematicCharacterControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    up() {\n        const ret = wasm.rawcollidershapecasthit_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} vector\n     */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    normalNudgeFactor() {\n        const ret = wasm.rawkinematiccharactercontroller_normalNudgeFactor(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setNormalNudgeFactor(value) {\n        wasm.rawkinematiccharactercontroller_setNormalNudgeFactor(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {number}\n     */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} value\n     */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n     * @returns {boolean}\n     */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {boolean} enabled\n     */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMaxHeight() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMaxHeight(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    autostepMinWidth() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepMinWidth(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @returns {boolean | undefined}\n     */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n     * @returns {boolean}\n     */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} maxHeight\n     * @param {number} minWidth\n     * @param {boolean} includeDynamicBodies\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n     * @returns {number}\n     */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawintegrationparameters_normalizedPredictionDistance(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawintegrationparameters_set_normalizedPredictionDistance(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number}\n     */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @param {number} angle\n     */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    snapToGroundDistance() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundDistance(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n    /**\n     * @param {number} distance\n     */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n     * @returns {boolean}\n     */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawQueryPipeline} queries\n     * @param {number} collider_handle\n     * @param {RawVector} desired_translation_delta\n     * @param {boolean} apply_impulses_to_dynamic_bodies\n     * @param {number | null | undefined} character_mass\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {Function} filter_predicate\n     */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, isLikeNone(character_mass) ? 0x100000001 : Math.fround(character_mass), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @returns {RawVector}\n     */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {number}\n     */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} i\n     * @param {RawCharacterCollision} collision\n     * @returns {boolean}\n     */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawMultibodyJointSetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawmultibodyjointset_free(ptr >>> 0, 1));\n\nclass RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawMultibodyJointSetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawMultibodyJointSetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr, 0);\n    }\n    /**\n     * The type of this joint.\n     * @param {number} handle\n     * @returns {RawJointType}\n     */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The angular part of the joint’s local frame relative to the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the points application point on the\n     * local frame of the first rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the points application point on the\n     * local frame of the second rigid-body it is attached to.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Are contacts between the rigid-bodies attached by this joint enabled?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * Are the limits for this joint enabled?\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {boolean}\n     */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n     * Return the lower limit along the given joint axis.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n     * If this is a prismatic joint, returns its upper limit.\n     * @param {number} handle\n     * @param {RawJointAxis} axis\n     * @returns {number}\n     */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawMultibodyJointSetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawGenericJoint} params\n     * @param {number} parent1\n     * @param {number} parent2\n     * @param {boolean} wakeUp\n     * @returns {number}\n     */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n     * @param {number} body\n     * @param {Function} f\n     */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawNarrowPhaseFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawnarrowphase_free(ptr >>> 0, 1));\n\nclass RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n        RawNarrowPhaseFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawNarrowPhaseFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawNarrowPhaseFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {RawContactPair | undefined}\n     */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n     * @param {number} handle1\n     * @param {Function} f\n     */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n     * @param {number} handle1\n     * @param {number} handle2\n     * @returns {boolean}\n     */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n\nconst RawPhysicsPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawphysicspipeline_free(ptr >>> 0, 1));\n\nclass RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPhysicsPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawPhysicsPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     * @param {RawCCDSolver} ccd_solver\n     * @param {RawEventQueue} eventQueue\n     * @param {object} hookObject\n     * @param {Function} hookFilterContactPair\n     * @param {Function} hookFilterIntersectionPair\n     */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n\nconst RawPidControllerFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpidcontroller_free(ptr >>> 0, 1));\n\nclass RawPidController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPidControllerFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpidcontroller_free(ptr, 0);\n    }\n    /**\n     * @param {number} kp\n     * @param {number} ki\n     * @param {number} kd\n     * @param {number} axes_mask\n     */\n    constructor(kp, ki, kd, axes_mask) {\n        const ret = wasm.rawpidcontroller_new(kp, ki, kd, axes_mask);\n        this.__wbg_ptr = ret >>> 0;\n        RawPidControllerFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {number} kp\n     * @param {number} axes\n     */\n    set_kp(kp, axes) {\n        wasm.rawpidcontroller_set_kp(this.__wbg_ptr, kp, axes);\n    }\n    /**\n     * @param {number} ki\n     * @param {number} axes\n     */\n    set_ki(ki, axes) {\n        wasm.rawpidcontroller_set_ki(this.__wbg_ptr, ki, axes);\n    }\n    /**\n     * @param {number} kd\n     * @param {number} axes\n     */\n    set_kd(kd, axes) {\n        wasm.rawpidcontroller_set_kd(this.__wbg_ptr, kd, axes);\n    }\n    /**\n     * @param {number} axes_mask\n     */\n    set_axes_mask(axes_mask) {\n        wasm.rawpidcontroller_set_axes_mask(this.__wbg_ptr, axes_mask);\n    }\n    reset_integrals() {\n        wasm.rawpidcontroller_reset_integrals(this.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     */\n    apply_linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        wasm.rawpidcontroller_apply_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {number} target_rotation\n     * @param {number} target_angvel\n     */\n    apply_angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawpidcontroller_apply_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation, target_angvel);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {RawVector} target_translation\n     * @param {RawVector} target_linvel\n     * @returns {RawVector}\n     */\n    linear_correction(dt, bodies, rb_handle, target_translation, target_linvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(target_translation, RawVector);\n        _assertClass(target_linvel, RawVector);\n        const ret = wasm.rawpidcontroller_linear_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_translation.__wbg_ptr, target_linvel.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} dt\n     * @param {RawRigidBodySet} bodies\n     * @param {number} rb_handle\n     * @param {number} target_rotation\n     * @param {number} target_angvel\n     * @returns {number}\n     */\n    angular_correction(dt, bodies, rb_handle, target_rotation, target_angvel) {\n        _assertClass(bodies, RawRigidBodySet);\n        const ret = wasm.rawpidcontroller_angular_correction(this.__wbg_ptr, dt, bodies.__wbg_ptr, rb_handle, target_rotation, target_angvel);\n        return ret;\n    }\n}\n\nconst RawPointColliderProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointcolliderprojection_free(ptr >>> 0, 1));\n\nclass RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointColliderProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointColliderProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawPointProjectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawpointprojection_free(ptr >>> 0, 1));\n\nclass RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawPointProjectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawPointProjectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {boolean}\n     */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n\nconst RawQueryPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawquerypipeline_free(ptr >>> 0, 1));\n\nclass RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawQueryPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawQueryPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawColliderSet} colliders\n     */\n    update(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderHit | undefined}\n     */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawRayColliderIntersection | undefined}\n     */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {number | undefined}\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);\n            var r2 = getDataViewMemory0().getFloat64(retptr + 8 * 1, true);\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawPointColliderProjection | undefined}\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} point\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} shapeVel\n     * @param {RawShape} shape\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     * @returns {RawColliderShapeCastHit | undefined}\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, target_distance, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, target_distance, maxToi, stop_at_penetration, filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawColliderShapeCastHit.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawShape} shape\n     * @param {Function} callback\n     * @param {number} filter_flags\n     * @param {number | null | undefined} filter_groups\n     * @param {number | null | undefined} filter_exclude_collider\n     * @param {number | null | undefined} filter_exclude_rigid_body\n     * @param {Function} filter_predicate\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, isLikeNone(filter_groups) ? 0x100000001 : (filter_groups) >>> 0, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawVector} aabbCenter\n     * @param {RawVector} aabbHalfExtents\n     * @param {Function} callback\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n\nconst RawRayColliderHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderhit_free(ptr >>> 0, 1));\n\nclass RawRayColliderHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderhit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawcollidershapecasthit_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number}\n     */\n    timeOfImpact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawRayColliderIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawraycolliderintersection_free(ptr >>> 0, 1));\n\nclass RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayColliderIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayColliderIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRayIntersectionFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrayintersection_free(ptr >>> 0, 1));\n\nclass RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRayIntersectionFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRayIntersectionFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr, 0);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawcollidershapecasthit_time_of_impact(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawFeatureType}\n     */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {number | undefined}\n     */\n    featureId() {\n        const ret = wasm.rawpointcolliderprojection_featureId(this.__wbg_ptr);\n        return ret === 0x100000001 ? undefined : ret;\n    }\n}\n\nconst RawRigidBodySetFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrigidbodyset_free(ptr >>> 0, 1));\n\nclass RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRigidBodySetFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRigidBodySetFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr, 0);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Put the given rigid-body to sleep.\n     * @param {number} handle\n     */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The world-space predicted translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space predicted orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     * @param {number} handle\n     * @returns {RawRotation}\n     */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     * @param {boolean} wakeUp\n     */\n    rbSetTranslation(handle, x, y, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, wakeUp);\n    }\n    /**\n     * Sets the rotation angle of this rigid-body.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     * @param {number} handle\n     * @param {number} angle\n     * @param {boolean} wakeUp\n     */\n    rbSetRotation(handle, angle, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, angle, wakeUp);\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} linvel\n     * @param {boolean} wakeUp\n     */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Sets the angular velocity of this rigid-body.\n     * @param {number} handle\n     * @param {number} angvel\n     * @param {boolean} wakeUp\n     */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel, wakeUp);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `x`: the world-space position of the rigid-body along the `x` axis.\n     * - `y`: the world-space position of the rigid-body along the `y` axis.\n     * @param {number} handle\n     * @param {number} x\n     * @param {number} y\n     */\n    rbSetNextKinematicTranslation(handle, x, y) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y);\n    }\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * # Parameters\n     * - `angle`: the rotation angle, in radians.\n     * @param {number} handle\n     * @param {number} angle\n     */\n    rbSetNextKinematicRotation(handle, angle) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, angle);\n    }\n    /**\n     * @param {number} handle\n     * @param {RawColliderSet} colliders\n     */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} mass\n     * @param {RawVector} centerOfMass\n     * @param {number} principalAngularInertia\n     * @param {boolean} wake_up\n     */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia, wake_up);\n    }\n    /**\n     * The linear velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The angular velocity of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The velocity of the given world-space point on this rigid-body.\n     * @param {number} handle\n     * @param {RawVector} point\n     * @returns {RawVector}\n     */\n    rbVelocityAtPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawrigidbodyset_rbVelocityAtPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} allow_x\n     * @param {boolean} allow_y\n     * @param {boolean} wake_up\n     */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} locked\n     * @param {boolean} wake_up\n     */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} group\n     */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} prediction\n     */\n    rbSetSoftCcdPrediction(handle, prediction) {\n        wasm.rawrigidbodyset_rbSetSoftCcdPrediction(this.__wbg_ptr, handle, prediction);\n    }\n    /**\n     * The mass of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This method forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     * @param {number} handle\n     */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n     * Is Continuous Collision Detection enabled for this rigid-body?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbSoftCcdPrediction(handle) {\n        const ret = wasm.rawrigidbodyset_rbSoftCcdPrediction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * # Parameters\n     * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     * @param {number} handle\n     * @param {number} at\n     * @returns {number}\n     */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n     * The status of this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @returns {RawRigidBodyType}\n     */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n     * @param {number} handle\n     * @param {RawRigidBodyType} status\n     * @param {boolean} wake_up\n     */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n     * Is this rigid-body fixed?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body kinematic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Is this rigid-body dynamic?\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n     * @param {number} handle\n     * @param {boolean} enabled\n     */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} factor\n     * @param {boolean} wakeUp\n     */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added forces added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Resets to zero all user-added torques added to this rigid-body.\n     * @param {number} handle\n     * @param {boolean} wakeUp\n     */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {boolean} wakeUp\n     */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque`: the torque to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {number} torque\n     * @param {boolean} wakeUp\n     */\n    rbAddTorque(handle, torque, wakeUp) {\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque, wakeUp);\n    }\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * # Parameters\n     * - `torque impulse`: the torque impulse to apply on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {number} torque_impulse\n     * @param {boolean} wakeUp\n     */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse, wakeUp);\n    }\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `force`: the world-space force to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} force\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * # Parameters\n     * - `impulse`: the world-space impulse to apply on the rigid-body.\n     * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n     * - `wakeUp`: should the rigid-body be automatically woken-up?\n     * @param {number} handle\n     * @param {RawVector} impulse\n     * @param {RawVector} point\n     * @param {boolean} wakeUp\n     */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * @param {number} handle\n     * @param {number} iters\n     */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n     * An arbitrary user-defined 32-bit integer\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n     * Sets the user-defined 32-bit integer of this rigid-body.\n     *\n     * # Parameters\n     * - `data`: an arbitrary user-defined 32-bit integer.\n     * @param {number} handle\n     * @param {number} data\n     */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n     * Retrieves the constant force(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {RawVector}\n     */\n    rbUserForce(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserForce(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Retrieves the constant torque(s) the user added to this rigid-body.\n     * Returns zero if the rigid-body is not dynamic.\n     * @param {number} handle\n     * @returns {number}\n     */\n    rbUserTorque(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserTorque(this.__wbg_ptr, handle);\n        return ret;\n    }\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawRigidBodySetFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {boolean} enabled\n     * @param {RawVector} translation\n     * @param {RawRotation} rotation\n     * @param {number} gravityScale\n     * @param {number} mass\n     * @param {boolean} massOnly\n     * @param {RawVector} centerOfMass\n     * @param {RawVector} linvel\n     * @param {number} angvel\n     * @param {number} principalAngularInertia\n     * @param {boolean} translationEnabledX\n     * @param {boolean} translationEnabledY\n     * @param {boolean} rotationsEnabled\n     * @param {number} linearDamping\n     * @param {number} angularDamping\n     * @param {RawRigidBodyType} rb_type\n     * @param {boolean} canSleep\n     * @param {boolean} sleeping\n     * @param {number} softCcdPrediciton\n     * @param {boolean} ccdEnabled\n     * @param {number} dominanceGroup\n     * @param {number} additional_solver_iterations\n     * @returns {number}\n     */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel, principalAngularInertia, translationEnabledX, translationEnabledY, rotationsEnabled, linearDamping, angularDamping, rb_type, canSleep, sleeping, softCcdPrediciton, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n     * @param {number} handle\n     * @param {RawIslandManager} islands\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} joints\n     * @param {RawMultibodyJointSet} articulations\n     */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     * @returns {number}\n     */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n     * Checks if a rigid-body with the given integer handle exists.\n     * @param {number} handle\n     * @returns {boolean}\n     */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n     * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n     *\n     * # Parameters\n     * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n     * @param {Function} f\n     */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n     * @param {RawColliderSet} colliders\n     */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n\nconst RawRotationFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawrotation_free(ptr >>> 0, 1));\n/**\n * A rotation quaternion.\n */\nclass RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n        RawRotationFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawRotationFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr, 0);\n    }\n    /**\n     * The identity rotation.\n     * @returns {RawRotation}\n     */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The rotation with thegiven angle.\n     * @param {number} angle\n     * @returns {RawRotation}\n     */\n    static fromAngle(angle) {\n        const ret = wasm.rawrotation_fromAngle(angle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n     * The imaginary part of this complex number.\n     * @returns {number}\n     */\n    get im() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The real part of this complex number.\n     * @returns {number}\n     */\n    get re() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * The rotation angle in radians.\n     * @returns {number}\n     */\n    get angle() {\n        const ret = wasm.rawrotation_angle(this.__wbg_ptr);\n        return ret;\n    }\n}\n\nconst RawSerializationPipelineFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawserializationpipeline_free(ptr >>> 0, 1));\n\nclass RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawSerializationPipelineFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr, 0);\n    }\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        RawSerializationPipelineFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * @param {RawVector} gravity\n     * @param {RawIntegrationParameters} integrationParameters\n     * @param {RawIslandManager} islands\n     * @param {RawBroadPhase} broadPhase\n     * @param {RawNarrowPhase} narrowPhase\n     * @param {RawRigidBodySet} bodies\n     * @param {RawColliderSet} colliders\n     * @param {RawImpulseJointSet} impulse_joints\n     * @param {RawMultibodyJointSet} multibody_joints\n     * @returns {Uint8Array | undefined}\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n     * @param {Uint8Array} data\n     * @returns {RawDeserializedWorld | undefined}\n     */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n\nconst RawShapeFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshape_free(ptr >>> 0, 1));\n\nclass RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr, 0);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @returns {RawShape}\n     */\n    static cuboid(hx, hy) {\n        const ret = wasm.rawshape_cuboid(hx, hy);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} hx\n     * @param {number} hy\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundCuboid(hx, hy, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} normal\n     * @returns {RawShape}\n     */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {number} halfHeight\n     * @param {number} radius\n     * @returns {RawShape}\n     */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} voxel_size\n     * @param {Int32Array} grid_coords\n     * @returns {RawShape}\n     */\n    static voxels(voxel_size, grid_coords) {\n        _assertClass(voxel_size, RawVector);\n        const ptr0 = passArray32ToWasm0(grid_coords, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_voxels(voxel_size.__wbg_ptr, ptr0, len0);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} voxel_size\n     * @param {Float32Array} points\n     * @returns {RawShape}\n     */\n    static voxelsFromPoints(voxel_size, points) {\n        _assertClass(voxel_size, RawVector);\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_voxelsFromPoints(voxel_size.__wbg_ptr, ptr0, len0);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @returns {RawShape}\n     */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {Uint32Array} indices\n     * @param {number} flags\n     * @returns {RawShape | undefined}\n     */\n    static trimesh(vertices, indices, flags) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_export_2);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1, flags);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} heights\n     * @param {RawVector} scale\n     * @returns {RawShape}\n     */\n    static heightfield(heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @returns {RawShape}\n     */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @returns {RawShape}\n     */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} p1\n     * @param {RawVector} p2\n     * @param {RawVector} p3\n     * @param {number} borderRadius\n     * @returns {RawShape}\n     */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @returns {RawShape | undefined}\n     */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} points\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @returns {RawShape | undefined}\n     */\n    static convexPolyline(vertices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexPolyline(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {Float32Array} vertices\n     * @param {number} borderRadius\n     * @returns {RawShape | undefined}\n     */\n    static roundConvexPolyline(vertices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_export_2);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexPolyline(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawVector} shapeVel1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {RawVector} shapeVel2\n     * @param {number} target_distance\n     * @param {number} maxToi\n     * @param {boolean} stop_at_penetration\n     * @returns {RawShapeCastHit | undefined}\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, target_distance, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, target_distance, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeCastHit.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @returns {boolean}\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos1\n     * @param {RawRotation} shapeRot1\n     * @param {RawShape} shape2\n     * @param {RawVector} shapePos2\n     * @param {RawRotation} shapeRot2\n     * @param {number} prediction\n     * @returns {RawShapeContact | undefined}\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @returns {boolean}\n     */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} point\n     * @param {boolean} solid\n     * @returns {RawPointProjection}\n     */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @returns {boolean}\n     */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {number}\n     */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n     * @param {RawVector} shapePos\n     * @param {RawRotation} shapeRot\n     * @param {RawVector} rayOrig\n     * @param {RawVector} rayDir\n     * @param {number} maxToi\n     * @param {boolean} solid\n     * @returns {RawRayIntersection | undefined}\n     */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n\nconst RawShapeCastHitFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecasthit_free(ptr >>> 0, 1));\n\nclass RawShapeCastHit {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeCastHit.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeCastHitFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeCastHitFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecasthit_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    time_of_impact() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness1() {\n        const ret = wasm.rawshapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    witness2() {\n        const ret = wasm.rawcollidershapecasthit_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcollidershapecasthit_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcollidershapecasthit_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawShapeContactFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawshapecontact_free(ptr >>> 0, 1));\n\nclass RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n        RawShapeContactFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawShapeContactFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr, 0);\n    }\n    /**\n     * @returns {number}\n     */\n    distance() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    point2() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal1() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * @returns {RawVector}\n     */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nconst RawVectorFinalization = (typeof FinalizationRegistry === 'undefined')\n    ? { register: () => {}, unregister: () => {} }\n    : new FinalizationRegistry(ptr => wasm.__wbg_rawvector_free(ptr >>> 0, 1));\n/**\n * A vector.\n */\nclass RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n        RawVectorFinalization.register(obj, obj.__wbg_ptr, obj);\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n        RawVectorFinalization.unregister(this);\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr, 0);\n    }\n    /**\n     * Creates a new vector filled with zeros.\n     * @returns {RawVector}\n     */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Creates a new 2D vector from its two components.\n     *\n     * # Parameters\n     * - `x`: the `x` component of this 2D vector.\n     * - `y`: the `y` component of this 2D vector.\n     * @param {number} x\n     * @param {number} y\n     */\n    constructor(x, y) {\n        const ret = wasm.rawvector_new(x, y);\n        this.__wbg_ptr = ret >>> 0;\n        RawVectorFinalization.register(this, this.__wbg_ptr, this);\n        return this;\n    }\n    /**\n     * The `x` component of this vector.\n     * @returns {number}\n     */\n    get x() {\n        const ret = wasm.rawrotation_re(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `x` component of this vector.\n     * @param {number} x\n     */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n     * The `y` component of this vector.\n     * @returns {number}\n     */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n     * Sets the `y` component of this vector.\n     * @param {number} y\n     */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n     * Create a new 2D vector from this vector with its components rearranged as `{x, y}`.\n     * @returns {RawVector}\n     */\n    xy() {\n        const ret = wasm.rawvector_xy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n     * Create a new 2D vector from this vector with its components rearranged as `{y, x}`.\n     * @returns {RawVector}\n     */\n    yx() {\n        const ret = wasm.rawvector_yx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nfunction __wbg_bind_c8359b1cba058168(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_buffer_609cc3eee51ed158(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nfunction __wbg_call_7cccdd69e0791ae2() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_833bed5770ea2041() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_call_b8adc8b1d0a0d8eb() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nfunction __wbg_length_3b4f022188ae8db6(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_length_a446193dc22c12f8(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nfunction __wbg_new_a12002a7f91c75be(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_newwithlength_5a5efe313cfd59f1(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nfunction __wbg_set_10bad9bee0e9c58b(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbg_set_65595bdd868b3009(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nfunction __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nfunction __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nfunction __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getDataViewMemory0().setFloat64(arg0 + 8 * 1, isLikeNone(ret) ? 0 : ret, true);\n    getDataViewMemory0().setInt32(arg0 + 4 * 0, !isLikeNone(ret), true);\n};\n\nfunction __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nfunction __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nfunction __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\n\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm":
/*!***************************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* harmony import */ var WEBPACK_IMPORTED_MODULE_0 = __webpack_require__(/*! ./rapier_wasm2d_bg.js */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.js\");\nmodule.exports = __webpack_require__.v(exports, module.id, \"152dcb7ec315e2b0d1d2\", {\n\t\"./rapier_wasm2d_bg.js\": {\n\t\t\"__wbindgen_number_new\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_new,\n\t\t\"__wbindgen_boolean_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_boolean_get,\n\t\t\"__wbindgen_object_drop_ref\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_object_drop_ref,\n\t\t\"__wbindgen_number_get\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_number_get,\n\t\t\"__wbindgen_is_function\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_is_function,\n\t\t\"__wbg_rawraycolliderintersection_new\": WEBPACK_IMPORTED_MODULE_0.__wbg_rawraycolliderintersection_new,\n\t\t\"__wbg_rawcontactforceevent_new\": WEBPACK_IMPORTED_MODULE_0.__wbg_rawcontactforceevent_new,\n\t\t\"__wbg_call_7cccdd69e0791ae2\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_7cccdd69e0791ae2,\n\t\t\"__wbg_call_833bed5770ea2041\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_833bed5770ea2041,\n\t\t\"__wbg_call_b8adc8b1d0a0d8eb\": WEBPACK_IMPORTED_MODULE_0.__wbg_call_b8adc8b1d0a0d8eb,\n\t\t\"__wbg_bind_c8359b1cba058168\": WEBPACK_IMPORTED_MODULE_0.__wbg_bind_c8359b1cba058168,\n\t\t\"__wbg_buffer_609cc3eee51ed158\": WEBPACK_IMPORTED_MODULE_0.__wbg_buffer_609cc3eee51ed158,\n\t\t\"__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a,\n\t\t\"__wbg_new_a12002a7f91c75be\": WEBPACK_IMPORTED_MODULE_0.__wbg_new_a12002a7f91c75be,\n\t\t\"__wbg_set_65595bdd868b3009\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_65595bdd868b3009,\n\t\t\"__wbg_length_a446193dc22c12f8\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_a446193dc22c12f8,\n\t\t\"__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354,\n\t\t\"__wbg_set_10bad9bee0e9c58b\": WEBPACK_IMPORTED_MODULE_0.__wbg_set_10bad9bee0e9c58b,\n\t\t\"__wbg_length_3b4f022188ae8db6\": WEBPACK_IMPORTED_MODULE_0.__wbg_length_3b4f022188ae8db6,\n\t\t\"__wbg_newwithlength_5a5efe313cfd59f1\": WEBPACK_IMPORTED_MODULE_0.__wbg_newwithlength_5a5efe313cfd59f1,\n\t\t\"__wbindgen_throw\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_throw,\n\t\t\"__wbindgen_memory\": WEBPACK_IMPORTED_MODULE_0.__wbindgen_memory\n\t}\n});\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/rapier_wasm2d_bg.wasm?");

/***/ }),

/***/ "./node_modules/@dimforge/rapier2d/raw.js":
/*!************************************************!*\
  !*** ./node_modules/@dimforge/rapier2d/raw.js ***!
  \************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RawBroadPhase: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawBroadPhase),\n/* harmony export */   RawCCDSolver: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawCCDSolver),\n/* harmony export */   RawCharacterCollision: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawCharacterCollision),\n/* harmony export */   RawColliderSet: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawColliderSet),\n/* harmony export */   RawColliderShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawColliderShapeCastHit),\n/* harmony export */   RawContactForceEvent: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawContactForceEvent),\n/* harmony export */   RawContactManifold: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawContactManifold),\n/* harmony export */   RawContactPair: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawContactPair),\n/* harmony export */   RawDebugRenderPipeline: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawDebugRenderPipeline),\n/* harmony export */   RawDeserializedWorld: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawDeserializedWorld),\n/* harmony export */   RawEventQueue: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawEventQueue),\n/* harmony export */   RawFeatureType: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawFeatureType),\n/* harmony export */   RawGenericJoint: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawGenericJoint),\n/* harmony export */   RawImpulseJointSet: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawImpulseJointSet),\n/* harmony export */   RawIntegrationParameters: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawIntegrationParameters),\n/* harmony export */   RawIslandManager: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawIslandManager),\n/* harmony export */   RawJointAxis: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawJointAxis),\n/* harmony export */   RawJointType: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawJointType),\n/* harmony export */   RawKinematicCharacterController: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawKinematicCharacterController),\n/* harmony export */   RawMotorModel: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawMotorModel),\n/* harmony export */   RawMultibodyJointSet: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawMultibodyJointSet),\n/* harmony export */   RawNarrowPhase: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawNarrowPhase),\n/* harmony export */   RawPhysicsPipeline: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawPhysicsPipeline),\n/* harmony export */   RawPidController: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawPidController),\n/* harmony export */   RawPointColliderProjection: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawPointColliderProjection),\n/* harmony export */   RawPointProjection: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawPointProjection),\n/* harmony export */   RawQueryPipeline: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawQueryPipeline),\n/* harmony export */   RawRayColliderHit: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderHit),\n/* harmony export */   RawRayColliderIntersection: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRayColliderIntersection),\n/* harmony export */   RawRayIntersection: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRayIntersection),\n/* harmony export */   RawRigidBodySet: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodySet),\n/* harmony export */   RawRigidBodyType: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRigidBodyType),\n/* harmony export */   RawRotation: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawRotation),\n/* harmony export */   RawSerializationPipeline: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawSerializationPipeline),\n/* harmony export */   RawShape: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawShape),\n/* harmony export */   RawShapeCastHit: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawShapeCastHit),\n/* harmony export */   RawShapeContact: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawShapeContact),\n/* harmony export */   RawShapeType: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawShapeType),\n/* harmony export */   RawVector: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.RawVector),\n/* harmony export */   __wbg_bind_c8359b1cba058168: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_bind_c8359b1cba058168),\n/* harmony export */   __wbg_buffer_609cc3eee51ed158: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_buffer_609cc3eee51ed158),\n/* harmony export */   __wbg_call_7cccdd69e0791ae2: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_7cccdd69e0791ae2),\n/* harmony export */   __wbg_call_833bed5770ea2041: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_833bed5770ea2041),\n/* harmony export */   __wbg_call_b8adc8b1d0a0d8eb: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_call_b8adc8b1d0a0d8eb),\n/* harmony export */   __wbg_length_3b4f022188ae8db6: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_3b4f022188ae8db6),\n/* harmony export */   __wbg_length_a446193dc22c12f8: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_length_a446193dc22c12f8),\n/* harmony export */   __wbg_new_a12002a7f91c75be: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_new_a12002a7f91c75be),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_d97e637ebe145a9a: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_d97e637ebe145a9a),\n/* harmony export */   __wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354),\n/* harmony export */   __wbg_newwithlength_5a5efe313cfd59f1: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_newwithlength_5a5efe313cfd59f1),\n/* harmony export */   __wbg_rawcontactforceevent_new: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawcontactforceevent_new),\n/* harmony export */   __wbg_rawraycolliderintersection_new: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_rawraycolliderintersection_new),\n/* harmony export */   __wbg_set_10bad9bee0e9c58b: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_10bad9bee0e9c58b),\n/* harmony export */   __wbg_set_65595bdd868b3009: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_65595bdd868b3009),\n/* harmony export */   __wbg_set_wasm: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbg_set_wasm),\n/* harmony export */   __wbindgen_boolean_get: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_boolean_get),\n/* harmony export */   __wbindgen_is_function: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_is_function),\n/* harmony export */   __wbindgen_memory: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_memory),\n/* harmony export */   __wbindgen_number_get: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_get),\n/* harmony export */   __wbindgen_number_new: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_number_new),\n/* harmony export */   __wbindgen_object_drop_ref: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_object_drop_ref),\n/* harmony export */   __wbindgen_throw: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.__wbindgen_throw),\n/* harmony export */   version: () => (/* reexport safe */ _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__.version)\n/* harmony export */ });\n/* harmony import */ var _rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rapier_wasm2d */ \"./node_modules/@dimforge/rapier2d/rapier_wasm2d.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__]);\n_rapier_wasm2d__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n//# sourceMappingURL=raw.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./node_modules/@dimforge/rapier2d/raw.js?");

/***/ }),

/***/ "./node_modules/ansi-up/dist/ansi-up.js":
/*!**********************************************!*\
  !*** ./node_modules/ansi-up/dist/ansi-up.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnsiUp: () => (/* binding */ AnsiUp)\n/* harmony export */ });\nvar AnsiUp = (function () {\n    function AnsiUp() {\n        this.ansi_colors = [\n            // Normal colors\n            [\n                { rgb: [0, 0, 0], class_name: \"ansi-black\" },\n                { rgb: [187, 0, 0], class_name: \"ansi-red\" },\n                { rgb: [0, 187, 0], class_name: \"ansi-green\" },\n                { rgb: [187, 187, 0], class_name: \"ansi-yellow\" },\n                { rgb: [0, 0, 187], class_name: \"ansi-blue\" },\n                { rgb: [187, 0, 187], class_name: \"ansi-magenta\" },\n                { rgb: [0, 187, 187], class_name: \"ansi-cyan\" },\n                { rgb: [255, 255, 255], class_name: \"ansi-white\" }\n            ],\n            // Bright colors\n            [\n                { rgb: [85, 85, 85], class_name: \"ansi-bright-black\" },\n                { rgb: [255, 85, 85], class_name: \"ansi-bright-red\" },\n                { rgb: [0, 255, 0], class_name: \"ansi-bright-green\" },\n                { rgb: [255, 255, 85], class_name: \"ansi-bright-yellow\" },\n                { rgb: [85, 85, 255], class_name: \"ansi-bright-blue\" },\n                { rgb: [255, 85, 255], class_name: \"ansi-bright-magenta\" },\n                { rgb: [85, 255, 255], class_name: \"ansi-bright-cyan\" },\n                { rgb: [255, 255, 255], class_name: \"ansi-bright-white\" }\n            ]\n        ];\n        this.setup_256_palette();\n        this.useClasses = false;\n        this.escapeForHtml = true;\n        this.bright = false;\n        this.fg = this.bg = null;\n        this._buffer = '';\n    }\n    Object.defineProperty(AnsiUp.prototype, \"useClasses\", {\n        get: function () {\n            return this._useClasses;\n        },\n        set: function (useClasses) {\n            this._useClasses = useClasses;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnsiUp.prototype, \"escapeForHtml\", {\n        get: function () {\n            return this._escapeForHtml;\n        },\n        set: function (arg) {\n            this._escapeForHtml = arg;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AnsiUp.prototype.setup_256_palette = function () {\n        var _this = this;\n        this.palette_256 = [];\n        // Index 0..15 : Ansi-Colors\n        this.ansi_colors.forEach(function (palette) {\n            palette.forEach(function (rec) {\n                _this.palette_256.push(rec);\n            });\n        });\n        // Index 16..231 : RGB 6x6x6\n        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n        var levels = [0, 95, 135, 175, 215, 255];\n        for (var r = 0; r < 6; ++r) {\n            for (var g = 0; g < 6; ++g) {\n                for (var b = 0; b < 6; ++b) {\n                    var c = { rgb: [levels[r], levels[g], levels[b]], class_name: 'truecolor' };\n                    this.palette_256.push(c);\n                }\n            }\n        }\n        // Index 232..255 : Grayscale\n        var grey_level = 8;\n        for (var i = 0; i < 24; ++i, grey_level += 10) {\n            var c = { rgb: [grey_level, grey_level, grey_level], class_name: 'truecolor' };\n            this.palette_256.push(c);\n        }\n    };\n    AnsiUp.prototype.doEscape = function (txt) {\n        return txt.replace(/[&<>]/gm, function (str) {\n            if (str === \"&\")\n                return \"&amp;\";\n            if (str === \"<\")\n                return \"&lt;\";\n            if (str === \">\")\n                return \"&gt;\";\n        });\n    };\n    AnsiUp.prototype.old_linkify = function (txt) {\n        return txt.replace(/(https?:\\/\\/[^\\s]+)/gm, function (str) {\n            return \"<a href=\\\"\" + str + \"\\\">\" + str + \"</a>\";\n        });\n    };\n    AnsiUp.prototype.detect_incomplete_ansi = function (txt) {\n        return !(/.*?[\\x40-\\x7e]/.test(txt));\n    };\n    AnsiUp.prototype.detect_incomplete_link = function (txt) {\n        var found = false;\n        for (var i = txt.length - 1; i > 0; i--) {\n            if (/\\s|\\x1B/.test(txt[i])) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            // Handle one other case\n            // Maybe the whole string is a URL?\n            if (/(https?:\\/\\/[^\\s]+)/.test(txt)) {\n                return 0;\n            }\n            else\n                return -1;\n        }\n        // Test if possible prefix\n        var prefix = txt.substr(i + 1, 4);\n        if (prefix.length === 0)\n            return -1;\n        if (\"http\".indexOf(prefix) === 0) {\n            return (i + 1);\n        }\n    };\n    AnsiUp.prototype.ansi_to_html = function (txt) {\n        var _this = this;\n        var pkt = this._buffer + txt;\n        this._buffer = '';\n        var raw_text_pkts = pkt.split(/\\x1B\\[/);\n        if (raw_text_pkts.length === 1)\n            raw_text_pkts.push('');\n        // COMPLEX - BEGIN\n        // Validate the last chunks for:\n        // - incomplete ANSI sequence\n        // - incomplete ESC\n        // If any of these occur, we may have to buffer\n        var last_pkt = raw_text_pkts[raw_text_pkts.length - 1];\n        // - incomplete ANSI sequence\n        if ((last_pkt.length > 0) && this.detect_incomplete_ansi(last_pkt)) {\n            this._buffer = '\\x1B\\[' + last_pkt;\n            raw_text_pkts.pop();\n            raw_text_pkts.push('');\n        }\n        else {\n            // - incomplete ESC\n            if (last_pkt.slice(-1) === '\\x1B') {\n                this._buffer = '\\x1B';\n                console.log(\"raw\", raw_text_pkts);\n                raw_text_pkts.pop();\n                raw_text_pkts.push(last_pkt.substr(0, last_pkt.length - 1));\n                console.log(raw_text_pkts);\n                console.log(last_pkt);\n            }\n            // - Incomplete ESC, only one packet\n            if (raw_text_pkts.length === 2 && (raw_text_pkts[1] == '') && (raw_text_pkts[0].slice(-1) == \"\\x1B\")) {\n                this._buffer = \"\\x1B\";\n                last_pkt = raw_text_pkts.shift();\n                raw_text_pkts.unshift(last_pkt.substr(0, last_pkt.length - 1));\n            }\n        }\n        // COMPLEX - END\n        var first_txt = this.wrap_text(raw_text_pkts.shift()); // the first pkt is not the result of the split\n        var blocks = raw_text_pkts.map(function (block) { return _this.wrap_text(_this.process_ansi(block)); });\n        if (first_txt.length > 0)\n            blocks.unshift(first_txt);\n        return blocks.join('');\n    };\n    AnsiUp.prototype.ansi_to_text = function (txt) {\n        var _this = this;\n        var raw_text_pkts = txt.split(/\\x1B\\[/);\n        var first_txt = raw_text_pkts.shift(); // the first pkt is not the result of the split\n        var blocks = raw_text_pkts.map(function (block) { return _this.process_ansi(block); });\n        if (first_txt.length > 0)\n            blocks.unshift(first_txt);\n        return blocks.join('');\n    };\n    AnsiUp.prototype.wrap_text = function (txt) {\n        if (txt.length === 0)\n            return txt;\n        if (this._escapeForHtml)\n            txt = this.doEscape(txt);\n        if (!this.bright && this.fg === null && this.bg === null)\n            return txt;\n        var styles = [];\n        var classes = [];\n        var fg = this.fg;\n        var bg = this.bg;\n        // Handle the case where we are told to be bright, but without a color\n        if (fg === null && this.bright)\n            fg = this.ansi_colors[1][7];\n        if (!this._useClasses) {\n            // USE INLINE STYLES\n            if (fg)\n                styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n            if (bg)\n                styles.push(\"background-color:rgb(\" + bg.rgb + \")\");\n        }\n        else {\n            // USE CLASSES\n            if (fg) {\n                if (fg.class_name !== 'truecolor') {\n                    classes.push(fg.class_name + \"-fg\");\n                }\n                else {\n                    styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n                }\n            }\n            if (bg) {\n                if (bg.class_name !== 'truecolor') {\n                    classes.push(bg.class_name + \"-bg\");\n                }\n                else {\n                    styles.push(\"background-color:rgb(\" + bg.rgb.join(',') + \")\");\n                }\n            }\n        }\n        var class_string = '';\n        var style_string = '';\n        if (classes.length)\n            class_string = \" class=\\\"\" + classes.join(' ') + \"\\\"\";\n        if (styles.length)\n            style_string = \" style=\\\"\" + styles.join(';') + \"\\\"\";\n        return \"<span\" + class_string + style_string + \">\" + txt + \"</span>\";\n    };\n    AnsiUp.prototype.process_ansi = function (block) {\n        // This must only be called with a string that started with a CSI (the string split above)\n        // The CSI must not be in the string. We consider this string to be a 'block'.\n        // It has an ANSI command at the front that affects the text that follows it.\n        //\n        // This regex is designed to parse an ANSI terminal CSI command. To be more specific,\n        // we follow the XTERM conventions vs. the various other \"standards\".\n        // http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n        //\n        // All ansi codes are typically in the following format. We parse it and focus\n        // specifically on the graphics commands (SGR)\n        //\n        // CONTROL-SEQUENCE-INTRODUCER CSI             (ESC, '[')\n        // PRIVATE-MODE-CHAR                           (!, <, >, ?)\n        // Numeric parameters separated by semicolons  ('0' - '9', ';')\n        // Intermediate-modifiers                      (0x20 - 0x2f)\n        // COMMAND-CHAR                                (0x40 - 0x7e)\n        //\n        // We use a regex to parse into capture groups the PRIVATE-MODE-CHAR to the COMMAND\n        // and the following text\n        //\n        // Lazy regex creation to keep nicely commented code here\n        // NOTE: default is multiline (workaround for now til I can\n        // determine flags inline)\n        if (!this._sgr_regex) {\n            this._sgr_regex = (_a = [\"\\n              ^                           # beginning of line\\n              ([!<-?]?)             # a private-mode char (!, <, =, >, ?)\\n              ([d;]*)                    # any digits or semicolons\\n              ([ -/]?               # an intermediate modifier\\n               [@-~])               # the command\\n              ([sS]*)                   # any text following this CSI sequence\\n              \"], _a.raw = [\"\\n              ^                           # beginning of line\\n              ([!\\\\x3c-\\\\x3f]?)             # a private-mode char (!, <, =, >, ?)\\n              ([\\\\d;]*)                    # any digits or semicolons\\n              ([\\\\x20-\\\\x2f]?               # an intermediate modifier\\n               [\\\\x40-\\\\x7e])               # the command\\n              ([\\\\s\\\\S]*)                   # any text following this CSI sequence\\n              \"], this.rgx(_a));\n        }\n        var matches = block.match(this._sgr_regex);\n        // The regex should have handled all cases!\n        if (!matches)\n            return block;\n        var orig_txt = matches[4];\n        if (matches[1] !== '' || matches[3] !== 'm')\n            return orig_txt;\n        // Ok - we have a valid \"SGR\" (Select Graphic Rendition)\n        var sgr_cmds = matches[2].split(';');\n        // Each of these params affects the SGR state\n        // Why do we shift through the array instead of a forEach??\n        // ... because some commands consume the params that follow !\n        while (sgr_cmds.length > 0) {\n            var sgr_cmd_str = sgr_cmds.shift();\n            var num = parseInt(sgr_cmd_str, 10);\n            if (isNaN(num) || num === 0) {\n                this.fg = this.bg = null;\n                this.bright = false;\n            }\n            else if (num === 1) {\n                this.bright = true;\n            }\n            else if (num === 22) {\n                this.bright = false;\n            }\n            else if (num === 39) {\n                this.fg = null;\n            }\n            else if (num === 49) {\n                this.bg = null;\n            }\n            else if ((num >= 30) && (num < 38)) {\n                var bidx = this.bright ? 1 : 0;\n                this.fg = this.ansi_colors[bidx][(num - 30)];\n            }\n            else if ((num >= 90) && (num < 98)) {\n                this.fg = this.ansi_colors[1][(num - 90)];\n            }\n            else if ((num >= 40) && (num < 48)) {\n                this.bg = this.ansi_colors[0][(num - 40)];\n            }\n            else if ((num >= 100) && (num < 108)) {\n                this.bg = this.ansi_colors[1][(num - 100)];\n            }\n            else if (num === 38 || num === 48) {\n                // extended set foreground/background color\n                // validate that param exists\n                if (sgr_cmds.length > 0) {\n                    // extend color (38=fg, 48=bg)\n                    var is_foreground = (num === 38);\n                    var mode_cmd = sgr_cmds.shift();\n                    // MODE '5' - 256 color palette\n                    if (mode_cmd === '5' && sgr_cmds.length > 0) {\n                        var palette_index = parseInt(sgr_cmds.shift(), 10);\n                        if (palette_index >= 0 && palette_index <= 255) {\n                            if (is_foreground)\n                                this.fg = this.palette_256[palette_index];\n                            else\n                                this.bg = this.palette_256[palette_index];\n                        }\n                    }\n                    // MODE '2' - True Color\n                    if (mode_cmd === '2' && sgr_cmds.length > 2) {\n                        var r = parseInt(sgr_cmds.shift(), 10);\n                        var g = parseInt(sgr_cmds.shift(), 10);\n                        var b = parseInt(sgr_cmds.shift(), 10);\n                        if ((r >= 0 && r <= 255) && (g >= 0 && g <= 255) && (b >= 0 && b <= 255)) {\n                            var c = { rgb: [r, g, b], class_name: 'truecolor' };\n                            if (is_foreground)\n                                this.fg = c;\n                            else\n                                this.bg = c;\n                        }\n                    }\n                }\n            }\n        }\n        return orig_txt;\n        var _a;\n    };\n    // ES5 template string transformer\n    // NOTE: default is multiline (workaround for now til I can\n    // determine flags inline)\n    AnsiUp.prototype.rgx = function (tmplObj) {\n        var subst = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            subst[_i - 1] = arguments[_i];\n        }\n        // Use the 'raw' value so we don't have to double backslash in a template string\n        var regexText = tmplObj.raw[0];\n        // Remove white-space and comments\n        var wsrgx = /^\\s+|\\s+\\n|\\s+#[\\s\\S]+?\\n/gm;\n        var txt2 = regexText.replace(wsrgx, '');\n        return new RegExp(txt2, 'm');\n    };\n    return AnsiUp;\n}());\n\n//# sourceMappingURL=ansi-up.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/ansi-up/dist/ansi-up.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ randomUUID });\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0,_rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./src/Components/Collider.ts":
/*!************************************!*\
  !*** ./src/Components/Collider.ts ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderC: () => (/* binding */ ColliderC),\n/* harmony export */   CollisionEventArgs: () => (/* binding */ CollisionEventArgs)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dimforge/rapier2d */ \"./node_modules/@dimforge/rapier2d/rapier.js\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Physics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Plugins/Physics */ \"./src/Plugins/Physics.ts\");\n/* harmony import */ var _RigidBody__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./RigidBody */ \"./src/Components/RigidBody.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_4__, _RigidBody__WEBPACK_IMPORTED_MODULE_5__]);\n([_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_4__, _RigidBody__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\nclass CollisionEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    collider;\n    constructor(collider) {\n        super();\n        this.collider = collider;\n    }\n}\nclass ColliderC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    offset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__.Vector(0, 0);\n    onCollisionEnterEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    onCollisionExitEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    colliderDesc;\n    collider;\n    constructor(radius = 1, isStatic = true, ...avoidObjectes) {\n        super();\n        this.colliderDesc = _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__.ColliderDesc.ball(radius);\n    }\n    start() {\n        this.onCollisionEnterEvent.register(this.getGameWorld());\n        this.onCollisionExitEvent.register(this.getGameWorld());\n    }\n    spawn() {\n        console.log(\"ColliderC spawned\");\n        // this.colliderDesc.setTranslation(this.offset.x, this.offset.y);\n        // this.colliderDesc.setSensor(true);\n        // this.colliderDesc.setCollisionGroups(0x0001);\n        // this.colliderDesc.setActiveEvents(true);\n        this.colliderDesc.setMass(0.25);\n        // this.colliderDesc.setDensity(1);\n        // this.colliderDesc.setRestitution(0.5);\n        // this.colliderDesc.setFriction(0.5);\n        this.collider = this.getPlugin(_Plugins_Physics__WEBPACK_IMPORTED_MODULE_4__.PhysicsPlugin).getWorld().createCollider(this.colliderDesc, this.getComponent(_RigidBody__WEBPACK_IMPORTED_MODULE_5__.RigidBodyC).getRigidBody());\n    }\n    getRadius() {\n        if (this.collider?.shape instanceof _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__.Ball)\n            return this.collider.shape.radius;\n        return 0;\n    }\n    onCollisionEnter(other) {\n        this.onCollisionEnterEvent.emit(new CollisionEventArgs(other));\n    }\n    onCollisionExit(other) {\n        this.onCollisionExitEvent.emit(new CollisionEventArgs(other));\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Collider.ts?");

/***/ }),

/***/ "./src/Components/Health.ts":
/*!**********************************!*\
  !*** ./src/Components/Health.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DamageEventArgs: () => (/* binding */ DamageEventArgs),\n/* harmony export */   HealthC: () => (/* binding */ HealthC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n\n\nclass DamageEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.EventArgs {\n    damage;\n    participant;\n    constructor(damage, participant) {\n        super();\n        this.damage = damage;\n        this.participant = participant;\n    }\n}\nclass HealthC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    health;\n    maxHealth;\n    damageEvent;\n    constructor(maxHealth, health = maxHealth) {\n        super();\n        this.health = health;\n        this.maxHealth = maxHealth;\n        this.damageEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.GameEvent();\n    }\n    start() {\n        this.damageEvent.register(this.gameObject?.manager?.gameWorld);\n        // this.getComponent(ColliderC).onCollisionEnterEvent.subscribe(this, \"onCollisionEnter\");\n    }\n    event(args) {\n        // let cargs = args as CollisionEventArgs;\n        // this.onCollisionEnter(cargs.collider);\n    }\n    // onCollisionEnter(other: ColliderC): void { \n    //     let otherGO = other.getGameObject();       \n    //     let otherRigidbody = otherGO.getComponent(RigidBodyC);\n    //     let thisRigidbody = this.getComponent(RigidBodyC);\n    //     let op = thisRigidbody.mass/(otherRigidbody.mass+thisRigidbody.mass);\n    //     if(thisRigidbody.mass<otherRigidbody.mass){\n    //         otherRigidbody.velocity = otherRigidbody.velocity.add(thisRigidbody.velocity.times(op)).times(0.5); //toUnit().times(v2);\n    //         thisRigidbody.velocity = thisRigidbody.velocity.add(otherRigidbody.velocity.times(1-op).times(0.5)); //toUnit().times(v2);\n    //     }\n    //     otherRigidbody.angularVelocity += this.getTransform().position.sub(otherGO.getTransform().position).vectorProduct(thisRigidbody.velocity)*(op/15);\n    //     try{\n    //         const other = otherGO.getComponent(HealthC);\n    //         const damageValue = Math.min(other.health, this.health);\n    //         if (damageValue==0)\n    //             return;\n    //         this.onDamage(damageValue, other);\n    //         other.onDamage(damageValue, this);            \n    //     }\n    //     catch {}\n    // }\n    getHealth() {\n        return this.health / this.maxHealth;\n    }\n    heal(value) {\n        this.health = Math.min(this.maxHealth, this.health + value);\n    }\n    onDamage(value, participant) {\n        this.health -= value;\n        this.damageEvent.emit(new DamageEventArgs(value, participant));\n        // if(this.health==0){\n        //     this.getComponent(ColliderC)?.enable(false);\n        //     this.getComponent(RigidBodyC).dampingFactor=0.6;\n        //     this.getComponent(AnimationC)?.startShrink();\n        //     if(participant.hasComponent(PolygonRendererC)){\n        //         let myColor = this.getComponent(PolygonRendererC).color;\n        //         let newColor = myColor.blend(\n        //             participant.getComponent(PolygonRendererC).color.toRgb(),\n        //             0.5\n        //         ).toRgb();\n        //         this.getComponent(PolygonRendererC).color = newColor;\n        //         participant.getComponent(PolygonRendererC).color = newColor;\n        //     }\n        // }\n        // else\n        //     this.getComponent(AnimationC)?.startZoom();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Health.ts?");

/***/ }),

/***/ "./src/Components/Renderers/BarRenderer.ts":
/*!*************************************************!*\
  !*** ./src/Components/Renderers/BarRenderer.ts ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarRendererC: () => (/* binding */ BarRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n/* harmony import */ var _Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Health */ \"./src/Components/Health.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nclass BarRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    offset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 4);\n    fill = 0.5;\n    width = 5;\n    height = 0.5;\n    constructor(zindex = 0) {\n        super(zindex);\n    }\n    //  const offset = this.getPlugin(CameraPlugin)!.cameraScreenOffset;\n    //         const x = ;\n    //         const y = this.gameObject!.getBody()!.getPosition().y;\n    //         const r = this.gameObject!.getBody()!.getPosition().x;\n    //         const transformScale = Vector.one();//this.getTransform().scale;\n    //         const scale = this.getPlugin(CameraPlugin)!.scaleV;\n    //         const cmx = this.getPlugin(CameraPlugin)!.cameraPositon.x;\n    //         const cmy = this.getPlugin(CameraPlugin)!.cameraPositon.y;\n    //         const color = this.color.toString();\n    //         const cx: number = (x-cmx);\n    //         const cy: number = (y-cmy);\n    render(context) {\n        let width = this.width;\n        let fill = this.fill;\n        try {\n            fill = this.getComponent(_Health__WEBPACK_IMPORTED_MODULE_4__.HealthC).getHealth();\n            width = 2 + this.getComponent(_Health__WEBPACK_IMPORTED_MODULE_4__.HealthC).maxHealth / 250.0;\n        }\n        catch { }\n        if (fill >= 1 || fill <= 0)\n            return;\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //this.getTransform().scale;\n        const scale = camera.scaleV;\n        const offset = camera.cameraScreenOffset;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.getHeatmapColor(fill).toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        const radius = 0.25;\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        // context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.translate(this.offset.x, this.offset.y);\n        context.fillStyle = color;\n        context.shadowBlur = 0;\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width, this.height, radius);\n        context.closePath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.fill();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width * fill, this.height, radius);\n        context.closePath();\n        context.fillStyle = color;\n        context.fill();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width, this.height, radius);\n        context.closePath();\n        context.shadowBlur = 30;\n        context.stroke();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width * fill, this.height, radius);\n        context.closePath();\n        context.shadowBlur = 0;\n        context.stroke();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/BarRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/ChasisRenderer.ts":
/*!****************************************************!*\
  !*** ./src/Components/Renderers/ChasisRenderer.ts ***!
  \****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChasisRendererC: () => (/* binding */ ChasisRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__, _PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__, _PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nclass ChasisRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_4__.RendererC {\n    color;\n    constructor(zindex = 0, color = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(22, 24, 25)) {\n        super();\n        this.zindex = zindex;\n        this.color = color;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //body.getScale();\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = x - cmx;\n        const cy = y - cmy;\n        // context.save();\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.beginPath();\n        context.fillStyle = this.getComponent(_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__.PolygonRendererC).color.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-4, -2, 8, 4, 1);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-4.5, -3.25, 10, 2, 0.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.shadowBlur = 0;\n        context.roundRect(-4.5, 1.25, 10, 2, 0.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-3, -2, 6, 4, 1.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.shadowBlur = 0;\n        ;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/ChasisRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/ColliderRenderer.ts":
/*!******************************************************!*\
  !*** ./src/Components/Renderers/ColliderRenderer.ts ***!
  \******************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderRendererC: () => (/* binding */ ColliderRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Plugins_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Collider */ \"./src/Components/Collider.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__, _Collider__WEBPACK_IMPORTED_MODULE_3__]);\n([_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__, _Collider__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nclass ColliderRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_4__.RendererC {\n    activeColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(172, 42, 55, 0.125);\n    staticColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(95, 64, 36, 0.125);\n    dynamicColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(57, 127, 31, 0.125);\n    disabledColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(36, 24, 36, 0.125);\n    constructor(zindex = -1) {\n        super();\n        this.zindex = zindex;\n    }\n    getColor() {\n        let color = this.dynamicColor;\n        let collider = this.getComponent(_Collider__WEBPACK_IMPORTED_MODULE_3__.ColliderC);\n        if (!collider.enabled)\n            color = this.disabledColor;\n        // else if (collider.isActive)\n        // color = this.activeColor;\n        // else if(collider.isStatic)\n        // color = this.staticColor;\n        return color;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        let display = this.getPlugin(_Plugins_Config__WEBPACK_IMPORTED_MODULE_2__.ConfigPlugin)?.get(\"displayColliders\") ?? false;\n        if (!display)\n            return;\n        const collider = this.getComponent(_Collider__WEBPACK_IMPORTED_MODULE_3__.ColliderC);\n        const colliderOffset = collider.offset;\n        const radius = collider.getRadius();\n        const radius2 = collider.getRadius() + 0.25;\n        const color = this.getColor();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x + colliderOffset.x;\n        const y = body.getPosition().y + colliderOffset.y;\n        const r = body.getRotation();\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        context.save();\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.strokeStyle = color.toRgb().toString();\n        context.fillStyle = color.toString();\n        context.shadowBlur = 30;\n        context.beginPath();\n        context.arc(0, 0, radius2, 0, 2 * Math.PI);\n        context.closePath();\n        context.fill();\n        context.stroke();\n        context.beginPath();\n        context.arc(0, 0, radius, 0, 2 * Math.PI);\n        context.closePath();\n        context.lineWidth = 0.1;\n        context.stroke();\n        // context.setTransform(1, 0, 0, 1, 0, 0);\n        context.restore();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/ColliderRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/PolygonRenderer.ts":
/*!*****************************************************!*\
  !*** ./src/Components/Renderers/PolygonRenderer.ts ***!
  \*****************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolygonRendererC: () => (/* binding */ PolygonRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\nclass PolygonRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    color;\n    radius;\n    n;\n    constructor(side, n = 4, zindex = 0, color = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.randomColor2()) {\n        super();\n        this.radius = side;\n        this.n = n;\n        this.zindex = zindex;\n        this.color = color;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.one(); //this.getTransform().scale;\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        // context.save();\n        // const sin = Math.sin(r);\n        // const cos = Math.cos(r);\n        // const sx = scale.x * transformScale.x;\n        // const sy = scale.y * transformScale.y;\n        // const a2 = cos * sx;\n        // const b = sin * sx;\n        // const c = -sin * sy;\n        // const d = cos * sy;\n        // const e = offset.x + scale.x * (cx * cos - cy * sin);\n        // const f = offset.y + scale.y * (cx * sin + cy * cos);\n        // // Ustaw bezpośrednio macierz transformacji\n        // context.setTransform(a2, b, c, d, e, f);\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        const a = this.radius;\n        if (this.n < 10) {\n            context.beginPath();\n            context.moveTo(0, a);\n            const angle = (2 * Math.PI) / this.n;\n            for (let i = 1; i < this.n; i++) {\n                context.lineTo(Math.sin(i * angle) * a, Math.cos(i * angle) * a);\n            }\n            context.closePath();\n        }\n        else {\n            context.beginPath();\n            context.arc(0, 0, a, 0, 2 * Math.PI);\n            context.closePath();\n        }\n        context.fillStyle = color;\n        context.shadowBlur = 0;\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.shadowBlur = 0;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/PolygonRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/Renderer.ts":
/*!**********************************************!*\
  !*** ./src/Components/Renderers/Renderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RendererC: () => (/* binding */ RendererC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Component */ \"./src/Core/Component.ts\");\n\nclass RendererC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    zindex;\n    constructor(zindex = 0) {\n        super();\n        this.zindex = zindex;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/Renderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/TextRenderer.ts":
/*!**************************************************!*\
  !*** ./src/Components/Renderers/TextRenderer.ts ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextRendererC: () => (/* binding */ TextRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\nclass TextRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    color = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(42, 42, 55);\n    text;\n    displayName;\n    constructor(text, displayName = false, zindex = 1) {\n        super();\n        this.text = text;\n        this.zindex = zindex;\n        this.displayName = displayName;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //body.getScale();\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        // context.save();\n        context.fillStyle = color;\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        // context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.scale(1, -1);\n        // context.fillRect(-a, -a, 2*a, 2*a);\n        // context.shadowBlur = 30;\n        // context.strokeRect(-a, -a, 2*a, 2*a);\n        const text = this.displayName ? this.gameObject.name : this.text;\n        const textHeight = 1.0;\n        context.font = \"bold \" + textHeight + \"px Arial\";\n        context.fillStyle = \"azure\";\n        context.shadowBlur = 10;\n        const textOffset = context.measureText(text).width / 2;\n        context.strokeText(text, -textOffset, textHeight / 4);\n        context.fillText(text, -textOffset, textHeight / 4);\n        context.shadowBlur = 0;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/TextRenderer.ts?");

/***/ }),

/***/ "./src/Components/RigidBody.ts":
/*!*************************************!*\
  !*** ./src/Components/RigidBody.ts ***!
  \*************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RigidBodyC: () => (/* binding */ RigidBodyC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dimforge/rapier2d */ \"./node_modules/@dimforge/rapier2d/rapier.js\");\n/* harmony import */ var _Plugins_Physics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Plugins/Physics */ \"./src/Plugins/Physics.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_3__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__, _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_3__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\nclass RigidBodyC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    body;\n    bodyDef = _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__.RigidBodyDesc\n        .dynamic()\n        .setTranslation(0, 0)\n        .setLinvel(0, 0)\n        .setLinearDamping(0)\n        .setRotation(0)\n        .setAngvel(0)\n        .setAngularDamping(0.2);\n    force = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    constructor(dampingFactor = 0.45) {\n        super();\n        this.setDamping(dampingFactor);\n    }\n    spawn() {\n        console.log(\"BodyC spawned\");\n        this.body = this.getPlugin(_Plugins_Physics__WEBPACK_IMPORTED_MODULE_3__.PhysicsPlugin).getWorld().createRigidBody(this.bodyDef);\n    }\n    destroy() {\n        console.log(\"BodyC destroyed\");\n        this.getPlugin(_Plugins_Physics__WEBPACK_IMPORTED_MODULE_3__.PhysicsPlugin)?.getWorld().removeRigidBody(this.body);\n    }\n    update(delta) {\n        this.body.resetForces(true);\n        this.body.addForce(this.force, true); // = this.body;\n    }\n    //set parameters\n    setPosition(position) {\n        if (this.body)\n            this.body.setTranslation(position, true);\n        this.bodyDef.setTranslation(position.x, position.y);\n    }\n    getPosition() {\n        return _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.fromVec2(this.body.translation()) ?? this.bodyDef.translation ?? new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    }\n    setRotation(rotation) {\n        if (this.body)\n            this.body.setRotation(rotation, true);\n        this.bodyDef.setRotation(rotation);\n    }\n    getRotation() {\n        return this.body.rotation() ?? this.bodyDef.rotation ?? 0;\n    }\n    setVelocity(velocity) {\n        if (this.body)\n            this.body.setLinvel(velocity, true);\n        this.bodyDef.setLinvel(velocity.x, velocity.y);\n    }\n    getVelocity() {\n        return _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.fromVec2(this.body.linvel()) ?? this.bodyDef.linvel ?? new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    }\n    setAngularVelocity(angularVelocity) {\n        if (this.body)\n            this.body.setAngvel(angularVelocity, true);\n        this.bodyDef.setAngvel(angularVelocity);\n    }\n    getAngularVelocity() {\n        return this.body.angvel() ?? this.bodyDef.angvel ?? 0;\n    }\n    setAngularDamping(angularDamping) {\n        if (this.body)\n            this.body.setAngularDamping(angularDamping);\n        this.bodyDef.setAngularDamping(angularDamping);\n    }\n    getAngularDamping() {\n        return this.body.angularDamping() ?? this.bodyDef.angularDamping ?? 0;\n    }\n    setDamping(linearDamping) {\n        if (this.body)\n            this.body.setLinearDamping(linearDamping);\n        this.bodyDef.setLinearDamping(linearDamping);\n    }\n    getDamping() {\n        return this.body.linearDamping() ?? this.bodyDef.linearDamping ?? 0;\n    }\n    getRigidBody() {\n        return this.body;\n    }\n    // public setAllowSleep(allowSleep: boolean): void {\n    //     if (this.body)\n    //         this.body.setslep(allowSleep);\n    //     this.bodyDef.allowSleep = allowSleep;\n    // }\n    // public getAllowSleep(): boolean {\n    //     return this.body.isSleepingAllowed()??this.bodyDef.allowSleep??false;\n    // }\n    //forces\n    setForce(force) {\n        this.force = force;\n    }\n    getForce() {\n        return this.force;\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Components/RigidBody.ts?");

/***/ }),

/***/ "./src/Components/Tags.ts":
/*!********************************!*\
  !*** ./src/Components/Tags.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TagsC: () => (/* binding */ TagsC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n\nclass TagsC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    tags = new Set();\n    constructor(...tags) {\n        super();\n        tags.forEach(tag => this.addTag(tag));\n    }\n    addTag(tag) {\n        this.tags.add(tag);\n    }\n    removeTag(tag) {\n        this.tags.delete(tag);\n    }\n    hasTag(tag) {\n        return this.tags.has(tag);\n    }\n    getTags() {\n        return Array.from(this.tags);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Tags.ts?");

/***/ }),

/***/ "./src/Core/Component.ts":
/*!*******************************!*\
  !*** ./src/Core/Component.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n\nclass Component {\n    enabled = true;\n    id = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    gameObject;\n    //overideable methods\n    spawn() { }\n    start() { }\n    event(args, alias) { }\n    destroy() { }\n    getComponent(classC) {\n        return this.gameObject?.getComponent(classC);\n    }\n    getAllComponents() {\n        return this.gameObject?.getAllComponents() ?? [];\n    }\n    getPlugin(plugin) {\n        return this.gameObject?.manager?.getPlugin(plugin);\n    }\n    getGameWorld() {\n        return this.gameObject?.manager?.gameWorld;\n    }\n    getManager() {\n        return this.gameObject?.manager;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/Component.ts?");

/***/ }),

/***/ "./src/Core/GameEvent.ts":
/*!*******************************!*\
  !*** ./src/Core/GameEvent.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventArgs: () => (/* binding */ EventArgs),\n/* harmony export */   GameEvent: () => (/* binding */ GameEvent)\n/* harmony export */ });\nclass EventArgs {\n    constructor() { }\n}\nclass GameEvent {\n    subs = new Map();\n    args = [];\n    subscribe(sub, alias) {\n        this.subs.set(new WeakRef(sub), alias);\n    }\n    unsubscribe(sub) {\n        this.subs.delete(new WeakRef(sub));\n    }\n    emit(args) {\n        this.args.push(args);\n    }\n    register(gameWorld) {\n        gameWorld?.registerEvent(this);\n    }\n    invoke() {\n        if (this.args.length == 0)\n            return;\n        for (const [sub, alias] of this.subs) {\n            const derefSub = sub.deref();\n            if (!derefSub) {\n                this.subs.delete(sub);\n                continue;\n            }\n            for (const args of this.args)\n                derefSub.event(args, alias);\n        }\n        this.args = [];\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/GameEvent.ts?");

/***/ }),

/***/ "./src/Core/GameObject.ts":
/*!********************************!*\
  !*** ./src/Core/GameObject.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObject: () => (/* binding */ GameObject)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/RigidBody */ \"./src/Components/RigidBody.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__]);\n_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nclass GameObject {\n    enabled = true;\n    name = \"GameObject\";\n    id = (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    manager = undefined;\n    components = new Map();\n    constructor(...components) {\n        for (let component of components) {\n            const id = component.id;\n            if (this.components.has(id))\n                throw new Error(`Component with id: ${id} already exists in the game object`);\n            component.gameObject = this;\n            this.components.set(id, component);\n        }\n    }\n    getComponent(classC) {\n        return this.components.values().find(c => c instanceof classC);\n    }\n    getComponents(classC) {\n        return Array.from(this.components.values()).filter(c => c instanceof classC);\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getBody() {\n        return this.getComponent(_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__.RigidBodyC);\n    }\n    spawn() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.spawn();\n    }\n    start() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.start();\n    }\n    update() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.update();\n    }\n    destroy() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.destroy();\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Core/GameObject.ts?");

/***/ }),

/***/ "./src/Core/GameWorld.ts":
/*!*******************************!*\
  !*** ./src/Core/GameWorld.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameWorld: () => (/* binding */ GameWorld)\n/* harmony export */ });\n/* harmony import */ var _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Plugins/Hud/Profiler */ \"./src/Plugins/Hud/Profiler.ts\");\n\nclass GameWorld {\n    startTime = 0;\n    prevWorldTime = 0;\n    worldTime = 0;\n    tickCount = 0;\n    plugins = new Map();\n    events = new Set();\n    constructor(...plugins) {\n        for (let plugin of plugins) {\n            let name = plugin.constructor.name;\n            if (this.plugins.has(name))\n                throw new Error(`Plugin ${name} already exists in the game object`);\n            plugin.gameWorld = this;\n            this.plugins.set(name, plugin);\n        }\n    }\n    //plugins\n    getPlugin(plugin) {\n        const name = plugin.name;\n        return this.getPluginByName(name);\n    }\n    getPluginByName(name) {\n        if (!this.plugins.has(name))\n            throw new Error(`Plugin ${name} does not exist in the game world`);\n        return this.plugins.get(name);\n    }\n    getAllPlugins() {\n        return Array.from(this.plugins.values());\n    }\n    hasPlugin(plugin) {\n        const name = plugin.name;\n        return this.plugins.has(name);\n    }\n    registerEvent(event) {\n        this.events.add(new WeakRef(event));\n    }\n    //time\n    getWorldTime() {\n        return this.worldTime / 1e3;\n    }\n    //flow control of components\n    // 1. start / update\n    // 2. event\n    tick() {\n        this.tickCount++;\n        if (this.tickCount == 1)\n            this.startWorld();\n        else\n            this.updateWorld();\n        this.invokeEvents();\n    }\n    startWorld() {\n        this.startTime = performance.now();\n        this.Start();\n        this.plugins.forEach(plugin => plugin.start());\n    }\n    updateWorld() {\n        this.worldTime = performance.now() - this.startTime;\n        const delta = this.worldTime - this.prevWorldTime;\n        this.prevWorldTime = this.worldTime;\n        this.Update(delta / 1e3);\n        this.plugins.forEach(plugin => {\n            if (!plugin.enabled)\n                return;\n            let start = performance.now();\n            plugin.update(delta / 1e3);\n            this.getPlugin(_Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__.ProfilerPlugin).addRecord(plugin.name, performance.now() - start);\n        });\n    }\n    invokeEvents() {\n        let start = performance.now();\n        for (const eventRef of this.events) {\n            const event = eventRef.deref();\n            if (event)\n                event.invoke();\n            else\n                this.events.delete(eventRef);\n        }\n        this.getPlugin(_Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__.ProfilerPlugin).addRecord(\"Events\", performance.now() - start);\n    }\n    //overridable methods\n    Start() { }\n    Update(delta) { }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/GameWorld.ts?");

/***/ }),

/***/ "./src/Core/Plugin.ts":
/*!****************************!*\
  !*** ./src/Core/Plugin.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Plugin: () => (/* binding */ Plugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n//WorldComponent = Plugin\nclass Plugin {\n    enabled = true;\n    name = \"Plugin\";\n    gameWorld;\n    //overideable methods\n    event(args, alias) { }\n    start() { }\n    update(delta) { }\n    getPlugin(plugin) {\n        return this.gameWorld.getPlugin(plugin);\n    }\n    hasPlugin(plugin) {\n        return this.gameWorld.hasPlugin(plugin) ?? false;\n    }\n    cliGetName() {\n        return this.name;\n    }\n    help() {\n        const BLUE = \"\\x1b[36m\";\n        const RESET = \"\\x1b[0m\";\n        let message = `${BLUE}${this.cliGetName()}${RESET} commands:\\n`;\n        for (const element of Object.values(this.constructor[\"syntaxes\"])) {\n            message += `  /${this.cliGetName()}:${element}\\n`;\n        }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, message, undefined);\n    }\n    cliEnable() {\n        const GREEN = \"\\x1b[32m\";\n        const RESET = \"\\x1b[0m\";\n        this.enabled = true;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, `${this.name} ${GREEN}enabled${RESET}`, undefined);\n    }\n    cliDisable() {\n        const RED = \"\\x1b[31m\";\n        const RESET = \"\\x1b[0m\";\n        this.enabled = false;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, `${this.name} ${RED}disabled${RESET}`, undefined);\n    }\n}\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"help\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"help\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"enable\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"cliEnable\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"disable\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"cliDisable\", null);\n\n\n//# sourceURL=webpack://gameengine/./src/Core/Plugin.ts?");

/***/ }),

/***/ "./src/GameObjectFactory.ts":
/*!**********************************!*\
  !*** ./src/GameObjectFactory.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObjectFactory: () => (/* binding */ GameObjectFactory)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Components_Collider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Components/Collider */ \"./src/Components/Collider.ts\");\n/* harmony import */ var _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Components/Renderers/ChasisRenderer */ \"./src/Components/Renderers/ChasisRenderer.ts\");\n/* harmony import */ var _Core_GameObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Core/GameObject */ \"./src/Core/GameObject.ts\");\n/* harmony import */ var _Components_RigidBody__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Components/RigidBody */ \"./src/Components/RigidBody.ts\");\n/* harmony import */ var _Components_Tags__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Components/Tags */ \"./src/Components/Tags.ts\");\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Components/Renderers/BarRenderer */ \"./src/Components/Renderers/BarRenderer.ts\");\n/* harmony import */ var _Components_Health__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Components/Health */ \"./src/Components/Health.ts\");\n/* harmony import */ var _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Components/Renderers/TextRenderer */ \"./src/Components/Renderers/TextRenderer.ts\");\n/* harmony import */ var _Helpers_Math__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Helpers/Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Components/Renderers/ColliderRenderer */ \"./src/Components/Renderers/ColliderRenderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Components_Collider__WEBPACK_IMPORTED_MODULE_1__, _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_2__, _Core_GameObject__WEBPACK_IMPORTED_MODULE_3__, _Components_RigidBody__WEBPACK_IMPORTED_MODULE_4__, _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_6__, _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__, _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_9__, _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_11__]);\n([_Components_Collider__WEBPACK_IMPORTED_MODULE_1__, _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_2__, _Core_GameObject__WEBPACK_IMPORTED_MODULE_3__, _Components_RigidBody__WEBPACK_IMPORTED_MODULE_4__, _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_6__, _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__, _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_9__, _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_11__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n\nclass GameObjectFactory {\n    static polygonGO(radius = 2, n = 3, ...components) {\n        let polygonGO = new _Core_GameObject__WEBPACK_IMPORTED_MODULE_3__.GameObject(\n        // new RigidBodyC(0.1),\n        new _Components_RigidBody__WEBPACK_IMPORTED_MODULE_4__.RigidBodyC(0.1), new _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_6__.PolygonRendererC(radius, n, 0, _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.randomColor2().toArgb(0.75)), new _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__.BarRendererC(0.1), new _Components_Collider__WEBPACK_IMPORTED_MODULE_1__.ColliderC(_Helpers_Math__WEBPACK_IMPORTED_MODULE_10__.GMath.getColliderRadius(n, radius)), new _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_11__.ColliderRendererC(), new _Components_Health__WEBPACK_IMPORTED_MODULE_8__.HealthC(25 * n), \n        // new AnimationC(),\n        new _Components_Tags__WEBPACK_IMPORTED_MODULE_5__.TagsC(\"Dragable\"), ...components);\n        polygonGO.getBody().setRotation(Math.random() * 2 * Math.PI);\n        // polygonGO.name = \"Polygon\";\n        return polygonGO;\n    }\n    // public static enemyGO(radius: number = 2.5, text: string=\"\", zindex = 4, ...components: Component[]): GameObject {\n    //     let circleGO: GameObject = new GameObject(\n    //         new TextRendererC(text, undefined, zindex+0.1),\n    //         new PolygonRendererC(radius, 8, zindex),\n    //         new BarRendererC(zindex+0.1),\n    //         new ChasisRendererC(zindex-0.2),\n    //         new RigidBodyC(30),\n    //         new ColliderC(radius, false),\n    //         new ColliderRendererC(zindex-0.15),\n    //         new HealthC(1500),\n    //         new AnimationC(),\n    //         new TracesRendererC(-21.37),\n    //         ...components\n    //     );\n    //     circleGO.getTransform().rotation = GMath.symRand(Math.PI);\n    //     circleGO.getComponent(CanonC).targetDirection = Vector.fromRad(GMath.symRand(Math.PI));\n    //     circleGO.name = \"Enemy\";\n    //     return circleGO;\n    // }\n    // public static bulletGO(owner: GameObject, hp=30, radius: number = 0.65, lifeTime: number=1, zindex=-1, ...components: Component[]): GameObject {\n    //     let bulletGO: GameObject = new GameObject(\n    //         new RigidBodyC(0.05, 1.0),\n    //         new PolygonRendererC(radius, 10, zindex, new rgb(173, 87, 87)),\n    //         new ColliderC(radius, false),\n    //         new ColliderRendererC(),\n    //         new HealthC(hp),\n    //         new AnimationC(),\n    //         new DestroyerC(lifeTime),\n    //         new BulletC(owner),\n    //         ...components\n    //     );\n    //     bulletGO.getTransform().rotation = 0;\n    //     bulletGO.name = \"Bullet\";\n    //     return bulletGO;\n    // }\n    static playerGO(radius = 2.5, zindex = 5, ...components) {\n        let playerGO = new _Core_GameObject__WEBPACK_IMPORTED_MODULE_3__.GameObject(\n        // new ImageRendererC(undefined, new Vector(1.3, 0.3), \"GameEngine/src/Assets/vectorpaint2.svg\" , zindex-0.2),\n        new _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_2__.ChasisRendererC(zindex - 0.2), new _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_6__.PolygonRendererC(radius, 10, zindex, new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(50, 99, 52)), new _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_9__.TextRendererC(\"Player\", true, zindex + 0.1), new _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_11__.ColliderRendererC(zindex - 0.15), new _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__.BarRendererC(zindex + 0.1), \n        // new CanonRendererC(zindex-0.1),\n        new _Components_RigidBody__WEBPACK_IMPORTED_MODULE_4__.RigidBodyC(25), new _Components_Collider__WEBPACK_IMPORTED_MODULE_1__.ColliderC(radius, false), new _Components_Health__WEBPACK_IMPORTED_MODULE_8__.HealthC(1000), \n        // new AnimationC(),\n        // new CanonC(6, 1.55, 44),\n        // new TracesRendererC(-21.37),\n        ...components);\n        playerGO.getBody().setRotation(Math.random() * 2 * Math.PI);\n        playerGO.name = \"Player\";\n        return playerGO;\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/GameObjectFactory.ts?");

/***/ }),

/***/ "./src/Helpers/Color.ts":
/*!******************************!*\
  !*** ./src/Helpers/Color.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rgb: () => (/* binding */ rgb)\n/* harmony export */ });\nclass rgb {\n    r = 0;\n    g = 0;\n    b = 0;\n    a = 1;\n    static stroke = new rgb(43, 43, 44);\n    // public static readonly background: rgb = new rgb(91, 93, 98);\n    static background = new rgb(93, 97, 95);\n    constructor(r, g, b, a = 1) {\n        this.r = Math.min(255, Math.max(0, r));\n        this.g = Math.min(255, Math.max(0, g));\n        this.b = Math.min(255, Math.max(0, b));\n        this.a = Math.min(1, Math.max(0, a));\n    }\n    toString() {\n        return `rgba(${this.r},${this.g},${this.b},${Math.max(0, Math.min(this.a, 1))})`;\n    }\n    toRgb() {\n        return new rgb(this.r, this.g, this.b);\n    }\n    toArgb(alpha) {\n        return new rgb(this.r, this.g, this.b, alpha);\n    }\n    blend(color, alpha) {\n        return new rgb(this.r * (1 - alpha) + color.r * alpha, this.g * (1 - alpha) + color.g * alpha, this.b * (1 - alpha) + color.b * alpha, this.a * (1 - alpha) + color.a * alpha);\n    }\n    static randomColor() {\n        return new rgb(Math.random() * 255, Math.random() * 255, Math.random() * 255);\n    }\n    static hslToRgb(h, s, l) {\n        s /= 100;\n        l /= 100;\n        const k = (n) => (n + h / 30) % 12;\n        const a = s * Math.min(l, 1 - l);\n        const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n        const r = Math.round(f(0) * 255);\n        const g = Math.round(f(8) * 255);\n        const b = Math.round(f(4) * 255);\n        return new rgb(r, g, b);\n    }\n    static randomColor2() {\n        const hue = Math.floor(Math.random() * 360);\n        const saturation = Math.floor(Math.random() * 30) + 15;\n        const lightness = Math.floor(Math.random() * 20) + 30;\n        return rgb.hslToRgb(hue, saturation, lightness);\n    }\n    static getHeatmapColor(value) {\n        value = Math.max(0, Math.min(1, value));\n        let g = Math.min(255, Math.max(0, Math.floor(255 * value * 2)));\n        let r = Math.min(255, Math.max(0, Math.floor(255 * (2 - value * 2))));\n        return new rgb(r / 1.5, g / 1.5, 0, 255);\n    }\n    static tryParseCssColor(color) {\n        let tempElem = document.body;\n        let lastColor = tempElem.style.color;\n        tempElem.style.color = color;\n        let computedColor = getComputedStyle(tempElem).color;\n        tempElem.style.color = lastColor;\n        return this.getRgbFromComputedStyle(computedColor);\n    }\n    static getRgbFromComputedStyle(style) {\n        let match = style.match(/^rgb(a?)\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)$/);\n        if (!match)\n            return undefined;\n        return new rgb(parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseFloat(match[5] ?? 1));\n    }\n    clone() {\n        return new rgb(this.r, this.g, this.b, this.a);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Color.ts?");

/***/ }),

/***/ "./src/Helpers/Commands.ts":
/*!*********************************!*\
  !*** ./src/Helpers/Commands.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandResult: () => (/* binding */ CommandResult),\n/* harmony export */   cli: () => (/* binding */ cli),\n/* harmony export */   cliPlugin: () => (/* binding */ cliPlugin)\n/* harmony export */ });\nclass CommandResult {\n    status;\n    message;\n    data;\n    constructor(status, message, data) {\n        this.status = status;\n        this.message = message;\n        this.data = data;\n    }\n}\nfunction cli(name, argsSyntax, returnType) {\n    return function (target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        if (originalMethod) {\n            name = name ?? propertyKey;\n            returnType = returnType ?? \"void\";\n            argsSyntax = argsSyntax ?? \"\";\n            if (argsSyntax)\n                argsSyntax = \" \" + argsSyntax;\n            if (returnType)\n                returnType = \": \" + returnType;\n            argsSyntax = name + argsSyntax + returnType;\n            const ctor = target.constructor;\n            if (!Object.prototype.hasOwnProperty.call(ctor, \"commands\")) {\n                ctor.commands = Object.assign({}, ctor.commands || {});\n            }\n            ctor.commands[name] = originalMethod;\n            if (!Object.prototype.hasOwnProperty.call(ctor, \"syntaxes\")) {\n                ctor.syntaxes = Object.assign({}, ctor.syntaxes || {});\n            }\n            console.log(\"Adding syntax:\", argsSyntax);\n            ctor.syntaxes[name] = argsSyntax;\n        }\n    };\n}\n// export function gameCommand(\n//     target: any, \n//     propertyKey: string, \n//     descriptor: TypedPropertyDescriptor<(...args: any[]) => CommandResult>,\n// ): void {\n//     // console.log(target);\n//     const originalMethod = descriptor.value;\n//     if (originalMethod) {\n//         const ctor = target.constructor;\n//         if (!Object.prototype.hasOwnProperty.call(ctor, \"commands\")) {\n//             ctor.commands = Object.assign({}, ctor.commands || {});\n//         }\n//         ctor.commands[propertyKey] = descriptor.value;\n//     }\n// }\nfunction cliPlugin(name) {\n    return function (target) {\n        target.prototype.cliGetName = function () { return name; };\n    };\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Commands.ts?");

/***/ }),

/***/ "./src/Helpers/Math.ts":
/*!*****************************!*\
  !*** ./src/Helpers/Math.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GMath: () => (/* binding */ GMath)\n/* harmony export */ });\nclass GMath {\n    static symRand(value) {\n        return (2 * Math.random() - 1) * value;\n    }\n    static getColliderRadius(n, radius) {\n        if (n >= 10)\n            return radius;\n        const angle = Math.PI / n;\n        const h = Math.cos(angle) * radius;\n        return (2 * h + radius) / 3;\n    }\n    static deltaAngle(a, b) {\n        a = a % (2 * Math.PI) + 2 * Math.PI;\n        a = a % (2 * Math.PI);\n        b = b % (2 * Math.PI) + 2 * Math.PI;\n        b = b % (2 * Math.PI) + 2 * Math.PI;\n        return (b - a + Math.PI) % (2 * Math.PI) - Math.PI;\n    }\n    static elasticCollision1D(m1, v1, m2, v2) {\n        const v1Final = ((v1 * (m1 - m2)) + (2 * m2 * v2)) / (m1 + m2);\n        const v2Final = ((v2 * (m2 - m1)) + (2 * m1 * v1)) / (m1 + m2);\n        return [v1Final, v2Final];\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Math.ts?");

/***/ }),

/***/ "./src/Helpers/Vector.ts":
/*!*******************************!*\
  !*** ./src/Helpers/Vector.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: () => (/* binding */ Vector)\n/* harmony export */ });\n/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dimforge/rapier2d */ \"./node_modules/@dimforge/rapier2d/rapier.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__]);\n_dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\nclass Vector extends _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_1__.Vector2 {\n    constructor(x, y) {\n        super(x, y);\n    }\n    //standard operators\n    add(a) {\n        return new Vector(this.x + a.x, this.y + a.y);\n    }\n    sub(a) {\n        return new Vector(this.x - a.x, this.y - a.y);\n    }\n    mul(a) {\n        return new Vector(this.x * a, this.y * a);\n    }\n    timesV(other) {\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n    //other operators \n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    distance(other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n    static distance(a, b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n    cross() {\n        return new Vector(this.y, -this.x).toUnit();\n    }\n    scalarProduct(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    vectorProduct(v) {\n        return this.x * v.y - this.y * v.x;\n    }\n    perpendicular(n) {\n        return this.sub(n.cross().mul((n.scalarProduct(this)) / (n.length() * n.length())));\n    }\n    toUnit() {\n        if (this.length() != 0)\n            return new Vector(this.x, this.y).mul(1 / this.length());\n        else\n            return new Vector(1, 0);\n    }\n    setLength(length) {\n        return this.toUnit().mul(length);\n    }\n    toString() {\n        return \"{\" + this.x + \":\" + this.y + \"}\";\n    }\n    toRad() {\n        return Math.atan2(this.y, this.x); // Kąt w radianach\n    }\n    reverse() {\n        let sx = 1e32;\n        let sy = 1e32;\n        if (this.x != 0)\n            sx = 1 / this.x;\n        if (this.y != 0)\n            sy = 1 / this.y;\n        return new Vector(sx, sy);\n    }\n    interpolate(target, k) {\n        const mx = target.sub(this);\n        const mv = mx.sub(mx.mul(Math.min(1, Math.max(0, k))));\n        return this.add(mv);\n    }\n    static fromRad(rad) {\n        return new Vector(Math.cos(rad), Math.sin(rad));\n    }\n    static fromVec2(vec) {\n        return new Vector(vec.x, vec.y);\n    }\n    static randomPos(range) {\n        return new Vector(_Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(range), _Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(range));\n    }\n    static randomPos2(range) {\n        let angle = _Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(Math.PI);\n        let distance = Math.random() * range;\n        return Vector.fromRad(angle).mul(distance);\n    }\n    clone() {\n        return new Vector(this.x, this.y);\n    }\n    //consts\n    static zero() { return new Vector(0, 0); }\n    static one() { return new Vector(1, 1); }\n    static up() { return new Vector(0, 1); }\n    static down() { return new Vector(0, -1); }\n    static left() { return new Vector(-1, 0); }\n    static right() { return new Vector(1, 0); }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Vector.ts?");

/***/ }),

/***/ "./src/Plugins/Camera.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Camera.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraPlugin: () => (/* binding */ CameraPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n/* harmony import */ var _Components_RigidBody__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Components/RigidBody */ \"./src/Components/RigidBody.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__, _Mouse__WEBPACK_IMPORTED_MODULE_2__, _Components_RigidBody__WEBPACK_IMPORTED_MODULE_5__]);\n([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__, _Mouse__WEBPACK_IMPORTED_MODULE_2__, _Components_RigidBody__WEBPACK_IMPORTED_MODULE_5__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar CameraPlugin_1;\n\n\n\n\n\n\nlet CameraPlugin = CameraPlugin_1 = class CameraPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    cameraPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(4, 0);\n    targetCameraPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(4, 0);\n    cameraScreenOffset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(100, 100);\n    followingSpeed = 0.02;\n    isFollowing = true;\n    scaleV = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(20, -20);\n    scale = 20;\n    targetId = \"None\"; //todo: delete this\n    targetScale = 40;\n    name = \"CameraPlugin\";\n    start() {\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseScrollYEvent.subscribe(this, \"scroll\");\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseDownEvent.subscribe(this, \"down\");\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseUpEvent.subscribe(this, \"up\");\n    }\n    event(args, alias) {\n        if (alias == \"scroll\") {\n            const mouseArgs = args;\n            this.zoom(mouseArgs.delta);\n        }\n        //todo: delete this\n        else if (alias == \"down\") {\n            const mouseArgs = args;\n            if (mouseArgs.button != 1)\n                return;\n            const target = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).getGameObject(this.targetId);\n            if (target) {\n                this.targetId = \"None\";\n                return;\n            }\n            const mousePositonScreen = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).getMouseScreenPosition();\n            const mousePositon = this.getWorldPosition(mousePositonScreen);\n            // let gameObject = this.getPlugin(CollisionDetectionPlugin).overlapPoint(mousePositon)[0]?.getGameObject();\n            // if (gameObject)\n            //     this.targetId = gameObject.getId();\n        }\n        // else if (alias == \"up\") {\n        //     const mouseArgs = args as MouseClickEventArgs;\n        //     if (mouseArgs.button != 1) \n        //         return;\n        //     this.target = undefined;\n        // }\n    }\n    zoom(delta) {\n        delta = Math.sign(delta);\n        if (delta > 0 && this.targetScale * 0.9 > 10)\n            this.targetScale = 0.9 * this.targetScale;\n        if (delta < 0 && this.targetScale * 1.1 < 100)\n            this.targetScale = 1.1 * this.targetScale;\n    }\n    getWorldPosition(screenPositon) {\n        let scale = this.getPlugin(CameraPlugin_1).scaleV;\n        let cameraPosition = this.getPlugin(CameraPlugin_1).cameraPosition;\n        let worldPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector((screenPositon.x - this.cameraScreenOffset.x) / scale.x, (screenPositon.y - this.cameraScreenOffset.y) / scale.y).add(cameraPosition);\n        return worldPosition;\n    }\n    update(delta) {\n        if (this.isFollowing)\n            this.cameraPosition = this.cameraPosition.interpolate(this.targetCameraPosition, Math.pow(this.followingSpeed, delta));\n        // this.scale += (this.targetScale-this.scale)*(2.5*delta);\n        this.scale += (this.targetScale - this.scale) * (1 - Math.pow(0.002, delta)); // (this.targetScale-this.scale)*(2.5*delta);\n        this.scaleV = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(this.scale, -this.scale);\n        //todo: delete this\n        const target = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).getGameObject(this.targetId);\n        if (target) {\n            const mousePositonScreen = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).getMouseScreenPosition();\n            const mousePositon = this.getWorldPosition(mousePositonScreen);\n            target.getComponent(_Components_RigidBody__WEBPACK_IMPORTED_MODULE_5__.RigidBodyC)?.setPosition(target.getComponent(_Components_RigidBody__WEBPACK_IMPORTED_MODULE_5__.RigidBodyC).getPosition().interpolate(mousePositon, Math.pow(0.001, delta)));\n            // if (this.getPlugin(KeyboardPlugin).isPressed(\"2\")){\n            //     target.getTransform().rotation += 0.5*3.14*delta;\n            // }\n            // if (this.getPlugin(KeyboardPlugin).isPressed(\"1\")){ \n            //     target.getTransform().rotation -= 0.5*3.14*delta;\n            // }\n        }\n    }\n    getscale() {\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, this.scaleV.toString(), this.scaleV);\n    }\n    follow(following) {\n        this.isFollowing = following;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, `Camera is ${following ? \"following\" : \"not following\"}`, undefined);\n    }\n    setzoom(zoom) {\n        this.targetScale = zoom;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, `Camera zoom set to ${zoom}`, undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"getscale\", undefined, \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"getscale\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"follow\", \"<following: boolean>\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Boolean]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"follow\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"zoom\", \"<zoom: number>\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"setzoom\", null);\nCameraPlugin = CameraPlugin_1 = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cliPlugin)(\"camera\")\n], CameraPlugin);\n\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Camera.ts?");

/***/ }),

/***/ "./src/Plugins/Cli.ts":
/*!****************************!*\
  !*** ./src/Plugins/Cli.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CliPlugin: () => (/* binding */ CliPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\nlet CliPlugin = class CliPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"CliPlugin\";\n    globalCommands = new Map();\n    echo(message) {\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, message);\n    }\n    loop(iters, command) {\n        let ret = [];\n        let message = \"\";\n        for (let i = 0; i < iters; i++) {\n            const result = this.parseAndExecuteCommands(command);\n            if (!result.status) {\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Error executing command: ${result.message}`, undefined);\n            }\n            ret.push(result.data);\n            message += `${result.message}\\n`;\n        }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, ret);\n    }\n    true() {\n        const message = \"This is a true command\";\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, true);\n    }\n    false() {\n        const message = \"This is a false command\";\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, false);\n    }\n    int(value) {\n        const message = `This is an int command with value ${value}`;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, parseInt(value));\n    }\n    float(value) {\n        const message = `This is a float command with value ${value}`;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, parseFloat(value));\n    }\n    refresh() {\n        const message = \"This is a refresh command\";\n        location.reload();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, undefined);\n    }\n    getrandomcolor() {\n        const randomColor = _Helpers_Color__WEBPACK_IMPORTED_MODULE_1__.rgb.randomColor2();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, `Random color is ${randomColor}`, randomColor);\n    }\n    help() {\n        let superResult = super.help();\n        let message = `plugins:\\n`;\n        for (const plugin of this.gameWorld?.getAllPlugins() ?? []) {\n            message += `/${plugin.cliGetName()}\\n`;\n        }\n        message = superResult.message + \"\\n\" + message;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, undefined);\n    }\n    art() {\n        const asciiArt = `\r\n        \\x1b[31m██████╗░░█████╗░██████╗░███████╗\r\n        \\x1b[32m██╔══██╗██╔══██╗██╔══██╗╚════██║\r\n        \\x1b[33m██║░░██║██║░░██║██████╔╝░░░░██╔╝\r\n        \\x1b[34m██║░░██║██║░░██║██╔═══╝░░░░██╔╝░\r\n        \\x1b[35m██████╔╝╚█████╔╝██║░░░░░░░██║░░░\r\n        \\x1b[36m╚═════╝░░╚════╝░╚═╝░░░░░░░╚═╝░░░\\x1b[0m\r\n        `;\n        const ansiArt = `\r\n\\x1b[38;5;160m         ██████         \\x1b[0m\r\n\\x1b[38;5;160m       ██████████       \\x1b[0m\r\n\\x1b[38;5;160m      ████    ████      \\x1b[0m\r\n\\x1b[38;5;82m    ████        ████    \\x1b[0m\r\n\\x1b[38;5;82m   ████          ████   \\x1b[0m\r\n\\x1b[38;5;82m  ████            ████  \\x1b[0m\r\n\\x1b[38;5;82m  ████    ████    ████  \\x1b[0m\r\n\\x1b[38;5;82m  ████████████████████  \\x1b[0m\r\n\\x1b[38;5;226m   ██████████████████   \\x1b[0m\r\n\\x1b[38;5;226m     ████████████████     \\x1b[0m\r\n\\x1b[38;5;226m      ████    ██████      \\x1b[0m\r\n\\x1b[38;5;196m      ████    ██████      \\x1b[0m\r\n\\x1b[38;5;196m     ██████████████████     \\x1b[0m\r\n\\x1b[38;5;196m    ████████████████████    \\x1b[0m\r\n\\x1b[38;5;196m   ██████████████████████   \\x1b[0m\r\n\\x1b[38;5;196m  ████████████████████████  \\x1b[0m\r\n\\x1b[38;5;160m      ██████████████      \\x1b[0m\r\n\\x1b[38;5;160m       ████████████       \\x1b[0m\r\n        `;\n        console.log(ansiArt);\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, ansiArt, undefined);\n    }\n    execute(command) {\n        try {\n            return this.parseAndExecuteCommands(command);\n        }\n        catch {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"Command execution failed\", undefined);\n        }\n    }\n    start() {\n        this.gameWorld?.getAllPlugins().forEach(plugin => {\n            const pluginName = plugin.constructor.name;\n            try {\n                for (let command of Object.keys(plugin.constructor[\"commands\"])) {\n                    if (this.globalCommands.has(command))\n                        this.globalCommands.set(command, undefined);\n                    else\n                        this.globalCommands.set(command, pluginName);\n                }\n            }\n            catch { }\n        });\n    }\n    ;\n    parseAndExecuteCommands(input, depth = 0) {\n        console.log((\"---\".repeat(depth)) + \"Parsing: \" + input);\n        const args = [];\n        let current = '';\n        let inSingleQuote = false;\n        let inDoubleQuote = false;\n        let parenDepth = 0;\n        input = input.trim();\n        for (let i = 0; i < input.length; i++) {\n            const char = input[i];\n            if (parenDepth > 0) {\n                if (char === \"{\") {\n                    parenDepth++;\n                    current += char;\n                    continue;\n                }\n                if (char === \"}\") {\n                    parenDepth--;\n                    if (parenDepth === 0) {\n                        const result = this.parseAndExecuteCommands(current, depth + 1);\n                        // console.log(\"   \".repeat(depth)+result.message);\n                        args.push(result.data);\n                        current = '';\n                    }\n                    else\n                        current += char;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (inDoubleQuote) {\n                if (char === \"\\\"\") {\n                    args.push(current);\n                    current = '';\n                    inDoubleQuote = false;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (inSingleQuote) {\n                if (char === \"'\") {\n                    args.push(current);\n                    current = '';\n                    inSingleQuote = false;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (char === \"\\\"\") {\n                inDoubleQuote = true;\n                continue;\n            }\n            if (char === \"'\") {\n                inSingleQuote = true;\n                continue;\n            }\n            if (char === \"{\") {\n                parenDepth++;\n                continue;\n            }\n            if (char === \" \") {\n                if (current.trim() !== \"\") {\n                    args.push(current);\n                    current = '';\n                }\n                continue;\n            }\n            current += char;\n        }\n        if (current.trim() !== \"\") {\n            args.push(current);\n        }\n        console.log(\"---\".repeat(depth) + \"Parsing result: \", args);\n        const fullCommand = args[0].split(':');\n        if (fullCommand.length === 2) {\n            const pluginName = fullCommand[0];\n            const plugin = this.gameWorld?.getAllPlugins().find(p => p.cliGetName() === pluginName);\n            if (!plugin)\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Plugin ${pluginName} not found`, undefined);\n            return this.executeParsedCommand(plugin, fullCommand[1], ...args.slice(1));\n        }\n        else if (fullCommand.length === 1) {\n            try {\n                if (!this.globalCommands.has(fullCommand[0]))\n                    return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Command ${fullCommand[0]} not found`, undefined);\n                const pluginName = this.globalCommands.get(fullCommand[0]);\n                if (!pluginName)\n                    return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `More than one command found, use \"/<plugin>:<command>\" (fe /cli:help) instead.`, undefined);\n                const plugin = this.gameWorld?.getPluginByName(pluginName);\n                return this.executeParsedCommand(plugin, fullCommand[0], ...args.slice(1));\n            }\n            catch {\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"Command not found or wrong syntax\", undefined);\n            }\n        }\n        else {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"No command found\", undefined);\n        }\n    }\n    executeParsedCommand(plugin, command, ...args) {\n        if (plugin.constructor[\"commands\"][command] === undefined) {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Command ${command} not found`, undefined);\n        }\n        try {\n            let commandToApply = plugin.constructor[\"commands\"][command];\n            let result = commandToApply.apply(plugin, args);\n            return result;\n        }\n        catch { }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Failed to execute command ${command} on ${plugin.cliGetName()}`, undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"echo\", \"<message: string>\", \"string\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"echo\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"loop\", \"<iterations: int> <command: string>\", \"string\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number, String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"loop\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"true\", undefined, \"bool\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"true\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"false\", undefined, \"bool\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"false\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"int\", \"<value: string>\", \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"int\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"float\", \"<value: string>\", \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"float\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"refresh\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"refresh\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"randomcolor\", undefined, \"rgb\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"getrandomcolor\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"help\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"help\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"art\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"art\", null);\nCliPlugin = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cliPlugin)(\"cli\")\n], CliPlugin);\n\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Cli.ts?");

/***/ }),

/***/ "./src/Plugins/Client.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Client.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientPlugin: () => (/* binding */ ClientPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass ClientPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ClientPlugin\";\n    socket;\n    start() {\n        // this.getPlugin(ChatPlugin)?.chatMessageEvent.subscribe(this, \"chatMessageEvent\");\n        // this.socket = io('http://localhost:3000', {});\n        // this.socket.on('connect', () => this.onConnection());\n        // this.socket.on('disconnect', (reason: string) => this.onDisconnection(reason));\n        // this.socket.on('chat_message', (message: string) => this.onChatMessage(message));\n    }\n    event(args, alias) {\n        let chatArgs = args;\n        this.sendChatMessage(chatArgs.message);\n    }\n    onConnection() {\n        console.log('Connected to server');\n    }\n    onDisconnection(reason) {\n        console.log(`Disconnected from server: ${reason}`);\n    }\n    onChatMessage(message) {\n        console.log(`Received chat message: ${message}`);\n        // this.getPlugin(ChatPlugin)?.sendChatMessage(message, false);\n    }\n    sendChatMessage(message) {\n        // this.socket.emit('chat_message', message);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Client.ts?");

/***/ }),

/***/ "./src/Plugins/CollisionDetection.ts":
/*!*******************************************!*\
  !*** ./src/Plugins/CollisionDetection.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionDetectionPlugin: () => (/* binding */ CollisionDetectionPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass CollisionDetectionPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"CollisionDetectionPlugin\";\n    cellSize = 5;\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/CollisionDetection.ts?");

/***/ }),

/***/ "./src/Plugins/Config.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Config.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigPlugin: () => (/* binding */ ConfigPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\n\nclass ConfigPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"ConfigPlugin\";\n    config = new Map([\n        [\"bulletSize\", 0.75],\n        // [\"displayColliders\", true as any],\n        [\"playerSize\", 2.5],\n        [\"bulletColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(56, 57, 60)],\n        // [\"playerColor\", new Color(145, 125, 39) as any],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(122, 111, 62)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(80, 37, 36)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(59, 94, 76)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(129, 49, 54)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(130, 111, 51)],\n    ]);\n    get(key) {\n        if (!this.config.has(key))\n            return undefined;\n        return this.config.get(key);\n    }\n    set(key, value) {\n        this.config.set(key, value);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Config.ts?");

/***/ }),

/***/ "./src/Plugins/GOManager.ts":
/*!**********************************!*\
  !*** ./src/Plugins/GOManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GOManagerPlugin: () => (/* binding */ GOManagerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass GOManagerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"GameObjects\";\n    gameObjects = new Map();\n    getGameObject(id) {\n        return this.gameObjects.get(id);\n    }\n    start() {\n        for (let gameObject of this.gameObjects.values())\n            gameObject.start();\n    }\n    //spawning\n    isSpawned(gameObject) {\n        return this.gameObjects.has(gameObject.id);\n    }\n    spawn(gameObject) {\n        this.gameObjects.set(gameObject.id, gameObject);\n        gameObject.manager = this;\n        gameObject.spawn();\n    }\n    destroy(gameObject) {\n        gameObject.destroy();\n        gameObject.manager = undefined;\n        this.gameObjects.delete(gameObject.id);\n    }\n    getComponents(classC) {\n        return Array.from(this.gameObjects.values().flatMap(go => go.getComponents(classC)));\n    }\n    getAllComponents() {\n        return Array.from(this.gameObjects.values().flatMap(go => go.getAllComponents()));\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/GOManager.ts?");

/***/ }),

/***/ "./src/Plugins/Hud/Console.ts":
/*!************************************!*\
  !*** ./src/Plugins/Hud/Console.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleEventArgs: () => (/* binding */ ConsoleEventArgs),\n/* harmony export */   ConsolePlugin: () => (/* binding */ ConsolePlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Cli__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Cli */ \"./src/Plugins/Cli.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var ansi_up__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ansi-up */ \"./node_modules/ansi-up/dist/ansi-up.js\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\n\n\nclass ConsoleEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    message;\n    constructor(message) {\n        super();\n        this.message = message;\n    }\n}\nlet ConsolePlugin = class ConsolePlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ConsolePlugin\";\n    isVisible = true;\n    consoleWrapper = document.createElement(\"div\");\n    buffer = \"\";\n    history = [\"\"];\n    historyIndex = 0;\n    constructor() {\n        super();\n        document.body.appendChild(this.consoleWrapper);\n        this.consoleWrapper.innerHTML = this.getInnerHtml();\n    }\n    start() {\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).KeyDownEvent.subscribe(this, \"keydown\");\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).BlockedKeyDownEvent.subscribe(this, \"keydown\");\n    }\n    event(args, alias) {\n        const key = args.key;\n        let input;\n        try {\n            input = this.consoleWrapper.querySelector(\".console-input\");\n        }\n        catch { }\n        if (!input)\n            return;\n        if (this.isFocused()) {\n            if (key == \"arrowup\") {\n                if (this.historyIndex < this.history.length - 1) {\n                    this.historyIndex++;\n                    input.value = this.history[this.historyIndex];\n                }\n            }\n            if (key == \"arrowdown\") {\n                if (this.historyIndex > 0) {\n                    this.historyIndex--;\n                    console.log(this.historyIndex);\n                    console.log(this.history);\n                    input.value = this.history[this.historyIndex];\n                }\n            }\n            if (key == \"escape\") {\n                input.blur();\n                input.value = \"\";\n            }\n            if (key == \"enter\") {\n                const value = input.value.trim();\n                if (value !== \"\") {\n                    input.value = \"\";\n                    console.log(\"Sending:\", value);\n                    this.messageEntered(value);\n                }\n                input.blur();\n            }\n        }\n        else {\n            if (key == \"enter\" && this.isVisible) {\n                input.focus();\n            }\n            if (key == \"t\") {\n                try {\n                    if (this.isVisible) {\n                        document.body.removeChild(this.consoleWrapper);\n                        input.blur();\n                    }\n                    else\n                        document.body.appendChild(this.consoleWrapper);\n                    this.isVisible = !this.isVisible;\n                }\n                catch (error) {\n                    console.log(\"Error: \", error);\n                }\n            }\n        }\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).block = this.isFocused();\n    }\n    isFocused() {\n        try {\n            const input = this.consoleWrapper.querySelector(\".console-input\");\n            if (input == null)\n                return false;\n            return document.activeElement === input;\n        }\n        catch {\n            return false;\n        }\n    }\n    writeLine(message) {\n        this.buffer += message + \"\\r\\n\";\n        this.setStatus(\"white\");\n        this.updateConsole();\n    }\n    messageEntered(message) {\n        // this.chatMessageEvent.emit(new ChatEventArgs(message));\n        if (message.startsWith(\"/\")) {\n            this.buffer += message + \"\\n\";\n            const result = this.getPlugin(_Cli__WEBPACK_IMPORTED_MODULE_3__.CliPlugin).execute(message.slice(1));\n            if (result.message != \"\")\n                this.buffer += result.message + \"\\r\\n\";\n            if (result.status)\n                this.setStatus(\"#485b49\");\n            else\n                this.setStatus(\"#813136\");\n        }\n        else {\n            this.buffer += message + \"\\r\\n\";\n            this.setStatus(\"white\");\n        }\n        this.history[0] = message;\n        this.history.unshift(\"\");\n        this.historyIndex = 0;\n        // this.buffer += \"<hr class='console-item-separator'/>\";\n        this.updateConsole();\n    }\n    setStatus(status) {\n        try {\n            const statusBar = this.consoleWrapper.querySelector(\".console-status\");\n            if (statusBar == null)\n                return;\n            statusBar.style.backgroundColor = status.toString();\n        }\n        catch { }\n    }\n    updateConsole() {\n        this.setElementsHtml(this.buffer);\n    }\n    setElementsHtml(buffer) {\n        try {\n            const content = this.consoleWrapper.querySelector(\".console-content\");\n            if (content == null)\n                return;\n            content.innerHTML = \"\";\n            const lines = buffer.split(\"\\n\");\n            for (let i = 0; i < lines.length - 1; i++) {\n                const line = lines[i];\n                const convert = new ansi_up__WEBPACK_IMPORTED_MODULE_5__.AnsiUp();\n                const html = convert.ansi_to_html(line);\n                let span = document.createElement(\"span\");\n                // span.textContent = line;\n                span.innerHTML = html;\n                content.appendChild(span);\n                const separator = document.createElement(\"hr\");\n                separator.className = \"console-item-separator\";\n                if (line.endsWith(\"\\r\"))\n                    content.appendChild(separator);\n                else\n                    content.appendChild(document.createElement(\"br\"));\n            }\n        }\n        catch { }\n    }\n    getInnerHtml() {\n        const profiler = `\r\n            <style>\r\n                .console{\r\n                    ${this.isVisible ? \"\" : \"display: none;\"}\r\n                    position: fixed;\r\n                    top: 20px;\r\n                    right: 20px;\r\n                    \r\n                    width: 400px;\r\n                    padding: 20px;\r\n                    border-radius: 20px;\r\n                    background-color: rgba(42, 43, 46, 0.382);\r\n                    color: white;\r\n                    font-family: \"IBM Plex Mono\", monospace;\r\n                    pointer-events: none;\r\n                    overflow: hidden;\r\n                }\r\n                .console-status{\r\n                    margin: 7px 0;\r\n                    height: 6px;\r\n                    background-color: white;\r\n                    opacity: 1;\r\n                    border-radius: 999px;\r\n                }\r\n                .console-header{\r\n                    font-size: 20px;\r\n                    font-weight: bold;\r\n                    height: 40px;\r\n                    color: white;\r\n                    margin-bottom: 10px;\r\n                    user-select: none;\r\n                }\r\n                .console-input{\r\n                    width: 100%; \r\n                    padding: 5px 0;\r\n                    margin: 0;\r\n                    border-radius: 0; \r\n                    border: none; \r\n                    border-bottom: 1px solid rgba(240, 240, 240, 0.5);\r\n                    background-color: transparent; \r\n                    color: white;\r\n                    font-size: 20px;   \r\n                }\r\n                .console *::selection {\r\n                    background-color: #546855;\r\n                    color: white;\r\n                }\r\n                .console-input:focus{\r\n                    outline: none; \r\n                    border-bottom: 1px solid rgba(240, 240, 240, 0.85);\r\n                }\r\n                .console-content-wrapper{\r\n                    position: relative;\r\n                    height: 600px;\r\n                    width: 100%;\r\n                    overflow: hidden;\r\n                }\r\n                .console-content{\r\n                    white-space: pre-wrap;\r\n                    word-wrap: break-word;\r\n                    position: absolute;\r\n                    width: 100%;\r\n                    line-height: 20px;\r\n                    font-size: 20px;\r\n                    margin: 0;\r\n                    bottom: 0;\r\n                }\r\n                .console-item-separator{\r\n                    border: none;\r\n                    border-top: 1px dashed gray;\r\n                    opacity: 0.75;\r\n                    margin: 9.5px 0;\r\n                }t\r\n            </style>\r\n\r\n            <div class=\"console\">\r\n                <div class=\"console-header\">\r\n                    <h2 style=\"margin: 0\">Console <span style=\"opacity: 0.5\">[T]</span></h2>\r\n                </div>\r\n                <div class=\"console-status\"></div>\r\n                <div class=\"console-content-wrapper\">\r\n                    <pre class=\"console-content\"></pre>\r\n                </div>\r\n                    <input class=\"console-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" type=\"text\" tabindex=\"-1\" placeholder=\"Type your command here...\" />\r\n            </div>\r\n            `;\n        // <div class=\"console-header\">\n        //         <h2 style=\"margin: 0\">Console <span style=\"opacity: 0.5\">[T]</span></h2>\n        //     </div>\n        return profiler;\n    }\n    clearConsole() {\n        this.buffer = \"\";\n        this.updateConsole();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.CommandResult(true, \"\", undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.cli)(\"clear\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.CommandResult)\n], ConsolePlugin.prototype, \"clearConsole\", null);\nConsolePlugin = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.cliPlugin)(\"console\"),\n    __metadata(\"design:paramtypes\", [])\n], ConsolePlugin);\n\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Hud/Console.ts?");

/***/ }),

/***/ "./src/Plugins/Hud/Profiler.ts":
/*!*************************************!*\
  !*** ./src/Plugins/Hud/Profiler.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProfilerPlugin: () => (/* binding */ ProfilerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Keyboard */ \"./src/Plugins/Keyboard.ts\");\n\n\nclass ProfilerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ProfilerPlugin\";\n    size = 250;\n    isVisible = true;\n    profilerWrapper = document.createElement(\"div\");\n    usage = new Map();\n    constructor() {\n        super();\n    }\n    start() {\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).KeyDownEvent.subscribe(this, \"keydown\");\n        document.body.appendChild(this.profilerWrapper);\n        this.addRecord(\"Fps\", 0);\n    }\n    lastTime = performance.now();\n    frames = 0;\n    fpsHistory = [];\n    update(delta) {\n        const fps = 1 / delta;\n        this.addRecord(\"Fps\", fps);\n        this.frames++;\n        const now = performance.now();\n        if (now - this.lastTime >= 250) {\n            this.fpsHistory.push(this.frames * 4);\n            if (this.fpsHistory.length > 100)\n                this.fpsHistory.shift();\n            this.frames = 0;\n            this.lastTime = now;\n        }\n        let i = 0;\n        let values = [];\n        for (const element of this.usage) {\n            let key = element[0];\n            let len = element[1].length;\n            let mean = 0;\n            for (const v of element[1])\n                mean += v;\n            mean /= len;\n            i++;\n            values.push(`${key}: ` + (mean).toFixed(2).toString());\n        }\n        this.profilerWrapper.innerHTML = this.getInnerHtml(values);\n    }\n    event(args, alias) {\n        if (alias == \"keydown\") {\n            const kargs = args;\n            if (kargs.key == \"p\")\n                this.isVisible = !this.isVisible;\n        }\n    }\n    addRecord(key, value) {\n        if (!this.usage.has(key)) {\n            this.usage.set(key, [value]);\n        }\n        else {\n            let usage = this.usage.get(key);\n            let len = usage.length;\n            if (len >= this.size) {\n                usage.shift();\n                usage.push(value);\n            }\n            else {\n                usage.push(value);\n            }\n        }\n    }\n    getChartHtml(values) {\n        values = values.slice(Math.max(0, values.length - 100), values.length);\n        const max = 200; //Math.max(...values);\n        let html = `<div class=\"profiler-chart\">`;\n        for (let i = 0; i < values.length; i++) {\n            html += `<div class=\"profiler-chart-item\" style=\"height: ${values[i] / max * 100}px\"></div>`;\n        }\n        html += `</div>`;\n        return html;\n    }\n    getElementsHtml(values) {\n        let html = \"\";\n        for (let i = 0; i < values.length; i++) {\n            if (i > 0)\n                html += `<hr class=\"profiler-item-separator\">`;\n            html +=\n                `<div class=\"profiler-item\">\r\n                <span class=\"profiler-item-key\">${values[i].split(\": \")[0]}:</span>\r\n                <span class=\"profiler-item-value\">${values[i].split(\": \")[1]}</span>\r\n            </div>`;\n        }\n        return html;\n    }\n    getInnerHtml(values) {\n        const profiler = `\r\n            <style>\r\n                .profiler{\r\n                    ${this.isVisible ? \"\" : \"display: none;\"}\r\n                    position: fixed;\r\n                    top: 20px;\r\n                    left: 20px;\r\n                    \r\n                    width: 400px;\r\n                    padding: 20px;\r\n                    border-radius: 20px;\r\n                    background-color: rgba(42, 43, 46, 0.382);\r\n                    color: white;\r\n                    pointer-events: none;\r\n                }\r\n                .profiler-header{\r\n                    font-size: 20px;\r\n                    font-weight: bold;\r\n                    color: white;\r\n                    margin-bottom: 10px;\r\n                }\r\n                .profiler-item{\r\n                    // display: flex;\r\n                    // justify-content: space-between;\r\n                    padding: 5px 0;\r\n                    color:rgba(240, 240, 240, 0.85)\r\n                }\r\n                .profiler-item-key{\r\n                    margin-right: 10px;\r\n                }\r\n                .profiler-item-value{\r\n                    color: #f0f0f0;\r\n                }\r\n                .profiler-item-separator{\r\n                    border: none;\r\n                    border-top: 1px dashed gray;\r\n                    opacity: 0.75;\r\n                    margin: 2px 0;\r\n                }\r\n                .profiler-chart{\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                    justify-content: space-between;\r\n                    align-items: flex-end;\r\n                    height: 100px;\r\n                    width: 100%;\r\n                    margin-bottom: 10px;\r\n                    border-radius: 10px;\r\n                    overflow: hidden;\r\n                    opacity: 0.25;\r\n                }\r\n                .profiler-chart-item{\r\n                    background-color: rgb(240, 240, 240);\r\n                    width: 100%;\r\n                    margin: 0;\r\n                }\r\n            </style>\r\n\r\n            <div class=\"profiler\">\r\n                <div class=\"profiler-header\">\r\n                    <h2 style=\"margin: 0\">Profiler <span style=\"opacity: 0.5\">[P]</span></h2>\r\n                </div>\r\n                ${this.getChartHtml(this.fpsHistory)}\r\n                ${this.getElementsHtml(values)}\r\n            </div>\r\n            `;\n        return profiler;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Hud/Profiler.ts?");

/***/ }),

/***/ "./src/Plugins/Keyboard.ts":
/*!*********************************!*\
  !*** ./src/Plugins/Keyboard.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardEventArgs: () => (/* binding */ KeyboardEventArgs),\n/* harmony export */   KeyboardPlugin: () => (/* binding */ KeyboardPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\n\nclass KeyboardEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.EventArgs {\n    key;\n    constructor(key) {\n        super();\n        this.key = key;\n    }\n}\nclass KeyboardPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"KeyboardPlugin\";\n    KeyDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.GameEvent();\n    BlockedKeyDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.GameEvent();\n    block = false;\n    NowPressedKeys = new Set();\n    pressedKeys = new Set();\n    constructor() {\n        super();\n        this.pressedKeys = new Set();\n        document.onkeydown = (event) => {\n            const key = event.key.toLowerCase();\n            this.pressedKeys.add(key);\n            this.NowPressedKeys.add(key);\n        };\n        document.onkeyup = (event) => {\n            const key = event.key.toLowerCase();\n            this.pressedKeys.delete(key);\n        };\n    }\n    isPressed(key) {\n        return this.enabled && !this.block && this.pressedKeys.has(key);\n    }\n    start() {\n        this.KeyDownEvent.register(this.gameWorld);\n        this.BlockedKeyDownEvent.register(this.gameWorld);\n    }\n    update(delta) {\n        this.NowPressedKeys.forEach(key => {\n            if (this.block)\n                this.BlockedKeyDownEvent.emit(new KeyboardEventArgs(key));\n            else\n                this.KeyDownEvent.emit(new KeyboardEventArgs(key));\n        });\n        this.NowPressedKeys.clear();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Keyboard.ts?");

/***/ }),

/***/ "./src/Plugins/Mouse.ts":
/*!******************************!*\
  !*** ./src/Plugins/Mouse.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MouseClickEventArgs: () => (/* binding */ MouseClickEventArgs),\n/* harmony export */   MousePlugin: () => (/* binding */ MousePlugin),\n/* harmony export */   MouseScrollEventArgs: () => (/* binding */ MouseScrollEventArgs)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__]);\n_Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\nclass MouseScrollEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    delta;\n    constructor(delta) {\n        super();\n        this.delta = delta;\n    }\n}\nclass MouseClickEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    button;\n    constructor(button) {\n        super();\n        this.button = button;\n    }\n}\nclass MousePlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"MousePlugin\";\n    mouseScrollYEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    mouseDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    mouseUpEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    pressedKeys = new Set();\n    canvas;\n    position = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector.zero();\n    constructor(canvas) {\n        super();\n        this.canvas = canvas;\n        this.trackMouse(canvas);\n    }\n    start() {\n        this.mouseScrollYEvent.register(this.gameWorld);\n        this.mouseDownEvent.register(this.gameWorld);\n        this.mouseUpEvent.register(this.gameWorld);\n    }\n    isKeyDown(key = 0) {\n        return this.pressedKeys.has(key);\n    }\n    getMouseScreenPosition() {\n        const scale = window.devicePixelRatio || 1;\n        // const canvasSize = new Vector(this.canvas.width, this.canvas.height);\n        let screenPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector((this.position.x * scale), (this.position.y * scale));\n        return screenPosition;\n    }\n    trackMouse(canvas) {\n        canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = canvas.getBoundingClientRect();\n            let x = event.clientX - rect.left;\n            let y = event.clientY - rect.top;\n            this.position = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y);\n        });\n        canvas.addEventListener(\"mousedown\", (event) => {\n            this.pressedKeys.add(event.button);\n            this.mouseDownEvent.emit(new MouseClickEventArgs(event.button));\n        });\n        canvas.addEventListener(\"mouseup\", (event) => {\n            this.pressedKeys.delete(event.button);\n            this.mouseUpEvent.emit(new MouseClickEventArgs(event.button));\n        });\n        canvas.addEventListener(\"wheel\", (event) => {\n            this.mouseScrollYEvent.emit(new MouseScrollEventArgs(event.deltaY));\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Mouse.ts?");

/***/ }),

/***/ "./src/Plugins/Physics.ts":
/*!********************************!*\
  !*** ./src/Plugins/Physics.ts ***!
  \********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPlugin: () => (/* binding */ PhysicsPlugin)\n/* harmony export */ });\n/* harmony import */ var _Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/RigidBody */ \"./src/Components/RigidBody.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dimforge/rapier2d */ \"./node_modules/@dimforge/rapier2d/rapier.js\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__, _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__]);\n([_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__, _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\nclass PhysicsPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"PhysicsPlugin\";\n    world = new _dimforge_rapier2d__WEBPACK_IMPORTED_MODULE_2__.World(new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(0, 0));\n    update(delta) {\n        const totalDelta = this.gameWorld.getWorldTime();\n        for (let body of this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_3__.GOManagerPlugin).getComponents(_Components_RigidBody__WEBPACK_IMPORTED_MODULE_0__.RigidBodyC))\n            body.update(delta);\n        this.world.step();\n    }\n    getWorld() {\n        return this.world;\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Physics.ts?");

/***/ }),

/***/ "./src/Plugins/Player.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Player.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerPlugin: () => (/* binding */ PlayerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GameObjectFactory */ \"./src/GameObjectFactory.ts\");\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__, _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__, _Mouse__WEBPACK_IMPORTED_MODULE_6__, _Camera__WEBPACK_IMPORTED_MODULE_9__]);\n([_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__, _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__, _Mouse__WEBPACK_IMPORTED_MODULE_6__, _Camera__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// import { CanonC } from \"../Components/Canon\";\n\n\n\n\n\n\n\n\n\n\n\nclass PlayerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_4__.Plugin {\n    name = \"PlayerPlugin\";\n    playerName = \"player\";\n    player = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__.GameObjectFactory.playerGO();\n    getPlayerPosition() {\n        return this.player.getBody().getPosition();\n    }\n    getPlayerColor() {\n        return this.player.getComponent(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__.PolygonRendererC).color.clone();\n    }\n    start() {\n        this.respawn();\n        this.player.getComponent(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__.PolygonRendererC).color = this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.get(\"playerColor\") ?? new _Helpers_Color__WEBPACK_IMPORTED_MODULE_2__.rgb(53, 110, 58);\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_5__.KeyboardPlugin)?.KeyDownEvent.subscribe(this, \"KeyDownEvent\");\n    }\n    event(args, alias) {\n        if (alias === \"KeyDownEvent\") {\n            let keyArgs = args;\n            if (keyArgs.key === \"r\") {\n                this.respawn();\n            }\n            else if (keyArgs.key === \"c\") {\n                let displayColliders = this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.get(\"displayColliders\") ?? false;\n                if (displayColliders !== undefined)\n                    this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.set(\"displayColliders\", !displayColliders);\n            }\n        }\n    }\n    // color: rgb = new rgb(53, 110, 58);\n    // target: rgb = new rgb(53, 110, 58);\n    update(delta) {\n        const body = this.player.getBody();\n        const camera = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_9__.CameraPlugin);\n        const mouse = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_6__.MousePlugin);\n        const keyboard = this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_5__.KeyboardPlugin);\n        const ra = -25;\n        const a = keyboard.isPressed(\"shift\") ? 120 : 60;\n        const vmax = 50.0;\n        const rotation = body.getRotation();\n        const direction = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__.Vector.fromRad(rotation);\n        const turnSpeed = 2.5;\n        //   const gun = this.player.getComponent(CanonC);\n        // if (Math.random() < 0.05){\n        //   this.target=rgb.randomColor2();\n        //   // this.getPlugin(CliPlugin)?.execute(\"player:setcolor {randomcolor}\");\n        // }\n        // this.color = this.color.blend(this.target, 0.02);\n        // this.player.getComponent(PolygonRendererC).color = this.color;\n        camera.targetCameraPosition = body.getPosition();\n        if (!this.player.enabled)\n            return;\n        //   if (!gun) return;\n        //   gun.targetDirection = camera.getWorldPosition(mouse.getMouseScreenPosition()).sub(this.player.getTransform().position);\n        //   gun.range = camera.getWorldPosition(mouse.getMouseScreenPosition()).sub(this.player.getTransform().position.add(gun.getGlobalOffset())).magnitude();\n        //   if (keyboard.isPressed(\"e\")||mouse.isKeyDown(0)) \n        //     gun.shoot();\n        let velocity = body.getVelocity();\n        // Przyspieszanie\n        if (keyboard.isPressed(\"w\")) {\n            body.setForce(direction.toUnit().mul(a));\n            if (keyboard.isPressed(\"s\"))\n                body.setForce(direction.toUnit().mul(-ra));\n        }\n        else if (keyboard.isPressed(\"s\"))\n            body.setForce(direction.toUnit().mul(ra));\n        else\n            body.setForce(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__.Vector.zero());\n        velocity = velocity.sub(velocity.perpendicular(direction));\n        if (velocity.length() > vmax)\n            velocity.setLength(vmax);\n        if (keyboard.isPressed(\"a\"))\n            body.setAngularVelocity(turnSpeed);\n        else if (keyboard.isPressed(\"d\"))\n            body.setAngularVelocity(-turnSpeed);\n        else\n            body.setAngularVelocity(0);\n    }\n    cliGetName() {\n        return \"player\";\n    }\n    //   @cli(\"setname\", \"<name: string>\")\n    //   private setname(newName: string): CommandResult {\n    //       this.playerName = newName;\n    //       this.player.name = newName;\n    //       return new CommandResult(true, `Player name set to ${newName}`, undefined);\n    //   }\n    //   @cli(\"setcolor\", \"<color: string | rgb>\")\n    //   private setcolor(color: string | rgb): CommandResult {\n    //       try{\n    //         let newColor = rgb.tryParseCssColor(color.toString());\n    //         if (newColor)\n    //           this.player.getComponent(PolygonRendererC).color = newColor;\n    //       } catch {}\n    //       return new CommandResult(true, `Player color set`, undefined);\n    //   }\n    respawn() {\n        const gom = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_10__.GOManagerPlugin);\n        if (this.player && gom.isSpawned(this.player))\n            gom.destroy(this.player);\n        this.player = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__.GameObjectFactory.playerGO();\n        this.player.name = this.playerName;\n        gom.spawn(this.player);\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.CommandResult(true, `Player respawned`, undefined);\n    }\n}\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.cli)(\"respawn\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.CommandResult)\n], PlayerPlugin.prototype, \"respawn\", null);\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Player.ts?");

/***/ }),

/***/ "./src/Plugins/Renderer.ts":
/*!*********************************!*\
  !*** ./src/Plugins/Renderer.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RendererPlugin: () => (/* binding */ RendererPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n/* harmony import */ var _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Components/Renderers/TextRenderer */ \"./src/Components/Renderers/TextRenderer.ts\");\n/* harmony import */ var _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Components/Renderers/BarRenderer */ \"./src/Components/Renderers/BarRenderer.ts\");\n/* harmony import */ var _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Components/Renderers/ChasisRenderer */ \"./src/Components/Renderers/ChasisRenderer.ts\");\n/* harmony import */ var _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../Components/Renderers/ColliderRenderer */ \"./src/Components/Renderers/ColliderRenderer.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Camera__WEBPACK_IMPORTED_MODULE_2__, _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__, _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__, _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__, _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__, _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_9__]);\n([_Camera__WEBPACK_IMPORTED_MODULE_2__, _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__, _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__, _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__, _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__, _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_9__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n// import { ImageRendererC } from \"../Components/Renderers/ImageRenderer\";\n\n// import { CanonRendererC } from \"../Components/Renderers/CanonRenderer\";\n\n\n\n\n\n\n// import { TracesRendererC } from \"../Components/Renderers/TracesRenderer\";\nclass RendererPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"RendererPlugin\";\n    context;\n    renderDistance = 150;\n    constructor(context) {\n        super();\n        this.context = context;\n    }\n    addVignetteEffect(context, color) {\n        const centerX = context.canvas.width / 2;\n        const centerY = context.canvas.height / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);\n        const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);\n        gradient.addColorStop(0.025, 'rgba(0, 0, 0, 0)');\n        gradient.addColorStop(1, color);\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    }\n    gridCanvas = [];\n    start() {\n        ////\n        this.context.imageSmoothingEnabled = true;\n        this.context.strokeStyle = \"rgb(43,43,44)\";\n        this.context.lineWidth = 0.175;\n        this.context.lineJoin = \"round\";\n        this.context.shadowColor = 'rgba(0, 0, 0, 0.75)';\n        this.context.fillStyle = \"#716f6b\";\n        this.context.fillStyle = \"rgb(85, 106, 86)\";\n        this.context.fillStyle = \"rgb(66, 85, 68)\";\n        ////\n        let worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"src_Components_Renderers_BackgroundRenderer_ts\"), __webpack_require__.b), { type: \"module\" }); //this.drawDotGrid(ctx, new Vector(2.5, 2.5), 0.175, rgb.stroke.toString(), new Vector(i*4+5, i*4+5));\n        for (let i = 0; i < 10; i++) {\n            this.gridCanvas[i] = document.createElement(\"canvas\");\n            this.gridCanvas[i].width = 3440;\n            this.gridCanvas[i].height = 1440;\n            document.createElement(\"canvas\");\n            const offscreen = this.gridCanvas[i].transferControlToOffscreen();\n            worker.postMessage({ canvas: offscreen, args: [new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(2, 2), 0.175, _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.stroke.toString(), new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(i * 5 + 5, i * 5 + 5)] }, [offscreen]);\n        }\n    }\n    clip(position) {\n        const width = this.context.canvas.width;\n        const height = this.context.canvas.height;\n        const scale = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).scaleV;\n        const cameraPositon = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraPosition;\n        const xClip = Math.abs(width / 2 / scale.x);\n        const yClip = Math.abs(height / 2 / scale.y);\n        return Math.abs(position.x - cameraPositon.x) > xClip || Math.abs(position.y - cameraPositon.y) > yClip;\n    }\n    update(delta) {\n        const width = this.context.canvas.width;\n        const height = this.context.canvas.height;\n        // this.context.fillStyle =\"rgb(66, 85, 68)\";\n        // this.context.fillStyle =\"rgb(105, 111, 105)\";\n        this.context.fillStyle = \"rgba(80, 100, 81, 1)\";\n        this.context.fillRect(0, 0, width, height);\n        this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraScreenOffset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(this.context.canvas.width / 2, this.context.canvas.height / 2);\n        // let gx = Math.sqrt(3);\n        // let gy = 3;\n        let gx = 2;\n        let gy = 2;\n        const offset = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraScreenOffset;\n        const scale = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).scaleV;\n        const cpos = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraPosition;\n        let i = Math.max(0, Math.min(9, Math.round(scale.x / 10)));\n        let c = i * 5 + 5;\n        this.context.translate(offset.x, offset.y);\n        this.context.scale(scale.x, scale.y);\n        this.context.translate((-cpos.x) % gx, (-cpos.y) % gy);\n        this.context.scale(1 / c, 1 / c);\n        this.context.drawImage(this.gridCanvas[i], -this.gridCanvas[i].width / 2, -this.gridCanvas[i].height / 2, this.gridCanvas[i].width, this.gridCanvas[i].height);\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__.TextRendererC)\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_9__.ColliderRendererC))\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__.PolygonRendererC))\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__.BarRendererC))\n            // .concat(this.app.getComponents(ImageRendererC)as RendererC[])\n            .filter(renderer => !this.clip(renderer.gameObject.getBody().getPosition()))\n            // .concat(this.app.getComponents(CanonRendererC)as RendererC[])\n            // .concat(this.app.getComponents(TracesRendererC)as RendererC[])\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__.ChasisRendererC))\n            .filter(renderer => !this.clip(renderer.gameObject.getBody().getPosition()))\n            .sort((a, b) => a.zindex - b.zindex).forEach(renderer => renderer.render(this.context));\n        // this.gameWorld.getAllComponents<RendererC>(RendererC.name).forEach(renderer => renderer.render(this.context));\n        this.addVignetteEffect(this.context, 'rgba(0, 0, 0, 0.35)');\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Renderer.ts?");

/***/ }),

/***/ "./src/Plugins/Scheduler.ts":
/*!**********************************!*\
  !*** ./src/Plugins/Scheduler.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SchedulerPlugin: () => (/* binding */ SchedulerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass SchedulerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"SchedulerPlugin\";\n    schedule = [];\n    addInvoke(subscriber, totalTime, topic) {\n        let sub = new WeakRef(subscriber);\n        this.schedule.push({ totalTime, subscriber: sub, topic });\n        this.schedule.sort((a, b) => b.totalTime - a.totalTime);\n    }\n    update(delta) {\n        const totalDelta = this.gameWorld.getWorldTime();\n        if (this.schedule.length != 0)\n            while (this.schedule.length != 0 && this.schedule[this.schedule.length - 1].totalTime <= totalDelta) {\n                let last = this.schedule.pop();\n                last.subscriber.deref()?.onInvoke(last.topic);\n            }\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Scheduler.ts?");

/***/ }),

/***/ "./src/Plugins/StandaloneComponent.ts":
/*!********************************************!*\
  !*** ./src/Plugins/StandaloneComponent.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandaloneComponentPlugin: () => (/* binding */ StandaloneComponentPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass StandaloneComponentPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"StandaloneComponentPlugin\";\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/StandaloneComponent.ts?");

/***/ }),

/***/ "./src/Worlds/MyWorld.ts":
/*!*******************************!*\
  !*** ./src/Worlds/MyWorld.ts ***!
  \*******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyWorld: () => (/* binding */ MyWorld)\n/* harmony export */ });\n/* harmony import */ var _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GameObjectFactory */ \"./src/GameObjectFactory.ts\");\n/* harmony import */ var _Core_GameWorld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/GameWorld */ \"./src/Core/GameWorld.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Plugins/GOManager */ \"./src/Plugins/GOManager.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__]);\n([_GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__, _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n// import { RigidBodyC } from \"../Components/RigidBody\";\n\n\n\n// import { CanonC } from \"../Components/Canon\";\n// import { NpcC } from \"../Components/Npc\";\n\n\n// import { CanonRendererC } from \"../Components/Renderers/CanonRenderer\";\nclass MyWorld extends _Core_GameWorld__WEBPACK_IMPORTED_MODULE_1__.GameWorld {\n    Start() {\n        console.log(\"Hello, MyWorld!\");\n        const r = 350;\n        for (let i = 0; i < 550; i++) {\n            const radius = 3 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let sqr = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, 4);\n            sqr.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            sqr.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(sqr);\n        }\n        for (let i = 0; i < 250; i++) {\n            const radius = 3.5 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let triangle = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, 3);\n            triangle.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            triangle.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(triangle);\n        }\n        for (let i = 0; i < 350; i++) {\n            const radius = 4 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let polygon = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, Math.round(Math.random() * 3) + 5);\n            polygon.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            polygon.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(polygon);\n        }\n        // for(let i = 0; i < 225; i++){\n        //     const radius = 3+GMath.symRand(0.25);\n        //     let polygon = GameObjectFactory.polygonGO(\n        //         radius/2, \n        //         Math.round(Math.random()*3)+5,\n        //         new ImageRendererC(Vector.zero(), undefined, undefined, 12)\n        //     );\n        //     polygon.getTransform().position = new Vector(Math.random()*2*r-r, Math.random()*2*r-r);\n        //     polygon.getComponent(RigidBodyC).angularVelocity = Math.random()*2-1;\n        //     polygon.getComponent(PolygonRendererC).enable(false);\n        //     this.spawn(polygon);\n        // }\n        // for(let i = 0; i < 25; i++){\n        //     let follower = GameObjectFactory.enemyGO(2.5, \"Enemy nr.\"+i, 4,\n        //         new CanonC(undefined, undefined, 10+Math.random()*5),\n        //         new CanonRendererC(4-0.1),\n        //         new NpcC()\n        //     );\n        //     follower.getTransform().position = Vector.randomPos(r);\n        //     follower.spawn(this);\n        // }\n    }\n    Update(delta) {\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/Worlds/MyWorld.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   main: () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Worlds/MyWorld */ \"./src/Worlds/MyWorld.ts\");\n/* harmony import */ var _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Plugins/Renderer */ \"./src/Plugins/Renderer.ts\");\n/* harmony import */ var _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Plugins/Physics */ \"./src/Plugins/Physics.ts\");\n/* harmony import */ var _Plugins_Keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Plugins/Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Plugins/Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Plugins/Player */ \"./src/Plugins/Player.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Plugins_Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Plugins/Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Plugins_CollisionDetection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Plugins/CollisionDetection */ \"./src/Plugins/CollisionDetection.ts\");\n/* harmony import */ var _Plugins_StandaloneComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Plugins/StandaloneComponent */ \"./src/Plugins/StandaloneComponent.ts\");\n/* harmony import */ var _Plugins_Scheduler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Plugins/Scheduler */ \"./src/Plugins/Scheduler.ts\");\n/* harmony import */ var _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Plugins/Hud/Profiler */ \"./src/Plugins/Hud/Profiler.ts\");\n/* harmony import */ var _Plugins_Client__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Plugins/Client */ \"./src/Plugins/Client.ts\");\n/* harmony import */ var _Plugins_Cli__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Plugins/Cli */ \"./src/Plugins/Cli.ts\");\n/* harmony import */ var _Plugins_Hud_Console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Plugins/Hud/Console */ \"./src/Plugins/Hud/Console.ts\");\n/* harmony import */ var _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Plugins/GOManager */ \"./src/Plugins/GOManager.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__, _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__, _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__, _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__]);\n([_Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__, _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__, _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__, _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__, _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__, _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__] = __webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function main(canvas) {\n    const world = new _Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__.MyWorld(new _Plugins_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin(), new _Plugins_Client__WEBPACK_IMPORTED_MODULE_12__.ClientPlugin(), new _Plugins_Cli__WEBPACK_IMPORTED_MODULE_13__.CliPlugin(), new _Plugins_Keyboard__WEBPACK_IMPORTED_MODULE_3__.KeyboardPlugin(), new _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__.MousePlugin(canvas), new _Plugins_Scheduler__WEBPACK_IMPORTED_MODULE_10__.SchedulerPlugin(), new _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_15__.GOManagerPlugin(), new _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__.PlayerPlugin(), new _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsPlugin(), new _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__.CameraPlugin(), new _Plugins_Hud_Console__WEBPACK_IMPORTED_MODULE_14__.ConsolePlugin(), new _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_11__.ProfilerPlugin(), new _Plugins_CollisionDetection__WEBPACK_IMPORTED_MODULE_8__.CollisionDetectionPlugin(), new _Plugins_StandaloneComponent__WEBPACK_IMPORTED_MODULE_9__.StandaloneComponentPlugin(), new _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__.RendererPlugin(canvas.getContext(\"2d\")));\n    console.log(world.getAllPlugins());\n    function tick() {\n        world.tick();\n        requestAnimationFrame(tick);\n    }\n    tick();\n}\nmain(document.getElementById(\"gameCanvas\"));\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });\n\n//# sourceURL=webpack://gameengine/./src/index.ts?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		id: moduleId,
/******/ 		loaded: false,
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Flag the module as loaded
/******/ 	module.loaded = true;
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/async module */
/******/ (() => {
/******/ 	var webpackQueues = typeof Symbol === "function" ? Symbol("webpack queues") : "__webpack_queues__";
/******/ 	var webpackExports = typeof Symbol === "function" ? Symbol("webpack exports") : "__webpack_exports__";
/******/ 	var webpackError = typeof Symbol === "function" ? Symbol("webpack error") : "__webpack_error__";
/******/ 	var resolveQueue = (queue) => {
/******/ 		if(queue && queue.d < 1) {
/******/ 			queue.d = 1;
/******/ 			queue.forEach((fn) => (fn.r--));
/******/ 			queue.forEach((fn) => (fn.r-- ? fn.r++ : fn()));
/******/ 		}
/******/ 	}
/******/ 	var wrapDeps = (deps) => (deps.map((dep) => {
/******/ 		if(dep !== null && typeof dep === "object") {
/******/ 			if(dep[webpackQueues]) return dep;
/******/ 			if(dep.then) {
/******/ 				var queue = [];
/******/ 				queue.d = 0;
/******/ 				dep.then((r) => {
/******/ 					obj[webpackExports] = r;
/******/ 					resolveQueue(queue);
/******/ 				}, (e) => {
/******/ 					obj[webpackError] = e;
/******/ 					resolveQueue(queue);
/******/ 				});
/******/ 				var obj = {};
/******/ 				obj[webpackQueues] = (fn) => (fn(queue));
/******/ 				return obj;
/******/ 			}
/******/ 		}
/******/ 		var ret = {};
/******/ 		ret[webpackQueues] = x => {};
/******/ 		ret[webpackExports] = dep;
/******/ 		return ret;
/******/ 	}));
/******/ 	__webpack_require__.a = (module, body, hasAwait) => {
/******/ 		var queue;
/******/ 		hasAwait && ((queue = []).d = -1);
/******/ 		var depQueues = new Set();
/******/ 		var exports = module.exports;
/******/ 		var currentDeps;
/******/ 		var outerResolve;
/******/ 		var reject;
/******/ 		var promise = new Promise((resolve, rej) => {
/******/ 			reject = rej;
/******/ 			outerResolve = resolve;
/******/ 		});
/******/ 		promise[webpackExports] = exports;
/******/ 		promise[webpackQueues] = (fn) => (queue && fn(queue), depQueues.forEach(fn), promise["catch"](x => {}));
/******/ 		module.exports = promise;
/******/ 		body((deps) => {
/******/ 			currentDeps = wrapDeps(deps);
/******/ 			var fn;
/******/ 			var getResult = () => (currentDeps.map((d) => {
/******/ 				if(d[webpackError]) throw d[webpackError];
/******/ 				return d[webpackExports];
/******/ 			}))
/******/ 			var promise = new Promise((resolve) => {
/******/ 				fn = () => (resolve(getResult));
/******/ 				fn.r = 0;
/******/ 				var fnQueue = (q) => (q !== queue && !depQueues.has(q) && (depQueues.add(q), q && !q.d && (fn.r++, q.push(fn))));
/******/ 				currentDeps.map((dep) => (dep[webpackQueues](fnQueue)));
/******/ 			});
/******/ 			return fn.r ? promise : getResult();
/******/ 		}, (err) => ((err ? reject(promise[webpackError] = err) : outerResolve(exports)), resolveQueue(queue)));
/******/ 		queue && queue.d < 0 && (queue.d = 0);
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".bundle.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/harmony module decorator */
/******/ (() => {
/******/ 	__webpack_require__.hmd = (module) => {
/******/ 		module = Object.create(module);
/******/ 		if (!module.children) module.children = [];
/******/ 		Object.defineProperty(module, 'exports', {
/******/ 			enumerable: true,
/******/ 			set: () => {
/******/ 				throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 			}
/******/ 		});
/******/ 		return module;
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/wasm loading */
/******/ (() => {
/******/ 	__webpack_require__.v = (exports, wasmModuleId, wasmModuleHash, importsObj) => {
/******/ 	
/******/ 		var req = fetch(__webpack_require__.p + "" + wasmModuleHash + ".module.wasm");
/******/ 		var fallback = () => (req
/******/ 			.then((x) => (x.arrayBuffer()))
/******/ 			.then((bytes) => (WebAssembly.instantiate(bytes, importsObj)))
/******/ 			.then((res) => (Object.assign(exports, res.instance.exports))));
/******/ 		return req.then((res) => {
/******/ 			if (typeof WebAssembly.instantiateStreaming === "function") {
/******/ 	
/******/ 				return WebAssembly.instantiateStreaming(res, importsObj)
/******/ 					.then(
/******/ 						(res) => (Object.assign(exports, res.instance.exports)),
/******/ 						(e) => {
/******/ 							if(res.headers.get("Content-Type") !== "application/wasm") {
/******/ 								console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);
/******/ 								return fallback();
/******/ 							}
/******/ 							throw e;
/******/ 						}
/******/ 					);
/******/ 			}
/******/ 			return fallback();
/******/ 		});
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (typeof import.meta.url === "string") scriptUrl = import.meta.url
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	__webpack_require__.b = new URL("./", import.meta.url);
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/ 	
/******/ 	// no install chunk
/******/ 	
/******/ 	// no chunk on demand loading
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 
