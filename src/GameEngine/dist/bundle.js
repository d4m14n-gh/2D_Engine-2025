/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ var __webpack_modules__ = ({

/***/ "./node_modules/ansi-up/dist/ansi-up.js":
/*!**********************************************!*\
  !*** ./node_modules/ansi-up/dist/ansi-up.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AnsiUp: () => (/* binding */ AnsiUp)\n/* harmony export */ });\nvar AnsiUp = (function () {\n    function AnsiUp() {\n        this.ansi_colors = [\n            // Normal colors\n            [\n                { rgb: [0, 0, 0], class_name: \"ansi-black\" },\n                { rgb: [187, 0, 0], class_name: \"ansi-red\" },\n                { rgb: [0, 187, 0], class_name: \"ansi-green\" },\n                { rgb: [187, 187, 0], class_name: \"ansi-yellow\" },\n                { rgb: [0, 0, 187], class_name: \"ansi-blue\" },\n                { rgb: [187, 0, 187], class_name: \"ansi-magenta\" },\n                { rgb: [0, 187, 187], class_name: \"ansi-cyan\" },\n                { rgb: [255, 255, 255], class_name: \"ansi-white\" }\n            ],\n            // Bright colors\n            [\n                { rgb: [85, 85, 85], class_name: \"ansi-bright-black\" },\n                { rgb: [255, 85, 85], class_name: \"ansi-bright-red\" },\n                { rgb: [0, 255, 0], class_name: \"ansi-bright-green\" },\n                { rgb: [255, 255, 85], class_name: \"ansi-bright-yellow\" },\n                { rgb: [85, 85, 255], class_name: \"ansi-bright-blue\" },\n                { rgb: [255, 85, 255], class_name: \"ansi-bright-magenta\" },\n                { rgb: [85, 255, 255], class_name: \"ansi-bright-cyan\" },\n                { rgb: [255, 255, 255], class_name: \"ansi-bright-white\" }\n            ]\n        ];\n        this.setup_256_palette();\n        this.useClasses = false;\n        this.escapeForHtml = true;\n        this.bright = false;\n        this.fg = this.bg = null;\n        this._buffer = '';\n    }\n    Object.defineProperty(AnsiUp.prototype, \"useClasses\", {\n        get: function () {\n            return this._useClasses;\n        },\n        set: function (useClasses) {\n            this._useClasses = useClasses;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(AnsiUp.prototype, \"escapeForHtml\", {\n        get: function () {\n            return this._escapeForHtml;\n        },\n        set: function (arg) {\n            this._escapeForHtml = arg;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    AnsiUp.prototype.setup_256_palette = function () {\n        var _this = this;\n        this.palette_256 = [];\n        // Index 0..15 : Ansi-Colors\n        this.ansi_colors.forEach(function (palette) {\n            palette.forEach(function (rec) {\n                _this.palette_256.push(rec);\n            });\n        });\n        // Index 16..231 : RGB 6x6x6\n        // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n        var levels = [0, 95, 135, 175, 215, 255];\n        for (var r = 0; r < 6; ++r) {\n            for (var g = 0; g < 6; ++g) {\n                for (var b = 0; b < 6; ++b) {\n                    var c = { rgb: [levels[r], levels[g], levels[b]], class_name: 'truecolor' };\n                    this.palette_256.push(c);\n                }\n            }\n        }\n        // Index 232..255 : Grayscale\n        var grey_level = 8;\n        for (var i = 0; i < 24; ++i, grey_level += 10) {\n            var c = { rgb: [grey_level, grey_level, grey_level], class_name: 'truecolor' };\n            this.palette_256.push(c);\n        }\n    };\n    AnsiUp.prototype.doEscape = function (txt) {\n        return txt.replace(/[&<>]/gm, function (str) {\n            if (str === \"&\")\n                return \"&amp;\";\n            if (str === \"<\")\n                return \"&lt;\";\n            if (str === \">\")\n                return \"&gt;\";\n        });\n    };\n    AnsiUp.prototype.old_linkify = function (txt) {\n        return txt.replace(/(https?:\\/\\/[^\\s]+)/gm, function (str) {\n            return \"<a href=\\\"\" + str + \"\\\">\" + str + \"</a>\";\n        });\n    };\n    AnsiUp.prototype.detect_incomplete_ansi = function (txt) {\n        return !(/.*?[\\x40-\\x7e]/.test(txt));\n    };\n    AnsiUp.prototype.detect_incomplete_link = function (txt) {\n        var found = false;\n        for (var i = txt.length - 1; i > 0; i--) {\n            if (/\\s|\\x1B/.test(txt[i])) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            // Handle one other case\n            // Maybe the whole string is a URL?\n            if (/(https?:\\/\\/[^\\s]+)/.test(txt)) {\n                return 0;\n            }\n            else\n                return -1;\n        }\n        // Test if possible prefix\n        var prefix = txt.substr(i + 1, 4);\n        if (prefix.length === 0)\n            return -1;\n        if (\"http\".indexOf(prefix) === 0) {\n            return (i + 1);\n        }\n    };\n    AnsiUp.prototype.ansi_to_html = function (txt) {\n        var _this = this;\n        var pkt = this._buffer + txt;\n        this._buffer = '';\n        var raw_text_pkts = pkt.split(/\\x1B\\[/);\n        if (raw_text_pkts.length === 1)\n            raw_text_pkts.push('');\n        // COMPLEX - BEGIN\n        // Validate the last chunks for:\n        // - incomplete ANSI sequence\n        // - incomplete ESC\n        // If any of these occur, we may have to buffer\n        var last_pkt = raw_text_pkts[raw_text_pkts.length - 1];\n        // - incomplete ANSI sequence\n        if ((last_pkt.length > 0) && this.detect_incomplete_ansi(last_pkt)) {\n            this._buffer = '\\x1B\\[' + last_pkt;\n            raw_text_pkts.pop();\n            raw_text_pkts.push('');\n        }\n        else {\n            // - incomplete ESC\n            if (last_pkt.slice(-1) === '\\x1B') {\n                this._buffer = '\\x1B';\n                console.log(\"raw\", raw_text_pkts);\n                raw_text_pkts.pop();\n                raw_text_pkts.push(last_pkt.substr(0, last_pkt.length - 1));\n                console.log(raw_text_pkts);\n                console.log(last_pkt);\n            }\n            // - Incomplete ESC, only one packet\n            if (raw_text_pkts.length === 2 && (raw_text_pkts[1] == '') && (raw_text_pkts[0].slice(-1) == \"\\x1B\")) {\n                this._buffer = \"\\x1B\";\n                last_pkt = raw_text_pkts.shift();\n                raw_text_pkts.unshift(last_pkt.substr(0, last_pkt.length - 1));\n            }\n        }\n        // COMPLEX - END\n        var first_txt = this.wrap_text(raw_text_pkts.shift()); // the first pkt is not the result of the split\n        var blocks = raw_text_pkts.map(function (block) { return _this.wrap_text(_this.process_ansi(block)); });\n        if (first_txt.length > 0)\n            blocks.unshift(first_txt);\n        return blocks.join('');\n    };\n    AnsiUp.prototype.ansi_to_text = function (txt) {\n        var _this = this;\n        var raw_text_pkts = txt.split(/\\x1B\\[/);\n        var first_txt = raw_text_pkts.shift(); // the first pkt is not the result of the split\n        var blocks = raw_text_pkts.map(function (block) { return _this.process_ansi(block); });\n        if (first_txt.length > 0)\n            blocks.unshift(first_txt);\n        return blocks.join('');\n    };\n    AnsiUp.prototype.wrap_text = function (txt) {\n        if (txt.length === 0)\n            return txt;\n        if (this._escapeForHtml)\n            txt = this.doEscape(txt);\n        if (!this.bright && this.fg === null && this.bg === null)\n            return txt;\n        var styles = [];\n        var classes = [];\n        var fg = this.fg;\n        var bg = this.bg;\n        // Handle the case where we are told to be bright, but without a color\n        if (fg === null && this.bright)\n            fg = this.ansi_colors[1][7];\n        if (!this._useClasses) {\n            // USE INLINE STYLES\n            if (fg)\n                styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n            if (bg)\n                styles.push(\"background-color:rgb(\" + bg.rgb + \")\");\n        }\n        else {\n            // USE CLASSES\n            if (fg) {\n                if (fg.class_name !== 'truecolor') {\n                    classes.push(fg.class_name + \"-fg\");\n                }\n                else {\n                    styles.push(\"color:rgb(\" + fg.rgb.join(',') + \")\");\n                }\n            }\n            if (bg) {\n                if (bg.class_name !== 'truecolor') {\n                    classes.push(bg.class_name + \"-bg\");\n                }\n                else {\n                    styles.push(\"background-color:rgb(\" + bg.rgb.join(',') + \")\");\n                }\n            }\n        }\n        var class_string = '';\n        var style_string = '';\n        if (classes.length)\n            class_string = \" class=\\\"\" + classes.join(' ') + \"\\\"\";\n        if (styles.length)\n            style_string = \" style=\\\"\" + styles.join(';') + \"\\\"\";\n        return \"<span\" + class_string + style_string + \">\" + txt + \"</span>\";\n    };\n    AnsiUp.prototype.process_ansi = function (block) {\n        // This must only be called with a string that started with a CSI (the string split above)\n        // The CSI must not be in the string. We consider this string to be a 'block'.\n        // It has an ANSI command at the front that affects the text that follows it.\n        //\n        // This regex is designed to parse an ANSI terminal CSI command. To be more specific,\n        // we follow the XTERM conventions vs. the various other \"standards\".\n        // http://invisible-island.net/xterm/ctlseqs/ctlseqs.html\n        //\n        // All ansi codes are typically in the following format. We parse it and focus\n        // specifically on the graphics commands (SGR)\n        //\n        // CONTROL-SEQUENCE-INTRODUCER CSI             (ESC, '[')\n        // PRIVATE-MODE-CHAR                           (!, <, >, ?)\n        // Numeric parameters separated by semicolons  ('0' - '9', ';')\n        // Intermediate-modifiers                      (0x20 - 0x2f)\n        // COMMAND-CHAR                                (0x40 - 0x7e)\n        //\n        // We use a regex to parse into capture groups the PRIVATE-MODE-CHAR to the COMMAND\n        // and the following text\n        //\n        // Lazy regex creation to keep nicely commented code here\n        // NOTE: default is multiline (workaround for now til I can\n        // determine flags inline)\n        if (!this._sgr_regex) {\n            this._sgr_regex = (_a = [\"\\n              ^                           # beginning of line\\n              ([!<-?]?)             # a private-mode char (!, <, =, >, ?)\\n              ([d;]*)                    # any digits or semicolons\\n              ([ -/]?               # an intermediate modifier\\n               [@-~])               # the command\\n              ([sS]*)                   # any text following this CSI sequence\\n              \"], _a.raw = [\"\\n              ^                           # beginning of line\\n              ([!\\\\x3c-\\\\x3f]?)             # a private-mode char (!, <, =, >, ?)\\n              ([\\\\d;]*)                    # any digits or semicolons\\n              ([\\\\x20-\\\\x2f]?               # an intermediate modifier\\n               [\\\\x40-\\\\x7e])               # the command\\n              ([\\\\s\\\\S]*)                   # any text following this CSI sequence\\n              \"], this.rgx(_a));\n        }\n        var matches = block.match(this._sgr_regex);\n        // The regex should have handled all cases!\n        if (!matches)\n            return block;\n        var orig_txt = matches[4];\n        if (matches[1] !== '' || matches[3] !== 'm')\n            return orig_txt;\n        // Ok - we have a valid \"SGR\" (Select Graphic Rendition)\n        var sgr_cmds = matches[2].split(';');\n        // Each of these params affects the SGR state\n        // Why do we shift through the array instead of a forEach??\n        // ... because some commands consume the params that follow !\n        while (sgr_cmds.length > 0) {\n            var sgr_cmd_str = sgr_cmds.shift();\n            var num = parseInt(sgr_cmd_str, 10);\n            if (isNaN(num) || num === 0) {\n                this.fg = this.bg = null;\n                this.bright = false;\n            }\n            else if (num === 1) {\n                this.bright = true;\n            }\n            else if (num === 22) {\n                this.bright = false;\n            }\n            else if (num === 39) {\n                this.fg = null;\n            }\n            else if (num === 49) {\n                this.bg = null;\n            }\n            else if ((num >= 30) && (num < 38)) {\n                var bidx = this.bright ? 1 : 0;\n                this.fg = this.ansi_colors[bidx][(num - 30)];\n            }\n            else if ((num >= 90) && (num < 98)) {\n                this.fg = this.ansi_colors[1][(num - 90)];\n            }\n            else if ((num >= 40) && (num < 48)) {\n                this.bg = this.ansi_colors[0][(num - 40)];\n            }\n            else if ((num >= 100) && (num < 108)) {\n                this.bg = this.ansi_colors[1][(num - 100)];\n            }\n            else if (num === 38 || num === 48) {\n                // extended set foreground/background color\n                // validate that param exists\n                if (sgr_cmds.length > 0) {\n                    // extend color (38=fg, 48=bg)\n                    var is_foreground = (num === 38);\n                    var mode_cmd = sgr_cmds.shift();\n                    // MODE '5' - 256 color palette\n                    if (mode_cmd === '5' && sgr_cmds.length > 0) {\n                        var palette_index = parseInt(sgr_cmds.shift(), 10);\n                        if (palette_index >= 0 && palette_index <= 255) {\n                            if (is_foreground)\n                                this.fg = this.palette_256[palette_index];\n                            else\n                                this.bg = this.palette_256[palette_index];\n                        }\n                    }\n                    // MODE '2' - True Color\n                    if (mode_cmd === '2' && sgr_cmds.length > 2) {\n                        var r = parseInt(sgr_cmds.shift(), 10);\n                        var g = parseInt(sgr_cmds.shift(), 10);\n                        var b = parseInt(sgr_cmds.shift(), 10);\n                        if ((r >= 0 && r <= 255) && (g >= 0 && g <= 255) && (b >= 0 && b <= 255)) {\n                            var c = { rgb: [r, g, b], class_name: 'truecolor' };\n                            if (is_foreground)\n                                this.fg = c;\n                            else\n                                this.bg = c;\n                        }\n                    }\n                }\n            }\n        }\n        return orig_txt;\n        var _a;\n    };\n    // ES5 template string transformer\n    // NOTE: default is multiline (workaround for now til I can\n    // determine flags inline)\n    AnsiUp.prototype.rgx = function (tmplObj) {\n        var subst = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            subst[_i - 1] = arguments[_i];\n        }\n        // Use the 'raw' value so we don't have to double backslash in a template string\n        var regexText = tmplObj.raw[0];\n        // Remove white-space and comments\n        var wsrgx = /^\\s+|\\s+\\n|\\s+#[\\s\\S]+?\\n/gm;\n        var txt2 = regexText.replace(wsrgx, '');\n        return new RegExp(txt2, 'm');\n    };\n    return AnsiUp;\n}());\n\n//# sourceMappingURL=ansi-up.js.map\n\n//# sourceURL=webpack://gameengine/./node_modules/ansi-up/dist/ansi-up.js?");

/***/ }),

/***/ "./node_modules/planck-js/dist/planck.mjs":
/*!************************************************!*\
  !*** ./node_modules/planck-js/dist/planck.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AABB: () => (/* binding */ AABB),\n/* harmony export */   Body: () => (/* binding */ Body),\n/* harmony export */   Box: () => (/* binding */ Box),\n/* harmony export */   BoxShape: () => (/* binding */ BoxShape),\n/* harmony export */   BroadPhase: () => (/* binding */ BroadPhase),\n/* harmony export */   Chain: () => (/* binding */ Chain),\n/* harmony export */   ChainShape: () => (/* binding */ ChainShape),\n/* harmony export */   Circle: () => (/* binding */ Circle),\n/* harmony export */   CircleShape: () => (/* binding */ CircleShape),\n/* harmony export */   ClipVertex: () => (/* binding */ ClipVertex),\n/* harmony export */   CollideCircles: () => (/* binding */ CollideCircles),\n/* harmony export */   CollideEdgeCircle: () => (/* binding */ CollideEdgeCircle),\n/* harmony export */   CollideEdgePolygon: () => (/* binding */ CollideEdgePolygon),\n/* harmony export */   CollidePolygonCircle: () => (/* binding */ CollidePolygonCircle),\n/* harmony export */   CollidePolygons: () => (/* binding */ CollidePolygons),\n/* harmony export */   Contact: () => (/* binding */ Contact),\n/* harmony export */   ContactEdge: () => (/* binding */ ContactEdge),\n/* harmony export */   ContactFeatureType: () => (/* binding */ ContactFeatureType),\n/* harmony export */   ContactID: () => (/* binding */ ContactID),\n/* harmony export */   ContactImpulse: () => (/* binding */ ContactImpulse),\n/* harmony export */   DataDriver: () => (/* binding */ DataDriver),\n/* harmony export */   Distance: () => (/* binding */ Distance),\n/* harmony export */   DistanceInput: () => (/* binding */ DistanceInput),\n/* harmony export */   DistanceJoint: () => (/* binding */ DistanceJoint),\n/* harmony export */   DistanceOutput: () => (/* binding */ DistanceOutput),\n/* harmony export */   DistanceProxy: () => (/* binding */ DistanceProxy),\n/* harmony export */   DynamicTree: () => (/* binding */ DynamicTree),\n/* harmony export */   Edge: () => (/* binding */ Edge),\n/* harmony export */   EdgeShape: () => (/* binding */ EdgeShape),\n/* harmony export */   Fixture: () => (/* binding */ Fixture),\n/* harmony export */   FixtureProxy: () => (/* binding */ FixtureProxy),\n/* harmony export */   FrictionJoint: () => (/* binding */ FrictionJoint),\n/* harmony export */   GearJoint: () => (/* binding */ GearJoint),\n/* harmony export */   Joint: () => (/* binding */ Joint),\n/* harmony export */   JointEdge: () => (/* binding */ JointEdge),\n/* harmony export */   Manifold: () => (/* binding */ Manifold),\n/* harmony export */   ManifoldPoint: () => (/* binding */ ManifoldPoint),\n/* harmony export */   ManifoldType: () => (/* binding */ ManifoldType),\n/* harmony export */   Mat22: () => (/* binding */ Mat22),\n/* harmony export */   Mat33: () => (/* binding */ Mat33),\n/* harmony export */   Math: () => (/* binding */ math),\n/* harmony export */   MotorJoint: () => (/* binding */ MotorJoint),\n/* harmony export */   MouseJoint: () => (/* binding */ MouseJoint),\n/* harmony export */   PointState: () => (/* binding */ PointState),\n/* harmony export */   Polygon: () => (/* binding */ Polygon),\n/* harmony export */   PolygonShape: () => (/* binding */ PolygonShape),\n/* harmony export */   PrismaticJoint: () => (/* binding */ PrismaticJoint),\n/* harmony export */   PulleyJoint: () => (/* binding */ PulleyJoint),\n/* harmony export */   RevoluteJoint: () => (/* binding */ RevoluteJoint),\n/* harmony export */   RopeJoint: () => (/* binding */ RopeJoint),\n/* harmony export */   Rot: () => (/* binding */ Rot),\n/* harmony export */   Serializer: () => (/* binding */ Serializer),\n/* harmony export */   Settings: () => (/* binding */ Settings),\n/* harmony export */   SettingsInternal: () => (/* binding */ SettingsInternal),\n/* harmony export */   Shape: () => (/* binding */ Shape),\n/* harmony export */   ShapeCast: () => (/* binding */ ShapeCast),\n/* harmony export */   ShapeCastInput: () => (/* binding */ ShapeCastInput),\n/* harmony export */   ShapeCastOutput: () => (/* binding */ ShapeCastOutput),\n/* harmony export */   SimplexCache: () => (/* binding */ SimplexCache),\n/* harmony export */   Solver: () => (/* binding */ Solver),\n/* harmony export */   Sweep: () => (/* binding */ Sweep),\n/* harmony export */   TOIInput: () => (/* binding */ TOIInput),\n/* harmony export */   TOIOutput: () => (/* binding */ TOIOutput),\n/* harmony export */   TOIOutputState: () => (/* binding */ TOIOutputState),\n/* harmony export */   Testbed: () => (/* binding */ Testbed),\n/* harmony export */   TimeOfImpact: () => (/* binding */ TimeOfImpact),\n/* harmony export */   TimeStep: () => (/* binding */ TimeStep),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   TreeNode: () => (/* binding */ TreeNode),\n/* harmony export */   Vec2: () => (/* binding */ Vec2),\n/* harmony export */   Vec3: () => (/* binding */ Vec3),\n/* harmony export */   VelocityConstraintPoint: () => (/* binding */ VelocityConstraintPoint),\n/* harmony export */   WeldJoint: () => (/* binding */ WeldJoint),\n/* harmony export */   WheelJoint: () => (/* binding */ WheelJoint),\n/* harmony export */   World: () => (/* binding */ World),\n/* harmony export */   WorldManifold: () => (/* binding */ WorldManifold),\n/* harmony export */   clipSegmentToLine: () => (/* binding */ clipSegmentToLine),\n/* harmony export */   \"default\": () => (/* binding */ planck),\n/* harmony export */   getPointStates: () => (/* binding */ getPointStates),\n/* harmony export */   internal: () => (/* binding */ internal),\n/* harmony export */   mixFriction: () => (/* binding */ mixFriction),\n/* harmony export */   mixRestitution: () => (/* binding */ mixRestitution),\n/* harmony export */   stats: () => (/* binding */ stats),\n/* harmony export */   testOverlap: () => (/* binding */ testOverlap),\n/* harmony export */   testbed: () => (/* binding */ testbed)\n/* harmony export */ });\n/**\n * Planck.js v1.3.0\n * @license The MIT license\n * @copyright Copyright (c) 2024 Erin Catto, Ali Shakiba\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n/*! *****************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\nvar extendStatics = function(d2, b2) {\n  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {\n    d3.__proto__ = b3;\n  } || function(d3, b3) {\n    for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d3[p] = b3[p];\n  };\n  return extendStatics(d2, b2);\n};\nfunction __extends(d2, b2) {\n  if (typeof b2 !== \"function\" && b2 !== null)\n    throw new TypeError(\"Class extends value \" + String(b2) + \" is not a constructor or null\");\n  extendStatics(d2, b2);\n  function __() {\n    this.constructor = d2;\n  }\n  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());\n}\nvar __assign = function() {\n  __assign = Object.assign || function __assign2(t) {\n    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {\n      s2 = arguments[i];\n      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t[p] = s2[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nvar options = function(input2, defaults) {\n  if (input2 === null || typeof input2 === \"undefined\") {\n    input2 = {};\n  }\n  var output2 = __assign({}, input2);\n  for (var key in defaults) {\n    if (defaults.hasOwnProperty(key) && typeof input2[key] === \"undefined\") {\n      output2[key] = defaults[key];\n    }\n  }\n  if (typeof Object.getOwnPropertySymbols === \"function\") {\n    var symbols = Object.getOwnPropertySymbols(defaults);\n    for (var i = 0; i < symbols.length; i++) {\n      var symbol = symbols[i];\n      if (defaults.propertyIsEnumerable(symbol) && typeof input2[symbol] === \"undefined\") {\n        output2[symbol] = defaults[symbol];\n      }\n    }\n  }\n  return output2;\n};\nvar math_random = Math.random;\nvar EPSILON = 1e-9;\nvar isFinite = Number.isFinite;\nfunction nextPowerOfTwo(x2) {\n  x2 |= x2 >> 1;\n  x2 |= x2 >> 2;\n  x2 |= x2 >> 4;\n  x2 |= x2 >> 8;\n  x2 |= x2 >> 16;\n  return x2 + 1;\n}\nfunction isPowerOfTwo(x2) {\n  return x2 > 0 && (x2 & x2 - 1) === 0;\n}\nfunction mod(num, min, max) {\n  if (typeof min === \"undefined\") {\n    max = 1;\n    min = 0;\n  } else if (typeof max === \"undefined\") {\n    max = min;\n    min = 0;\n  }\n  if (max > min) {\n    num = (num - min) % (max - min);\n    return num + (num < 0 ? max : min);\n  } else {\n    num = (num - max) % (min - max);\n    return num + (num <= 0 ? min : max);\n  }\n}\nfunction clamp(num, min, max) {\n  if (num < min) {\n    return min;\n  } else if (num > max) {\n    return max;\n  } else {\n    return num;\n  }\n}\nfunction random(min, max) {\n  if (typeof min === \"undefined\") {\n    max = 1;\n    min = 0;\n  } else if (typeof max === \"undefined\") {\n    max = min;\n    min = 0;\n  }\n  return min === max ? min : math_random() * (max - min) + min;\n}\nvar math = Object.create(Math);\nmath.EPSILON = EPSILON;\nmath.isFinite = isFinite;\nmath.nextPowerOfTwo = nextPowerOfTwo;\nmath.isPowerOfTwo = isPowerOfTwo;\nmath.mod = mod;\nmath.clamp = clamp;\nmath.random = random;\nvar math_abs$9 = Math.abs;\nvar math_sqrt$5 = Math.sqrt;\nvar math_max$8 = Math.max;\nvar math_min$8 = Math.min;\nvar Vec2 = (\n  /** @class */\n  function() {\n    function Vec22(x2, y) {\n      if (!(this instanceof Vec22)) {\n        return new Vec22(x2, y);\n      }\n      if (typeof x2 === \"undefined\") {\n        this.x = 0;\n        this.y = 0;\n      } else if (typeof x2 === \"object\") {\n        this.x = x2.x;\n        this.y = x2.y;\n      } else {\n        this.x = x2;\n        this.y = y;\n      }\n    }\n    Vec22.prototype._serialize = function() {\n      return {\n        x: this.x,\n        y: this.y\n      };\n    };\n    Vec22._deserialize = function(data) {\n      var obj = Object.create(Vec22.prototype);\n      obj.x = data.x;\n      obj.y = data.y;\n      return obj;\n    };\n    Vec22.zero = function() {\n      var obj = Object.create(Vec22.prototype);\n      obj.x = 0;\n      obj.y = 0;\n      return obj;\n    };\n    Vec22.neo = function(x2, y) {\n      var obj = Object.create(Vec22.prototype);\n      obj.x = x2;\n      obj.y = y;\n      return obj;\n    };\n    Vec22.clone = function(v3) {\n      return Vec22.neo(v3.x, v3.y);\n    };\n    Vec22.prototype.toString = function() {\n      return JSON.stringify(this);\n    };\n    Vec22.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Number.isFinite(obj.x) && Number.isFinite(obj.y);\n    };\n    Vec22.assert = function(o) {\n    };\n    Vec22.prototype.clone = function() {\n      return Vec22.clone(this);\n    };\n    Vec22.prototype.setZero = function() {\n      this.x = 0;\n      this.y = 0;\n      return this;\n    };\n    Vec22.prototype.set = function(x2, y) {\n      if (typeof x2 === \"object\") {\n        this.x = x2.x;\n        this.y = x2.y;\n      } else {\n        this.x = x2;\n        this.y = y;\n      }\n      return this;\n    };\n    Vec22.prototype.setNum = function(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    };\n    Vec22.prototype.setVec2 = function(value) {\n      this.x = value.x;\n      this.y = value.y;\n      return this;\n    };\n    Vec22.prototype.wSet = function(a2, v3, b2, w) {\n      if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n        return this.setCombine(a2, v3, b2, w);\n      } else {\n        return this.setMul(a2, v3);\n      }\n    };\n    Vec22.prototype.setCombine = function(a2, v3, b2, w) {\n      var x2 = a2 * v3.x + b2 * w.x;\n      var y = a2 * v3.y + b2 * w.y;\n      this.x = x2;\n      this.y = y;\n      return this;\n    };\n    Vec22.prototype.setMul = function(a2, v3) {\n      var x2 = a2 * v3.x;\n      var y = a2 * v3.y;\n      this.x = x2;\n      this.y = y;\n      return this;\n    };\n    Vec22.prototype.add = function(w) {\n      this.x += w.x;\n      this.y += w.y;\n      return this;\n    };\n    Vec22.prototype.wAdd = function(a2, v3, b2, w) {\n      if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n        return this.addCombine(a2, v3, b2, w);\n      } else {\n        return this.addMul(a2, v3);\n      }\n    };\n    Vec22.prototype.addCombine = function(a2, v3, b2, w) {\n      var x2 = a2 * v3.x + b2 * w.x;\n      var y = a2 * v3.y + b2 * w.y;\n      this.x += x2;\n      this.y += y;\n      return this;\n    };\n    Vec22.prototype.addMul = function(a2, v3) {\n      var x2 = a2 * v3.x;\n      var y = a2 * v3.y;\n      this.x += x2;\n      this.y += y;\n      return this;\n    };\n    Vec22.prototype.wSub = function(a2, v3, b2, w) {\n      if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n        return this.subCombine(a2, v3, b2, w);\n      } else {\n        return this.subMul(a2, v3);\n      }\n    };\n    Vec22.prototype.subCombine = function(a2, v3, b2, w) {\n      var x2 = a2 * v3.x + b2 * w.x;\n      var y = a2 * v3.y + b2 * w.y;\n      this.x -= x2;\n      this.y -= y;\n      return this;\n    };\n    Vec22.prototype.subMul = function(a2, v3) {\n      var x2 = a2 * v3.x;\n      var y = a2 * v3.y;\n      this.x -= x2;\n      this.y -= y;\n      return this;\n    };\n    Vec22.prototype.sub = function(w) {\n      this.x -= w.x;\n      this.y -= w.y;\n      return this;\n    };\n    Vec22.prototype.mul = function(m) {\n      this.x *= m;\n      this.y *= m;\n      return this;\n    };\n    Vec22.prototype.length = function() {\n      return Vec22.lengthOf(this);\n    };\n    Vec22.prototype.lengthSquared = function() {\n      return Vec22.lengthSquared(this);\n    };\n    Vec22.prototype.normalize = function() {\n      var length = this.length();\n      if (length < EPSILON) {\n        return 0;\n      }\n      var invLength = 1 / length;\n      this.x *= invLength;\n      this.y *= invLength;\n      return length;\n    };\n    Vec22.normalize = function(v3) {\n      var length = Vec22.lengthOf(v3);\n      if (length < EPSILON) {\n        return Vec22.zero();\n      }\n      var invLength = 1 / length;\n      return Vec22.neo(v3.x * invLength, v3.y * invLength);\n    };\n    Vec22.lengthOf = function(v3) {\n      return math_sqrt$5(v3.x * v3.x + v3.y * v3.y);\n    };\n    Vec22.lengthSquared = function(v3) {\n      return v3.x * v3.x + v3.y * v3.y;\n    };\n    Vec22.distance = function(v3, w) {\n      var dx = v3.x - w.x;\n      var dy = v3.y - w.y;\n      return math_sqrt$5(dx * dx + dy * dy);\n    };\n    Vec22.distanceSquared = function(v3, w) {\n      var dx = v3.x - w.x;\n      var dy = v3.y - w.y;\n      return dx * dx + dy * dy;\n    };\n    Vec22.areEqual = function(v3, w) {\n      return v3 === w || typeof w === \"object\" && w !== null && v3.x === w.x && v3.y === w.y;\n    };\n    Vec22.skew = function(v3) {\n      return Vec22.neo(-v3.y, v3.x);\n    };\n    Vec22.dot = function(v3, w) {\n      return v3.x * w.x + v3.y * w.y;\n    };\n    Vec22.cross = function(v3, w) {\n      if (typeof w === \"number\") {\n        return Vec22.neo(w * v3.y, -w * v3.x);\n      } else if (typeof v3 === \"number\") {\n        return Vec22.neo(-v3 * w.y, v3 * w.x);\n      } else {\n        return v3.x * w.y - v3.y * w.x;\n      }\n    };\n    Vec22.crossVec2Vec2 = function(v3, w) {\n      return v3.x * w.y - v3.y * w.x;\n    };\n    Vec22.crossVec2Num = function(v3, w) {\n      return Vec22.neo(w * v3.y, -w * v3.x);\n    };\n    Vec22.crossNumVec2 = function(v3, w) {\n      return Vec22.neo(-v3 * w.y, v3 * w.x);\n    };\n    Vec22.addCross = function(a2, v3, w) {\n      if (typeof w === \"number\") {\n        return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);\n      } else if (typeof v3 === \"number\") {\n        return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);\n      }\n    };\n    Vec22.addCrossVec2Num = function(a2, v3, w) {\n      return Vec22.neo(w * v3.y + a2.x, -w * v3.x + a2.y);\n    };\n    Vec22.addCrossNumVec2 = function(a2, v3, w) {\n      return Vec22.neo(-v3 * w.y + a2.x, v3 * w.x + a2.y);\n    };\n    Vec22.add = function(v3, w) {\n      return Vec22.neo(v3.x + w.x, v3.y + w.y);\n    };\n    Vec22.wAdd = function(a2, v3, b2, w) {\n      if (typeof b2 !== \"undefined\" || typeof w !== \"undefined\") {\n        return Vec22.combine(a2, v3, b2, w);\n      } else {\n        return Vec22.mulNumVec2(a2, v3);\n      }\n    };\n    Vec22.combine = function(a2, v3, b2, w) {\n      return Vec22.zero().setCombine(a2, v3, b2, w);\n    };\n    Vec22.sub = function(v3, w) {\n      return Vec22.neo(v3.x - w.x, v3.y - w.y);\n    };\n    Vec22.mul = function(a2, b2) {\n      if (typeof a2 === \"object\") {\n        return Vec22.neo(a2.x * b2, a2.y * b2);\n      } else if (typeof b2 === \"object\") {\n        return Vec22.neo(a2 * b2.x, a2 * b2.y);\n      }\n    };\n    Vec22.mulVec2Num = function(a2, b2) {\n      return Vec22.neo(a2.x * b2, a2.y * b2);\n    };\n    Vec22.mulNumVec2 = function(a2, b2) {\n      return Vec22.neo(a2 * b2.x, a2 * b2.y);\n    };\n    Vec22.prototype.neg = function() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    };\n    Vec22.neg = function(v3) {\n      return Vec22.neo(-v3.x, -v3.y);\n    };\n    Vec22.abs = function(v3) {\n      return Vec22.neo(math_abs$9(v3.x), math_abs$9(v3.y));\n    };\n    Vec22.mid = function(v3, w) {\n      return Vec22.neo((v3.x + w.x) * 0.5, (v3.y + w.y) * 0.5);\n    };\n    Vec22.upper = function(v3, w) {\n      return Vec22.neo(math_max$8(v3.x, w.x), math_max$8(v3.y, w.y));\n    };\n    Vec22.lower = function(v3, w) {\n      return Vec22.neo(math_min$8(v3.x, w.x), math_min$8(v3.y, w.y));\n    };\n    Vec22.prototype.clamp = function(max) {\n      var lengthSqr = this.x * this.x + this.y * this.y;\n      if (lengthSqr > max * max) {\n        var scale = max / math_sqrt$5(lengthSqr);\n        this.x *= scale;\n        this.y *= scale;\n      }\n      return this;\n    };\n    Vec22.clamp = function(v3, max) {\n      var r = Vec22.neo(v3.x, v3.y);\n      r.clamp(max);\n      return r;\n    };\n    Vec22.clampVec2 = function(v3, min, max) {\n      return {\n        x: clamp(v3.x, min === null || min === void 0 ? void 0 : min.x, max === null || max === void 0 ? void 0 : max.x),\n        y: clamp(v3.y, min === null || min === void 0 ? void 0 : min.y, max === null || max === void 0 ? void 0 : max.y)\n      };\n    };\n    Vec22.scaleFn = function(x2, y) {\n      return function(v3) {\n        return Vec22.neo(v3.x * x2, v3.y * y);\n      };\n    };\n    Vec22.translateFn = function(x2, y) {\n      return function(v3) {\n        return Vec22.neo(v3.x + x2, v3.y + y);\n      };\n    };\n    return Vec22;\n  }()\n);\nvar math_max$7 = Math.max;\nvar math_min$7 = Math.min;\nvar AABB = (\n  /** @class */\n  function() {\n    function AABB2(lower, upper) {\n      if (!(this instanceof AABB2)) {\n        return new AABB2(lower, upper);\n      }\n      this.lowerBound = Vec2.zero();\n      this.upperBound = Vec2.zero();\n      if (typeof lower === \"object\") {\n        this.lowerBound.setVec2(lower);\n      }\n      if (typeof upper === \"object\") {\n        this.upperBound.setVec2(upper);\n      } else if (typeof lower === \"object\") {\n        this.upperBound.setVec2(lower);\n      }\n    }\n    AABB2.prototype.isValid = function() {\n      return AABB2.isValid(this);\n    };\n    AABB2.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Vec2.isValid(obj.lowerBound) && Vec2.isValid(obj.upperBound) && Vec2.sub(obj.upperBound, obj.lowerBound).lengthSquared() >= 0;\n    };\n    AABB2.assert = function(o) {\n    };\n    AABB2.prototype.getCenter = function() {\n      return Vec2.neo((this.lowerBound.x + this.upperBound.x) * 0.5, (this.lowerBound.y + this.upperBound.y) * 0.5);\n    };\n    AABB2.prototype.getExtents = function() {\n      return Vec2.neo((this.upperBound.x - this.lowerBound.x) * 0.5, (this.upperBound.y - this.lowerBound.y) * 0.5);\n    };\n    AABB2.prototype.getPerimeter = function() {\n      return 2 * (this.upperBound.x - this.lowerBound.x + this.upperBound.y - this.lowerBound.y);\n    };\n    AABB2.prototype.combine = function(a2, b2) {\n      b2 = b2 || this;\n      var lowerA = a2.lowerBound;\n      var upperA = a2.upperBound;\n      var lowerB = b2.lowerBound;\n      var upperB = b2.upperBound;\n      var lowerX = math_min$7(lowerA.x, lowerB.x);\n      var lowerY = math_min$7(lowerA.y, lowerB.y);\n      var upperX = math_max$7(upperB.x, upperA.x);\n      var upperY = math_max$7(upperB.y, upperA.y);\n      this.lowerBound.setNum(lowerX, lowerY);\n      this.upperBound.setNum(upperX, upperY);\n    };\n    AABB2.prototype.combinePoints = function(a2, b2) {\n      this.lowerBound.setNum(math_min$7(a2.x, b2.x), math_min$7(a2.y, b2.y));\n      this.upperBound.setNum(math_max$7(a2.x, b2.x), math_max$7(a2.y, b2.y));\n    };\n    AABB2.prototype.set = function(aabb) {\n      this.lowerBound.setNum(aabb.lowerBound.x, aabb.lowerBound.y);\n      this.upperBound.setNum(aabb.upperBound.x, aabb.upperBound.y);\n    };\n    AABB2.prototype.contains = function(aabb) {\n      var result = true;\n      result = result && this.lowerBound.x <= aabb.lowerBound.x;\n      result = result && this.lowerBound.y <= aabb.lowerBound.y;\n      result = result && aabb.upperBound.x <= this.upperBound.x;\n      result = result && aabb.upperBound.y <= this.upperBound.y;\n      return result;\n    };\n    AABB2.prototype.extend = function(value) {\n      AABB2.extend(this, value);\n      return this;\n    };\n    AABB2.extend = function(out, value) {\n      out.lowerBound.x -= value;\n      out.lowerBound.y -= value;\n      out.upperBound.x += value;\n      out.upperBound.y += value;\n      return out;\n    };\n    AABB2.testOverlap = function(a2, b2) {\n      var d1x = b2.lowerBound.x - a2.upperBound.x;\n      var d2x = a2.lowerBound.x - b2.upperBound.x;\n      var d1y = b2.lowerBound.y - a2.upperBound.y;\n      var d2y = a2.lowerBound.y - b2.upperBound.y;\n      if (d1x > 0 || d1y > 0 || d2x > 0 || d2y > 0) {\n        return false;\n      }\n      return true;\n    };\n    AABB2.areEqual = function(a2, b2) {\n      return Vec2.areEqual(a2.lowerBound, b2.lowerBound) && Vec2.areEqual(a2.upperBound, b2.upperBound);\n    };\n    AABB2.diff = function(a2, b2) {\n      var wD = math_max$7(0, math_min$7(a2.upperBound.x, b2.upperBound.x) - math_max$7(b2.lowerBound.x, a2.lowerBound.x));\n      var hD = math_max$7(0, math_min$7(a2.upperBound.y, b2.upperBound.y) - math_max$7(b2.lowerBound.y, a2.lowerBound.y));\n      var wA = a2.upperBound.x - a2.lowerBound.x;\n      var hA = a2.upperBound.y - a2.lowerBound.y;\n      var wB = b2.upperBound.x - b2.lowerBound.x;\n      var hB = b2.upperBound.y - b2.lowerBound.y;\n      return wA * hA + wB * hB - wD * hD;\n    };\n    AABB2.prototype.rayCast = function(output2, input2) {\n      var tmin = -Infinity;\n      var tmax = Infinity;\n      var p = input2.p1;\n      var d2 = Vec2.sub(input2.p2, input2.p1);\n      var absD = Vec2.abs(d2);\n      var normal3 = Vec2.zero();\n      for (var f = \"x\"; f !== null; f = f === \"x\" ? \"y\" : null) {\n        if (absD.x < EPSILON) {\n          if (p[f] < this.lowerBound[f] || this.upperBound[f] < p[f]) {\n            return false;\n          }\n        } else {\n          var inv_d = 1 / d2[f];\n          var t1 = (this.lowerBound[f] - p[f]) * inv_d;\n          var t2 = (this.upperBound[f] - p[f]) * inv_d;\n          var s2 = -1;\n          if (t1 > t2) {\n            var temp3 = t1;\n            t1 = t2;\n            t2 = temp3;\n            s2 = 1;\n          }\n          if (t1 > tmin) {\n            normal3.setZero();\n            normal3[f] = s2;\n            tmin = t1;\n          }\n          tmax = math_min$7(tmax, t2);\n          if (tmin > tmax) {\n            return false;\n          }\n        }\n      }\n      if (tmin < 0 || input2.maxFraction < tmin) {\n        return false;\n      }\n      output2.fraction = tmin;\n      output2.normal = normal3;\n      return true;\n    };\n    AABB2.prototype.toString = function() {\n      return JSON.stringify(this);\n    };\n    AABB2.combinePoints = function(out, a2, b2) {\n      out.lowerBound.x = math_min$7(a2.x, b2.x);\n      out.lowerBound.y = math_min$7(a2.y, b2.y);\n      out.upperBound.x = math_max$7(a2.x, b2.x);\n      out.upperBound.y = math_max$7(a2.y, b2.y);\n      return out;\n    };\n    AABB2.combinedPerimeter = function(a2, b2) {\n      var lx = math_min$7(a2.lowerBound.x, b2.lowerBound.x);\n      var ly = math_min$7(a2.lowerBound.y, b2.lowerBound.y);\n      var ux = math_max$7(a2.upperBound.x, b2.upperBound.x);\n      var uy = math_max$7(a2.upperBound.y, b2.upperBound.y);\n      return 2 * (ux - lx + uy - ly);\n    };\n    return AABB2;\n  }()\n);\nvar math_PI$6 = Math.PI;\nvar Settings = (\n  /** @class */\n  function() {\n    function Settings2() {\n    }\n    Object.defineProperty(Settings2, \"polygonRadius\", {\n      /**\n       * The radius of the polygon/edge shape skin. This should not be modified.\n       * Making this smaller means polygons will have an insufficient buffer for\n       * continuous collision. Making it larger may create artifacts for vertex\n       * collision.\n       */\n      get: function() {\n        return 2 * Settings2.linearSlop;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Settings2.lengthUnitsPerMeter = 1;\n    Settings2.maxManifoldPoints = 2;\n    Settings2.maxPolygonVertices = 12;\n    Settings2.aabbExtension = 0.1;\n    Settings2.aabbMultiplier = 2;\n    Settings2.linearSlop = 5e-3;\n    Settings2.angularSlop = 2 / 180 * math_PI$6;\n    Settings2.maxSubSteps = 8;\n    Settings2.maxTOIContacts = 32;\n    Settings2.maxTOIIterations = 20;\n    Settings2.maxDistanceIterations = 20;\n    Settings2.velocityThreshold = 1;\n    Settings2.maxLinearCorrection = 0.2;\n    Settings2.maxAngularCorrection = 8 / 180 * math_PI$6;\n    Settings2.maxTranslation = 2;\n    Settings2.maxRotation = 0.5 * math_PI$6;\n    Settings2.baumgarte = 0.2;\n    Settings2.toiBaugarte = 0.75;\n    Settings2.timeToSleep = 0.5;\n    Settings2.linearSleepTolerance = 0.01;\n    Settings2.angularSleepTolerance = 2 / 180 * math_PI$6;\n    return Settings2;\n  }()\n);\nvar SettingsInternal = (\n  /** @class */\n  function() {\n    function SettingsInternal2() {\n    }\n    Object.defineProperty(SettingsInternal2, \"maxManifoldPoints\", {\n      get: function() {\n        return Settings.maxManifoldPoints;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxPolygonVertices\", {\n      get: function() {\n        return Settings.maxPolygonVertices;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"aabbExtension\", {\n      get: function() {\n        return Settings.aabbExtension * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"aabbMultiplier\", {\n      get: function() {\n        return Settings.aabbMultiplier;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"linearSlop\", {\n      get: function() {\n        return Settings.linearSlop * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"linearSlopSquared\", {\n      get: function() {\n        return Settings.linearSlop * Settings.lengthUnitsPerMeter * Settings.linearSlop * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"angularSlop\", {\n      get: function() {\n        return Settings.angularSlop;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"polygonRadius\", {\n      get: function() {\n        return 2 * Settings.linearSlop;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxSubSteps\", {\n      get: function() {\n        return Settings.maxSubSteps;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxTOIContacts\", {\n      get: function() {\n        return Settings.maxTOIContacts;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxTOIIterations\", {\n      get: function() {\n        return Settings.maxTOIIterations;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxDistanceIterations\", {\n      get: function() {\n        return Settings.maxDistanceIterations;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"velocityThreshold\", {\n      get: function() {\n        return Settings.velocityThreshold * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxLinearCorrection\", {\n      get: function() {\n        return Settings.maxLinearCorrection * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxAngularCorrection\", {\n      get: function() {\n        return Settings.maxAngularCorrection;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxTranslation\", {\n      get: function() {\n        return Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxTranslationSquared\", {\n      get: function() {\n        return Settings.maxTranslation * Settings.lengthUnitsPerMeter * Settings.maxTranslation * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxRotation\", {\n      get: function() {\n        return Settings.maxRotation;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"maxRotationSquared\", {\n      get: function() {\n        return Settings.maxRotation * Settings.maxRotation;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"baumgarte\", {\n      get: function() {\n        return Settings.baumgarte;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"toiBaugarte\", {\n      get: function() {\n        return Settings.toiBaugarte;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"timeToSleep\", {\n      get: function() {\n        return Settings.timeToSleep;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"linearSleepTolerance\", {\n      get: function() {\n        return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"linearSleepToleranceSqr\", {\n      get: function() {\n        return Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter * Settings.linearSleepTolerance * Settings.lengthUnitsPerMeter;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"angularSleepTolerance\", {\n      get: function() {\n        return Settings.angularSleepTolerance;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(SettingsInternal2, \"angularSleepToleranceSqr\", {\n      get: function() {\n        return Settings.angularSleepTolerance * Settings.angularSleepTolerance;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return SettingsInternal2;\n  }()\n);\nvar Pool = (\n  /** @class */\n  function() {\n    function Pool2(opts) {\n      this._list = [];\n      this._max = Infinity;\n      this._hasCreateFn = false;\n      this._createCount = 0;\n      this._hasAllocateFn = false;\n      this._allocateCount = 0;\n      this._hasReleaseFn = false;\n      this._releaseCount = 0;\n      this._hasDisposeFn = false;\n      this._disposeCount = 0;\n      this._list = [];\n      this._max = opts.max || this._max;\n      this._createFn = opts.create;\n      this._hasCreateFn = typeof this._createFn === \"function\";\n      this._allocateFn = opts.allocate;\n      this._hasAllocateFn = typeof this._allocateFn === \"function\";\n      this._releaseFn = opts.release;\n      this._hasReleaseFn = typeof this._releaseFn === \"function\";\n      this._disposeFn = opts.dispose;\n      this._hasDisposeFn = typeof this._disposeFn === \"function\";\n    }\n    Pool2.prototype.max = function(n2) {\n      if (typeof n2 === \"number\") {\n        this._max = n2;\n        return this;\n      }\n      return this._max;\n    };\n    Pool2.prototype.size = function() {\n      return this._list.length;\n    };\n    Pool2.prototype.allocate = function() {\n      var item;\n      if (this._list.length > 0) {\n        item = this._list.shift();\n      } else {\n        this._createCount++;\n        if (this._hasCreateFn) {\n          item = this._createFn();\n        } else {\n          item = {};\n        }\n      }\n      this._allocateCount++;\n      if (this._hasAllocateFn) {\n        this._allocateFn(item);\n      }\n      return item;\n    };\n    Pool2.prototype.release = function(item) {\n      if (this._list.length < this._max) {\n        this._releaseCount++;\n        if (this._hasReleaseFn) {\n          this._releaseFn(item);\n        }\n        this._list.push(item);\n      } else {\n        this._disposeCount++;\n        if (this._hasDisposeFn) {\n          item = this._disposeFn(item);\n        }\n      }\n    };\n    Pool2.prototype.toString = function() {\n      return \" +\" + this._createCount + \" >\" + this._allocateCount + \" <\" + this._releaseCount + \" -\" + this._disposeCount + \" =\" + this._list.length + \"/\" + this._max;\n    };\n    return Pool2;\n  }()\n);\nvar math_abs$8 = Math.abs;\nvar math_max$6 = Math.max;\nvar TreeNode = (\n  /** @class */\n  function() {\n    function TreeNode2(id) {\n      this.aabb = new AABB();\n      this.userData = null;\n      this.parent = null;\n      this.child1 = null;\n      this.child2 = null;\n      this.height = -1;\n      this.id = id;\n    }\n    TreeNode2.prototype.toString = function() {\n      return this.id + \": \" + this.userData;\n    };\n    TreeNode2.prototype.isLeaf = function() {\n      return this.child1 == null;\n    };\n    return TreeNode2;\n  }()\n);\nvar poolTreeNode = new Pool({\n  create: function() {\n    return new TreeNode();\n  },\n  release: function(node) {\n    node.userData = null;\n    node.parent = null;\n    node.child1 = null;\n    node.child2 = null;\n    node.height = -1;\n    node.id = void 0;\n  }\n});\nvar DynamicTree = (\n  /** @class */\n  function() {\n    function DynamicTree2() {\n      this.inputPool = new Pool({\n        create: function() {\n          return {};\n        },\n        release: function(stack) {\n        }\n      });\n      this.stackPool = new Pool({\n        create: function() {\n          return [];\n        },\n        release: function(stack) {\n          stack.length = 0;\n        }\n      });\n      this.iteratorPool = new Pool({\n        create: function() {\n          return new Iterator();\n        },\n        release: function(iterator) {\n          iterator.close();\n        }\n      });\n      this.m_root = null;\n      this.m_nodes = {};\n      this.m_lastProxyId = 0;\n    }\n    DynamicTree2.prototype.getUserData = function(id) {\n      var node = this.m_nodes[id];\n      return node.userData;\n    };\n    DynamicTree2.prototype.getFatAABB = function(id) {\n      var node = this.m_nodes[id];\n      return node.aabb;\n    };\n    DynamicTree2.prototype.allocateNode = function() {\n      var node = poolTreeNode.allocate();\n      node.id = ++this.m_lastProxyId;\n      this.m_nodes[node.id] = node;\n      return node;\n    };\n    DynamicTree2.prototype.freeNode = function(node) {\n      delete this.m_nodes[node.id];\n      poolTreeNode.release(node);\n    };\n    DynamicTree2.prototype.createProxy = function(aabb, userData) {\n      var node = this.allocateNode();\n      node.aabb.set(aabb);\n      AABB.extend(node.aabb, SettingsInternal.aabbExtension);\n      node.userData = userData;\n      node.height = 0;\n      this.insertLeaf(node);\n      return node.id;\n    };\n    DynamicTree2.prototype.destroyProxy = function(id) {\n      var node = this.m_nodes[id];\n      this.removeLeaf(node);\n      this.freeNode(node);\n    };\n    DynamicTree2.prototype.moveProxy = function(id, aabb, d2) {\n      var node = this.m_nodes[id];\n      if (node.aabb.contains(aabb)) {\n        return false;\n      }\n      this.removeLeaf(node);\n      node.aabb.set(aabb);\n      aabb = node.aabb;\n      AABB.extend(aabb, SettingsInternal.aabbExtension);\n      if (d2.x < 0) {\n        aabb.lowerBound.x += d2.x * SettingsInternal.aabbMultiplier;\n      } else {\n        aabb.upperBound.x += d2.x * SettingsInternal.aabbMultiplier;\n      }\n      if (d2.y < 0) {\n        aabb.lowerBound.y += d2.y * SettingsInternal.aabbMultiplier;\n      } else {\n        aabb.upperBound.y += d2.y * SettingsInternal.aabbMultiplier;\n      }\n      this.insertLeaf(node);\n      return true;\n    };\n    DynamicTree2.prototype.insertLeaf = function(leaf) {\n      if (this.m_root == null) {\n        this.m_root = leaf;\n        this.m_root.parent = null;\n        return;\n      }\n      var leafAABB = leaf.aabb;\n      var index = this.m_root;\n      while (!index.isLeaf()) {\n        var child1 = index.child1;\n        var child2 = index.child2;\n        var area = index.aabb.getPerimeter();\n        var combinedArea = AABB.combinedPerimeter(index.aabb, leafAABB);\n        var cost = 2 * combinedArea;\n        var inheritanceCost = 2 * (combinedArea - area);\n        var newArea1 = AABB.combinedPerimeter(leafAABB, child1.aabb);\n        var cost1 = newArea1 + inheritanceCost;\n        if (!child1.isLeaf()) {\n          var oldArea = child1.aabb.getPerimeter();\n          cost1 -= oldArea;\n        }\n        var newArea2 = AABB.combinedPerimeter(leafAABB, child2.aabb);\n        var cost2 = newArea2 + inheritanceCost;\n        if (!child2.isLeaf()) {\n          var oldArea = child2.aabb.getPerimeter();\n          cost2 -= oldArea;\n        }\n        if (cost < cost1 && cost < cost2) {\n          break;\n        }\n        if (cost1 < cost2) {\n          index = child1;\n        } else {\n          index = child2;\n        }\n      }\n      var sibling = index;\n      var oldParent = sibling.parent;\n      var newParent = this.allocateNode();\n      newParent.parent = oldParent;\n      newParent.userData = null;\n      newParent.aabb.combine(leafAABB, sibling.aabb);\n      newParent.height = sibling.height + 1;\n      if (oldParent != null) {\n        if (oldParent.child1 === sibling) {\n          oldParent.child1 = newParent;\n        } else {\n          oldParent.child2 = newParent;\n        }\n        newParent.child1 = sibling;\n        newParent.child2 = leaf;\n        sibling.parent = newParent;\n        leaf.parent = newParent;\n      } else {\n        newParent.child1 = sibling;\n        newParent.child2 = leaf;\n        sibling.parent = newParent;\n        leaf.parent = newParent;\n        this.m_root = newParent;\n      }\n      index = leaf.parent;\n      while (index != null) {\n        index = this.balance(index);\n        var child1 = index.child1;\n        var child2 = index.child2;\n        index.height = 1 + math_max$6(child1.height, child2.height);\n        index.aabb.combine(child1.aabb, child2.aabb);\n        index = index.parent;\n      }\n    };\n    DynamicTree2.prototype.removeLeaf = function(leaf) {\n      if (leaf === this.m_root) {\n        this.m_root = null;\n        return;\n      }\n      var parent = leaf.parent;\n      var grandParent = parent.parent;\n      var sibling;\n      if (parent.child1 === leaf) {\n        sibling = parent.child2;\n      } else {\n        sibling = parent.child1;\n      }\n      if (grandParent != null) {\n        if (grandParent.child1 === parent) {\n          grandParent.child1 = sibling;\n        } else {\n          grandParent.child2 = sibling;\n        }\n        sibling.parent = grandParent;\n        this.freeNode(parent);\n        var index = grandParent;\n        while (index != null) {\n          index = this.balance(index);\n          var child1 = index.child1;\n          var child2 = index.child2;\n          index.aabb.combine(child1.aabb, child2.aabb);\n          index.height = 1 + math_max$6(child1.height, child2.height);\n          index = index.parent;\n        }\n      } else {\n        this.m_root = sibling;\n        sibling.parent = null;\n        this.freeNode(parent);\n      }\n    };\n    DynamicTree2.prototype.balance = function(iA) {\n      var A = iA;\n      if (A.isLeaf() || A.height < 2) {\n        return iA;\n      }\n      var B = A.child1;\n      var C = A.child2;\n      var balance = C.height - B.height;\n      if (balance > 1) {\n        var F = C.child1;\n        var G = C.child2;\n        C.child1 = A;\n        C.parent = A.parent;\n        A.parent = C;\n        if (C.parent != null) {\n          if (C.parent.child1 === iA) {\n            C.parent.child1 = C;\n          } else {\n            C.parent.child2 = C;\n          }\n        } else {\n          this.m_root = C;\n        }\n        if (F.height > G.height) {\n          C.child2 = F;\n          A.child2 = G;\n          G.parent = A;\n          A.aabb.combine(B.aabb, G.aabb);\n          C.aabb.combine(A.aabb, F.aabb);\n          A.height = 1 + math_max$6(B.height, G.height);\n          C.height = 1 + math_max$6(A.height, F.height);\n        } else {\n          C.child2 = G;\n          A.child2 = F;\n          F.parent = A;\n          A.aabb.combine(B.aabb, F.aabb);\n          C.aabb.combine(A.aabb, G.aabb);\n          A.height = 1 + math_max$6(B.height, F.height);\n          C.height = 1 + math_max$6(A.height, G.height);\n        }\n        return C;\n      }\n      if (balance < -1) {\n        var D = B.child1;\n        var E = B.child2;\n        B.child1 = A;\n        B.parent = A.parent;\n        A.parent = B;\n        if (B.parent != null) {\n          if (B.parent.child1 === A) {\n            B.parent.child1 = B;\n          } else {\n            B.parent.child2 = B;\n          }\n        } else {\n          this.m_root = B;\n        }\n        if (D.height > E.height) {\n          B.child2 = D;\n          A.child1 = E;\n          E.parent = A;\n          A.aabb.combine(C.aabb, E.aabb);\n          B.aabb.combine(A.aabb, D.aabb);\n          A.height = 1 + math_max$6(C.height, E.height);\n          B.height = 1 + math_max$6(A.height, D.height);\n        } else {\n          B.child2 = E;\n          A.child1 = D;\n          D.parent = A;\n          A.aabb.combine(C.aabb, D.aabb);\n          B.aabb.combine(A.aabb, E.aabb);\n          A.height = 1 + math_max$6(C.height, D.height);\n          B.height = 1 + math_max$6(A.height, E.height);\n        }\n        return B;\n      }\n      return A;\n    };\n    DynamicTree2.prototype.getHeight = function() {\n      if (this.m_root == null) {\n        return 0;\n      }\n      return this.m_root.height;\n    };\n    DynamicTree2.prototype.getAreaRatio = function() {\n      if (this.m_root == null) {\n        return 0;\n      }\n      var root = this.m_root;\n      var rootArea = root.aabb.getPerimeter();\n      var totalArea = 0;\n      var node;\n      var it = this.iteratorPool.allocate().preorder(this.m_root);\n      while (node = it.next()) {\n        if (node.height < 0) {\n          continue;\n        }\n        totalArea += node.aabb.getPerimeter();\n      }\n      this.iteratorPool.release(it);\n      return totalArea / rootArea;\n    };\n    DynamicTree2.prototype.computeHeight = function(id) {\n      var node;\n      if (typeof id !== \"undefined\") {\n        node = this.m_nodes[id];\n      } else {\n        node = this.m_root;\n      }\n      if (node.isLeaf()) {\n        return 0;\n      }\n      var height1 = this.computeHeight(node.child1.id);\n      var height2 = this.computeHeight(node.child2.id);\n      return 1 + math_max$6(height1, height2);\n    };\n    DynamicTree2.prototype.validateStructure = function(node) {\n      if (node == null) {\n        return;\n      }\n      if (node === this.m_root) ;\n      var child1 = node.child1;\n      var child2 = node.child2;\n      if (node.isLeaf()) {\n        return;\n      }\n      this.validateStructure(child1);\n      this.validateStructure(child2);\n    };\n    DynamicTree2.prototype.validateMetrics = function(node) {\n      if (node == null) {\n        return;\n      }\n      var child1 = node.child1;\n      var child2 = node.child2;\n      if (node.isLeaf()) {\n        return;\n      }\n      child1.height;\n      child2.height;\n      var aabb = new AABB();\n      aabb.combine(child1.aabb, child2.aabb);\n      this.validateMetrics(child1);\n      this.validateMetrics(child2);\n    };\n    DynamicTree2.prototype.validate = function() {\n      return;\n    };\n    DynamicTree2.prototype.getMaxBalance = function() {\n      var maxBalance = 0;\n      var node;\n      var it = this.iteratorPool.allocate().preorder(this.m_root);\n      while (node = it.next()) {\n        if (node.height <= 1) {\n          continue;\n        }\n        var balance = math_abs$8(node.child2.height - node.child1.height);\n        maxBalance = math_max$6(maxBalance, balance);\n      }\n      this.iteratorPool.release(it);\n      return maxBalance;\n    };\n    DynamicTree2.prototype.rebuildBottomUp = function() {\n      var nodes = [];\n      var count = 0;\n      var node;\n      var it = this.iteratorPool.allocate().preorder(this.m_root);\n      while (node = it.next()) {\n        if (node.height < 0) {\n          continue;\n        }\n        if (node.isLeaf()) {\n          node.parent = null;\n          nodes[count] = node;\n          ++count;\n        } else {\n          this.freeNode(node);\n        }\n      }\n      this.iteratorPool.release(it);\n      while (count > 1) {\n        var minCost = Infinity;\n        var iMin = -1;\n        var jMin = -1;\n        for (var i = 0; i < count; ++i) {\n          var aabbi = nodes[i].aabb;\n          for (var j = i + 1; j < count; ++j) {\n            var aabbj = nodes[j].aabb;\n            var cost = AABB.combinedPerimeter(aabbi, aabbj);\n            if (cost < minCost) {\n              iMin = i;\n              jMin = j;\n              minCost = cost;\n            }\n          }\n        }\n        var child1 = nodes[iMin];\n        var child2 = nodes[jMin];\n        var parent_1 = this.allocateNode();\n        parent_1.child1 = child1;\n        parent_1.child2 = child2;\n        parent_1.height = 1 + math_max$6(child1.height, child2.height);\n        parent_1.aabb.combine(child1.aabb, child2.aabb);\n        parent_1.parent = null;\n        child1.parent = parent_1;\n        child2.parent = parent_1;\n        nodes[jMin] = nodes[count - 1];\n        nodes[iMin] = parent_1;\n        --count;\n      }\n      this.m_root = nodes[0];\n    };\n    DynamicTree2.prototype.shiftOrigin = function(newOrigin) {\n      var node;\n      var it = this.iteratorPool.allocate().preorder(this.m_root);\n      while (node = it.next()) {\n        var aabb = node.aabb;\n        aabb.lowerBound.x -= newOrigin.x;\n        aabb.lowerBound.y -= newOrigin.y;\n        aabb.upperBound.x -= newOrigin.x;\n        aabb.upperBound.y -= newOrigin.y;\n      }\n      this.iteratorPool.release(it);\n    };\n    DynamicTree2.prototype.query = function(aabb, queryCallback) {\n      var stack = this.stackPool.allocate();\n      stack.push(this.m_root);\n      while (stack.length > 0) {\n        var node = stack.pop();\n        if (node == null) {\n          continue;\n        }\n        if (AABB.testOverlap(node.aabb, aabb)) {\n          if (node.isLeaf()) {\n            var proceed = queryCallback(node.id);\n            if (proceed === false) {\n              return;\n            }\n          } else {\n            stack.push(node.child1);\n            stack.push(node.child2);\n          }\n        }\n      }\n      this.stackPool.release(stack);\n    };\n    DynamicTree2.prototype.rayCast = function(input2, rayCastCallback) {\n      var p1 = input2.p1;\n      var p2 = input2.p2;\n      var r = Vec2.sub(p2, p1);\n      r.normalize();\n      var v3 = Vec2.crossNumVec2(1, r);\n      var abs_v = Vec2.abs(v3);\n      var maxFraction = input2.maxFraction;\n      var segmentAABB = new AABB();\n      var t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n      segmentAABB.combinePoints(p1, t);\n      var stack = this.stackPool.allocate();\n      var subInput = this.inputPool.allocate();\n      stack.push(this.m_root);\n      while (stack.length > 0) {\n        var node = stack.pop();\n        if (node == null) {\n          continue;\n        }\n        if (AABB.testOverlap(node.aabb, segmentAABB) === false) {\n          continue;\n        }\n        var c2 = node.aabb.getCenter();\n        var h = node.aabb.getExtents();\n        var separation = math_abs$8(Vec2.dot(v3, Vec2.sub(p1, c2))) - Vec2.dot(abs_v, h);\n        if (separation > 0) {\n          continue;\n        }\n        if (node.isLeaf()) {\n          subInput.p1 = Vec2.clone(input2.p1);\n          subInput.p2 = Vec2.clone(input2.p2);\n          subInput.maxFraction = maxFraction;\n          var value = rayCastCallback(subInput, node.id);\n          if (value === 0) {\n            break;\n          } else if (value > 0) {\n            maxFraction = value;\n            t = Vec2.combine(1 - maxFraction, p1, maxFraction, p2);\n            segmentAABB.combinePoints(p1, t);\n          }\n        } else {\n          stack.push(node.child1);\n          stack.push(node.child2);\n        }\n      }\n      this.stackPool.release(stack);\n      this.inputPool.release(subInput);\n    };\n    return DynamicTree2;\n  }()\n);\nvar Iterator = (\n  /** @class */\n  function() {\n    function Iterator2() {\n      this.parents = [];\n      this.states = [];\n    }\n    Iterator2.prototype.preorder = function(root) {\n      this.parents.length = 0;\n      this.parents.push(root);\n      this.states.length = 0;\n      this.states.push(0);\n      return this;\n    };\n    Iterator2.prototype.next = function() {\n      while (this.parents.length > 0) {\n        var i = this.parents.length - 1;\n        var node = this.parents[i];\n        if (this.states[i] === 0) {\n          this.states[i] = 1;\n          return node;\n        }\n        if (this.states[i] === 1) {\n          this.states[i] = 2;\n          if (node.child1) {\n            this.parents.push(node.child1);\n            this.states.push(1);\n            return node.child1;\n          }\n        }\n        if (this.states[i] === 2) {\n          this.states[i] = 3;\n          if (node.child2) {\n            this.parents.push(node.child2);\n            this.states.push(1);\n            return node.child2;\n          }\n        }\n        this.parents.pop();\n        this.states.pop();\n      }\n    };\n    Iterator2.prototype.close = function() {\n      this.parents.length = 0;\n    };\n    return Iterator2;\n  }()\n);\nvar math_max$5 = Math.max;\nvar math_min$6 = Math.min;\nvar BroadPhase = (\n  /** @class */\n  function() {\n    function BroadPhase2() {\n      var _this = this;\n      this.m_tree = new DynamicTree();\n      this.m_moveBuffer = [];\n      this.query = function(aabb, queryCallback) {\n        _this.m_tree.query(aabb, queryCallback);\n      };\n      this.queryCallback = function(proxyId) {\n        if (proxyId === _this.m_queryProxyId) {\n          return true;\n        }\n        var proxyIdA = math_min$6(proxyId, _this.m_queryProxyId);\n        var proxyIdB = math_max$5(proxyId, _this.m_queryProxyId);\n        var userDataA = _this.m_tree.getUserData(proxyIdA);\n        var userDataB = _this.m_tree.getUserData(proxyIdB);\n        _this.m_callback(userDataA, userDataB);\n        return true;\n      };\n    }\n    BroadPhase2.prototype.getUserData = function(proxyId) {\n      return this.m_tree.getUserData(proxyId);\n    };\n    BroadPhase2.prototype.testOverlap = function(proxyIdA, proxyIdB) {\n      var aabbA = this.m_tree.getFatAABB(proxyIdA);\n      var aabbB = this.m_tree.getFatAABB(proxyIdB);\n      return AABB.testOverlap(aabbA, aabbB);\n    };\n    BroadPhase2.prototype.getFatAABB = function(proxyId) {\n      return this.m_tree.getFatAABB(proxyId);\n    };\n    BroadPhase2.prototype.getProxyCount = function() {\n      return this.m_moveBuffer.length;\n    };\n    BroadPhase2.prototype.getTreeHeight = function() {\n      return this.m_tree.getHeight();\n    };\n    BroadPhase2.prototype.getTreeBalance = function() {\n      return this.m_tree.getMaxBalance();\n    };\n    BroadPhase2.prototype.getTreeQuality = function() {\n      return this.m_tree.getAreaRatio();\n    };\n    BroadPhase2.prototype.rayCast = function(input2, rayCastCallback) {\n      this.m_tree.rayCast(input2, rayCastCallback);\n    };\n    BroadPhase2.prototype.shiftOrigin = function(newOrigin) {\n      this.m_tree.shiftOrigin(newOrigin);\n    };\n    BroadPhase2.prototype.createProxy = function(aabb, userData) {\n      var proxyId = this.m_tree.createProxy(aabb, userData);\n      this.bufferMove(proxyId);\n      return proxyId;\n    };\n    BroadPhase2.prototype.destroyProxy = function(proxyId) {\n      this.unbufferMove(proxyId);\n      this.m_tree.destroyProxy(proxyId);\n    };\n    BroadPhase2.prototype.moveProxy = function(proxyId, aabb, displacement2) {\n      var changed = this.m_tree.moveProxy(proxyId, aabb, displacement2);\n      if (changed) {\n        this.bufferMove(proxyId);\n      }\n    };\n    BroadPhase2.prototype.touchProxy = function(proxyId) {\n      this.bufferMove(proxyId);\n    };\n    BroadPhase2.prototype.bufferMove = function(proxyId) {\n      this.m_moveBuffer.push(proxyId);\n    };\n    BroadPhase2.prototype.unbufferMove = function(proxyId) {\n      for (var i = 0; i < this.m_moveBuffer.length; ++i) {\n        if (this.m_moveBuffer[i] === proxyId) {\n          this.m_moveBuffer[i] = null;\n        }\n      }\n    };\n    BroadPhase2.prototype.updatePairs = function(addPairCallback) {\n      this.m_callback = addPairCallback;\n      while (this.m_moveBuffer.length > 0) {\n        this.m_queryProxyId = this.m_moveBuffer.pop();\n        if (this.m_queryProxyId === null) {\n          continue;\n        }\n        var fatAABB = this.m_tree.getFatAABB(this.m_queryProxyId);\n        this.m_tree.query(fatAABB, this.queryCallback);\n      }\n    };\n    return BroadPhase2;\n  }()\n);\nvar math_sin$2 = Math.sin;\nvar math_cos$2 = Math.cos;\nvar math_sqrt$4 = Math.sqrt;\nfunction vec2(x2, y) {\n  return { x: x2, y };\n}\nfunction rotation(angle) {\n  return { s: math_sin$2(angle), c: math_cos$2(angle) };\n}\nfunction setVec2(out, x2, y) {\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction copyVec2(out, w) {\n  out.x = w.x;\n  out.y = w.y;\n  return out;\n}\nfunction zeroVec2(out) {\n  out.x = 0;\n  out.y = 0;\n  return out;\n}\nfunction negVec2(out) {\n  out.x = -out.x;\n  out.y = -out.y;\n  return out;\n}\nfunction plusVec2(out, w) {\n  out.x += w.x;\n  out.y += w.y;\n  return out;\n}\nfunction addVec2(out, v3, w) {\n  out.x = v3.x + w.x;\n  out.y = v3.x + w.y;\n  return out;\n}\nfunction minusVec2(out, w) {\n  out.x -= w.x;\n  out.y -= w.y;\n  return out;\n}\nfunction subVec2(out, v3, w) {\n  out.x = v3.x - w.x;\n  out.y = v3.y - w.y;\n  return out;\n}\nfunction mulVec2(out, m) {\n  out.x *= m;\n  out.y *= m;\n  return out;\n}\nfunction scaleVec2(out, m, w) {\n  out.x = m * w.x;\n  out.y = m * w.y;\n  return out;\n}\nfunction plusScaleVec2(out, m, w) {\n  out.x += m * w.x;\n  out.y += m * w.y;\n  return out;\n}\nfunction minusScaleVec2(out, m, w) {\n  out.x -= m * w.x;\n  out.y -= m * w.y;\n  return out;\n}\nfunction combine2Vec2(out, am, a2, bm, b2) {\n  out.x = am * a2.x + bm * b2.x;\n  out.y = am * a2.y + bm * b2.y;\n  return out;\n}\nfunction combine3Vec2(out, am, a2, bm, b2, cm, c2) {\n  out.x = am * a2.x + bm * b2.x + cm * c2.x;\n  out.y = am * a2.y + bm * b2.y + cm * c2.y;\n  return out;\n}\nfunction normalizeVec2Length(out) {\n  var length = math_sqrt$4(out.x * out.x + out.y * out.y);\n  if (length !== 0) {\n    var invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return length;\n}\nfunction normalizeVec2(out) {\n  var length = math_sqrt$4(out.x * out.x + out.y * out.y);\n  if (length > 0) {\n    var invLength = 1 / length;\n    out.x *= invLength;\n    out.y *= invLength;\n  }\n  return out;\n}\nfunction crossVec2Num(out, v3, w) {\n  var x2 = w * v3.y;\n  var y = -w * v3.x;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction crossNumVec2(out, w, v3) {\n  var x2 = -w * v3.y;\n  var y = w * v3.x;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction crossVec2Vec2(a2, b2) {\n  return a2.x * b2.y - a2.y * b2.x;\n}\nfunction dotVec2(a2, b2) {\n  return a2.x * b2.x + a2.y * b2.y;\n}\nfunction lengthSqrVec2(a2) {\n  return a2.x * a2.x + a2.y * a2.y;\n}\nfunction distVec2(a2, b2) {\n  var dx = a2.x - b2.x;\n  var dy = a2.y - b2.y;\n  return math_sqrt$4(dx * dx + dy * dy);\n}\nfunction distSqrVec2(a2, b2) {\n  var dx = a2.x - b2.x;\n  var dy = a2.y - b2.y;\n  return dx * dx + dy * dy;\n}\nfunction setRotAngle(out, a2) {\n  out.c = math_cos$2(a2);\n  out.s = math_sin$2(a2);\n  return out;\n}\nfunction rotVec2(out, q, v3) {\n  out.x = q.c * v3.x - q.s * v3.y;\n  out.y = q.s * v3.x + q.c * v3.y;\n  return out;\n}\nfunction derotVec2(out, q, v3) {\n  var x2 = q.c * v3.x + q.s * v3.y;\n  var y = -q.s * v3.x + q.c * v3.y;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction rerotVec2(out, before, after, v3) {\n  var x0 = before.c * v3.x + before.s * v3.y;\n  var y0 = -before.s * v3.x + before.c * v3.y;\n  var x2 = after.c * x0 - after.s * y0;\n  var y = after.s * x0 + after.c * y0;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction transform(x2, y, a2) {\n  return { p: vec2(x2, y), q: rotation(a2) };\n}\nfunction copyTransform(out, transform2) {\n  out.p.x = transform2.p.x;\n  out.p.y = transform2.p.y;\n  out.q.s = transform2.q.s;\n  out.q.c = transform2.q.c;\n  return out;\n}\nfunction transformVec2(out, xf2, v3) {\n  var x2 = xf2.q.c * v3.x - xf2.q.s * v3.y + xf2.p.x;\n  var y = xf2.q.s * v3.x + xf2.q.c * v3.y + xf2.p.y;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction detransformVec2(out, xf2, v3) {\n  var px = v3.x - xf2.p.x;\n  var py = v3.y - xf2.p.y;\n  var x2 = xf2.q.c * px + xf2.q.s * py;\n  var y = -xf2.q.s * px + xf2.q.c * py;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction retransformVec2(out, from, to, v3) {\n  var x0 = from.q.c * v3.x - from.q.s * v3.y + from.p.x;\n  var y0 = from.q.s * v3.x + from.q.c * v3.y + from.p.y;\n  var px = x0 - to.p.x;\n  var py = y0 - to.p.y;\n  var x2 = to.q.c * px + to.q.s * py;\n  var y = -to.q.s * px + to.q.c * py;\n  out.x = x2;\n  out.y = y;\n  return out;\n}\nfunction detransformTransform(out, a2, b2) {\n  var c2 = a2.q.c * b2.q.c + a2.q.s * b2.q.s;\n  var s2 = a2.q.c * b2.q.s - a2.q.s * b2.q.c;\n  var x2 = a2.q.c * (b2.p.x - a2.p.x) + a2.q.s * (b2.p.y - a2.p.y);\n  var y = -a2.q.s * (b2.p.x - a2.p.x) + a2.q.c * (b2.p.y - a2.p.y);\n  out.q.c = c2;\n  out.q.s = s2;\n  out.p.x = x2;\n  out.p.y = y;\n  return out;\n}\nvar math_sin$1 = Math.sin;\nvar math_cos$1 = Math.cos;\nvar math_atan2$1 = Math.atan2;\nvar Rot = (\n  /** @class */\n  function() {\n    function Rot2(angle) {\n      if (!(this instanceof Rot2)) {\n        return new Rot2(angle);\n      }\n      if (typeof angle === \"number\") {\n        this.setAngle(angle);\n      } else if (typeof angle === \"object\") {\n        this.setRot(angle);\n      } else {\n        this.setIdentity();\n      }\n    }\n    Rot2.neo = function(angle) {\n      var obj = Object.create(Rot2.prototype);\n      obj.setAngle(angle);\n      return obj;\n    };\n    Rot2.clone = function(rot) {\n      var obj = Object.create(Rot2.prototype);\n      obj.s = rot.s;\n      obj.c = rot.c;\n      return obj;\n    };\n    Rot2.identity = function() {\n      var obj = Object.create(Rot2.prototype);\n      obj.s = 0;\n      obj.c = 1;\n      return obj;\n    };\n    Rot2.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Number.isFinite(obj.s) && Number.isFinite(obj.c);\n    };\n    Rot2.assert = function(o) {\n    };\n    Rot2.prototype.setIdentity = function() {\n      this.s = 0;\n      this.c = 1;\n    };\n    Rot2.prototype.set = function(angle) {\n      if (typeof angle === \"object\") {\n        this.s = angle.s;\n        this.c = angle.c;\n      } else {\n        this.s = math_sin$1(angle);\n        this.c = math_cos$1(angle);\n      }\n    };\n    Rot2.prototype.setRot = function(angle) {\n      this.s = angle.s;\n      this.c = angle.c;\n    };\n    Rot2.prototype.setAngle = function(angle) {\n      this.s = math_sin$1(angle);\n      this.c = math_cos$1(angle);\n    };\n    Rot2.prototype.getAngle = function() {\n      return math_atan2$1(this.s, this.c);\n    };\n    Rot2.prototype.getXAxis = function() {\n      return Vec2.neo(this.c, this.s);\n    };\n    Rot2.prototype.getYAxis = function() {\n      return Vec2.neo(-this.s, this.c);\n    };\n    Rot2.mul = function(rot, m) {\n      if (\"c\" in m && \"s\" in m) {\n        var qr = Rot2.identity();\n        qr.s = rot.s * m.c + rot.c * m.s;\n        qr.c = rot.c * m.c - rot.s * m.s;\n        return qr;\n      } else if (\"x\" in m && \"y\" in m) {\n        return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n      }\n    };\n    Rot2.mulRot = function(rot, m) {\n      var qr = Rot2.identity();\n      qr.s = rot.s * m.c + rot.c * m.s;\n      qr.c = rot.c * m.c - rot.s * m.s;\n      return qr;\n    };\n    Rot2.mulVec2 = function(rot, m) {\n      return Vec2.neo(rot.c * m.x - rot.s * m.y, rot.s * m.x + rot.c * m.y);\n    };\n    Rot2.mulSub = function(rot, v3, w) {\n      var x2 = rot.c * (v3.x - w.x) - rot.s * (v3.y - w.y);\n      var y = rot.s * (v3.x - w.x) + rot.c * (v3.y - w.y);\n      return Vec2.neo(x2, y);\n    };\n    Rot2.mulT = function(rot, m) {\n      if (\"c\" in m && \"s\" in m) {\n        var qr = Rot2.identity();\n        qr.s = rot.c * m.s - rot.s * m.c;\n        qr.c = rot.c * m.c + rot.s * m.s;\n        return qr;\n      } else if (\"x\" in m && \"y\" in m) {\n        return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n      }\n    };\n    Rot2.mulTRot = function(rot, m) {\n      var qr = Rot2.identity();\n      qr.s = rot.c * m.s - rot.s * m.c;\n      qr.c = rot.c * m.c + rot.s * m.s;\n      return qr;\n    };\n    Rot2.mulTVec2 = function(rot, m) {\n      return Vec2.neo(rot.c * m.x + rot.s * m.y, -rot.s * m.x + rot.c * m.y);\n    };\n    return Rot2;\n  }()\n);\nvar math_atan2 = Math.atan2;\nvar math_PI$5 = Math.PI;\nvar temp$7 = vec2(0, 0);\nvar Sweep = (\n  /** @class */\n  function() {\n    function Sweep2() {\n      this.localCenter = Vec2.zero();\n      this.c = Vec2.zero();\n      this.a = 0;\n      this.alpha0 = 0;\n      this.c0 = Vec2.zero();\n      this.a0 = 0;\n    }\n    Sweep2.prototype.recycle = function() {\n      zeroVec2(this.localCenter);\n      zeroVec2(this.c);\n      this.a = 0;\n      this.alpha0 = 0;\n      zeroVec2(this.c0);\n      this.a0 = 0;\n    };\n    Sweep2.prototype.setTransform = function(xf2) {\n      transformVec2(temp$7, xf2, this.localCenter);\n      copyVec2(this.c, temp$7);\n      copyVec2(this.c0, temp$7);\n      this.a = this.a0 = math_atan2(xf2.q.s, xf2.q.c);\n    };\n    Sweep2.prototype.setLocalCenter = function(localCenter2, xf2) {\n      copyVec2(this.localCenter, localCenter2);\n      transformVec2(temp$7, xf2, this.localCenter);\n      copyVec2(this.c, temp$7);\n      copyVec2(this.c0, temp$7);\n    };\n    Sweep2.prototype.getTransform = function(xf2, beta) {\n      if (beta === void 0) {\n        beta = 0;\n      }\n      setRotAngle(xf2.q, (1 - beta) * this.a0 + beta * this.a);\n      combine2Vec2(xf2.p, 1 - beta, this.c0, beta, this.c);\n      minusVec2(xf2.p, rotVec2(temp$7, xf2.q, this.localCenter));\n    };\n    Sweep2.prototype.advance = function(alpha) {\n      var beta = (alpha - this.alpha0) / (1 - this.alpha0);\n      combine2Vec2(this.c0, beta, this.c, 1 - beta, this.c0);\n      this.a0 = beta * this.a + (1 - beta) * this.a0;\n      this.alpha0 = alpha;\n    };\n    Sweep2.prototype.forward = function() {\n      this.a0 = this.a;\n      copyVec2(this.c0, this.c);\n    };\n    Sweep2.prototype.normalize = function() {\n      var a0 = mod(this.a0, -math_PI$5, +math_PI$5);\n      this.a -= this.a0 - a0;\n      this.a0 = a0;\n    };\n    Sweep2.prototype.set = function(that) {\n      copyVec2(this.localCenter, that.localCenter);\n      copyVec2(this.c, that.c);\n      this.a = that.a;\n      this.alpha0 = that.alpha0;\n      copyVec2(this.c0, that.c0);\n      this.a0 = that.a0;\n    };\n    return Sweep2;\n  }()\n);\nvar Transform = (\n  /** @class */\n  function() {\n    function Transform2(position, rotation2) {\n      if (!(this instanceof Transform2)) {\n        return new Transform2(position, rotation2);\n      }\n      this.p = Vec2.zero();\n      this.q = Rot.identity();\n      if (typeof position !== \"undefined\") {\n        this.p.setVec2(position);\n      }\n      if (typeof rotation2 !== \"undefined\") {\n        this.q.setAngle(rotation2);\n      }\n    }\n    Transform2.clone = function(xf2) {\n      var obj = Object.create(Transform2.prototype);\n      obj.p = Vec2.clone(xf2.p);\n      obj.q = Rot.clone(xf2.q);\n      return obj;\n    };\n    Transform2.neo = function(position, rotation2) {\n      var obj = Object.create(Transform2.prototype);\n      obj.p = Vec2.clone(position);\n      obj.q = Rot.clone(rotation2);\n      return obj;\n    };\n    Transform2.identity = function() {\n      var obj = Object.create(Transform2.prototype);\n      obj.p = Vec2.zero();\n      obj.q = Rot.identity();\n      return obj;\n    };\n    Transform2.prototype.setIdentity = function() {\n      this.p.setZero();\n      this.q.setIdentity();\n    };\n    Transform2.prototype.set = function(a2, b2) {\n      if (typeof b2 === \"undefined\") {\n        this.p.set(a2.p);\n        this.q.set(a2.q);\n      } else {\n        this.p.set(a2);\n        this.q.set(b2);\n      }\n    };\n    Transform2.prototype.setNum = function(position, rotation2) {\n      this.p.setVec2(position);\n      this.q.setAngle(rotation2);\n    };\n    Transform2.prototype.setTransform = function(xf2) {\n      this.p.setVec2(xf2.p);\n      this.q.setRot(xf2.q);\n    };\n    Transform2.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Vec2.isValid(obj.p) && Rot.isValid(obj.q);\n    };\n    Transform2.assert = function(o) {\n    };\n    Transform2.mul = function(a2, b2) {\n      if (Array.isArray(b2)) {\n        var arr = [];\n        for (var i = 0; i < b2.length; i++) {\n          arr[i] = Transform2.mul(a2, b2[i]);\n        }\n        return arr;\n      } else if (\"x\" in b2 && \"y\" in b2) {\n        return Transform2.mulVec2(a2, b2);\n      } else if (\"p\" in b2 && \"q\" in b2) {\n        return Transform2.mulXf(a2, b2);\n      }\n    };\n    Transform2.mulAll = function(a2, b2) {\n      var arr = [];\n      for (var i = 0; i < b2.length; i++) {\n        arr[i] = Transform2.mul(a2, b2[i]);\n      }\n      return arr;\n    };\n    Transform2.mulFn = function(a2) {\n      return function(b2) {\n        return Transform2.mul(a2, b2);\n      };\n    };\n    Transform2.mulVec2 = function(a2, b2) {\n      var x2 = a2.q.c * b2.x - a2.q.s * b2.y + a2.p.x;\n      var y = a2.q.s * b2.x + a2.q.c * b2.y + a2.p.y;\n      return Vec2.neo(x2, y);\n    };\n    Transform2.mulXf = function(a2, b2) {\n      var xf2 = Transform2.identity();\n      xf2.q = Rot.mulRot(a2.q, b2.q);\n      xf2.p = Vec2.add(Rot.mulVec2(a2.q, b2.p), a2.p);\n      return xf2;\n    };\n    Transform2.mulT = function(a2, b2) {\n      if (\"x\" in b2 && \"y\" in b2) {\n        return Transform2.mulTVec2(a2, b2);\n      } else if (\"p\" in b2 && \"q\" in b2) {\n        return Transform2.mulTXf(a2, b2);\n      }\n    };\n    Transform2.mulTVec2 = function(a2, b2) {\n      var px = b2.x - a2.p.x;\n      var py = b2.y - a2.p.y;\n      var x2 = a2.q.c * px + a2.q.s * py;\n      var y = -a2.q.s * px + a2.q.c * py;\n      return Vec2.neo(x2, y);\n    };\n    Transform2.mulTXf = function(a2, b2) {\n      var xf2 = Transform2.identity();\n      xf2.q.setRot(Rot.mulTRot(a2.q, b2.q));\n      xf2.p.setVec2(Rot.mulTVec2(a2.q, Vec2.sub(b2.p, a2.p)));\n      return xf2;\n    };\n    return Transform2;\n  }()\n);\nvar Velocity = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function Velocity2() {\n      this.v = Vec2.zero();\n      this.w = 0;\n    }\n    return Velocity2;\n  }()\n);\nvar math_sin = Math.sin;\nvar math_cos = Math.cos;\nvar Position = (\n  /** @class */\n  function() {\n    function Position2() {\n      this.c = Vec2.zero();\n      this.a = 0;\n    }\n    Position2.prototype.getTransform = function(xf2, p) {\n      xf2.q.c = math_cos(this.a);\n      xf2.q.s = math_sin(this.a);\n      xf2.p.x = this.c.x - (xf2.q.c * p.x - xf2.q.s * p.y);\n      xf2.p.y = this.c.y - (xf2.q.s * p.x + xf2.q.c * p.y);\n      return xf2;\n    };\n    return Position2;\n  }()\n);\nfunction getTransform(xf2, p, c2, a2) {\n  xf2.q.c = math_cos(a2);\n  xf2.q.s = math_sin(a2);\n  xf2.p.x = c2.x - (xf2.q.c * p.x - xf2.q.s * p.y);\n  xf2.p.y = c2.y - (xf2.q.s * p.x + xf2.q.c * p.y);\n  return xf2;\n}\nvar Shape = (\n  /** @class */\n  function() {\n    function Shape2() {\n      this.style = {};\n      this.appData = {};\n    }\n    Shape2.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return typeof obj.m_type === \"string\" && typeof obj.m_radius === \"number\";\n    };\n    return Shape2;\n  }()\n);\nvar synchronize_aabb1 = new AABB();\nvar synchronize_aabb2 = new AABB();\nvar displacement = vec2(0, 0);\nvar FixtureDefDefault = {\n  userData: null,\n  friction: 0.2,\n  restitution: 0,\n  density: 0,\n  isSensor: false,\n  filterGroupIndex: 0,\n  filterCategoryBits: 1,\n  filterMaskBits: 65535\n};\nvar FixtureProxy = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function FixtureProxy2(fixture, childIndex) {\n      this.aabb = new AABB();\n      this.fixture = fixture;\n      this.childIndex = childIndex;\n    }\n    return FixtureProxy2;\n  }()\n);\nvar Fixture = (\n  /** @class */\n  function() {\n    function Fixture2(body, shape, def) {\n      this.style = {};\n      this.appData = {};\n      if (shape.shape) {\n        def = shape;\n        shape = shape.shape;\n      } else if (typeof def === \"number\") {\n        def = { density: def };\n      }\n      def = options(def, FixtureDefDefault);\n      this.m_body = body;\n      this.m_friction = def.friction;\n      this.m_restitution = def.restitution;\n      this.m_density = def.density;\n      this.m_isSensor = def.isSensor;\n      this.m_filterGroupIndex = def.filterGroupIndex;\n      this.m_filterCategoryBits = def.filterCategoryBits;\n      this.m_filterMaskBits = def.filterMaskBits;\n      this.m_shape = shape;\n      this.m_next = null;\n      this.m_proxies = [];\n      this.m_proxyCount = 0;\n      var childCount = this.m_shape.getChildCount();\n      for (var i = 0; i < childCount; ++i) {\n        this.m_proxies[i] = new FixtureProxy(this, i);\n      }\n      this.m_userData = def.userData;\n      if (typeof def.style === \"object\" && def.style !== null) {\n        this.style = def.style;\n      }\n    }\n    Fixture2.prototype._reset = function() {\n      var body = this.getBody();\n      var broadPhase = body.m_world.m_broadPhase;\n      this.destroyProxies(broadPhase);\n      if (this.m_shape._reset) {\n        this.m_shape._reset();\n      }\n      var childCount = this.m_shape.getChildCount();\n      for (var i = 0; i < childCount; ++i) {\n        this.m_proxies[i] = new FixtureProxy(this, i);\n      }\n      this.createProxies(broadPhase, body.m_xf);\n      body.resetMassData();\n    };\n    Fixture2.prototype._serialize = function() {\n      return {\n        friction: this.m_friction,\n        restitution: this.m_restitution,\n        density: this.m_density,\n        isSensor: this.m_isSensor,\n        filterGroupIndex: this.m_filterGroupIndex,\n        filterCategoryBits: this.m_filterCategoryBits,\n        filterMaskBits: this.m_filterMaskBits,\n        shape: this.m_shape\n      };\n    };\n    Fixture2._deserialize = function(data, body, restore) {\n      var shape = restore(Shape, data.shape);\n      var fixture = shape && new Fixture2(body, shape, data);\n      return fixture;\n    };\n    Fixture2.prototype.getType = function() {\n      return this.m_shape.m_type;\n    };\n    Fixture2.prototype.getShape = function() {\n      return this.m_shape;\n    };\n    Fixture2.prototype.isSensor = function() {\n      return this.m_isSensor;\n    };\n    Fixture2.prototype.setSensor = function(sensor) {\n      if (sensor != this.m_isSensor) {\n        this.m_body.setAwake(true);\n        this.m_isSensor = sensor;\n      }\n    };\n    Fixture2.prototype.getUserData = function() {\n      return this.m_userData;\n    };\n    Fixture2.prototype.setUserData = function(data) {\n      this.m_userData = data;\n    };\n    Fixture2.prototype.getBody = function() {\n      return this.m_body;\n    };\n    Fixture2.prototype.getNext = function() {\n      return this.m_next;\n    };\n    Fixture2.prototype.getDensity = function() {\n      return this.m_density;\n    };\n    Fixture2.prototype.setDensity = function(density) {\n      this.m_density = density;\n    };\n    Fixture2.prototype.getFriction = function() {\n      return this.m_friction;\n    };\n    Fixture2.prototype.setFriction = function(friction) {\n      this.m_friction = friction;\n    };\n    Fixture2.prototype.getRestitution = function() {\n      return this.m_restitution;\n    };\n    Fixture2.prototype.setRestitution = function(restitution) {\n      this.m_restitution = restitution;\n    };\n    Fixture2.prototype.testPoint = function(p) {\n      return this.m_shape.testPoint(this.m_body.getTransform(), p);\n    };\n    Fixture2.prototype.rayCast = function(output2, input2, childIndex) {\n      return this.m_shape.rayCast(output2, input2, this.m_body.getTransform(), childIndex);\n    };\n    Fixture2.prototype.getMassData = function(massData) {\n      this.m_shape.computeMass(massData, this.m_density);\n    };\n    Fixture2.prototype.getAABB = function(childIndex) {\n      return this.m_proxies[childIndex].aabb;\n    };\n    Fixture2.prototype.createProxies = function(broadPhase, xf2) {\n      this.m_proxyCount = this.m_shape.getChildCount();\n      for (var i = 0; i < this.m_proxyCount; ++i) {\n        var proxy = this.m_proxies[i];\n        this.m_shape.computeAABB(proxy.aabb, xf2, i);\n        proxy.proxyId = broadPhase.createProxy(proxy.aabb, proxy);\n      }\n    };\n    Fixture2.prototype.destroyProxies = function(broadPhase) {\n      for (var i = 0; i < this.m_proxyCount; ++i) {\n        var proxy = this.m_proxies[i];\n        broadPhase.destroyProxy(proxy.proxyId);\n        proxy.proxyId = null;\n      }\n      this.m_proxyCount = 0;\n    };\n    Fixture2.prototype.synchronize = function(broadPhase, xf1, xf2) {\n      for (var i = 0; i < this.m_proxyCount; ++i) {\n        var proxy = this.m_proxies[i];\n        this.m_shape.computeAABB(synchronize_aabb1, xf1, proxy.childIndex);\n        this.m_shape.computeAABB(synchronize_aabb2, xf2, proxy.childIndex);\n        proxy.aabb.combine(synchronize_aabb1, synchronize_aabb2);\n        subVec2(displacement, xf2.p, xf1.p);\n        broadPhase.moveProxy(proxy.proxyId, proxy.aabb, displacement);\n      }\n    };\n    Fixture2.prototype.setFilterData = function(filter) {\n      this.m_filterGroupIndex = filter.groupIndex;\n      this.m_filterCategoryBits = filter.categoryBits;\n      this.m_filterMaskBits = filter.maskBits;\n      this.refilter();\n    };\n    Fixture2.prototype.getFilterGroupIndex = function() {\n      return this.m_filterGroupIndex;\n    };\n    Fixture2.prototype.setFilterGroupIndex = function(groupIndex) {\n      this.m_filterGroupIndex = groupIndex;\n      this.refilter();\n    };\n    Fixture2.prototype.getFilterCategoryBits = function() {\n      return this.m_filterCategoryBits;\n    };\n    Fixture2.prototype.setFilterCategoryBits = function(categoryBits) {\n      this.m_filterCategoryBits = categoryBits;\n      this.refilter();\n    };\n    Fixture2.prototype.getFilterMaskBits = function() {\n      return this.m_filterMaskBits;\n    };\n    Fixture2.prototype.setFilterMaskBits = function(maskBits) {\n      this.m_filterMaskBits = maskBits;\n      this.refilter();\n    };\n    Fixture2.prototype.refilter = function() {\n      if (this.m_body == null) {\n        return;\n      }\n      var edge = this.m_body.getContactList();\n      while (edge) {\n        var contact = edge.contact;\n        var fixtureA = contact.getFixtureA();\n        var fixtureB = contact.getFixtureB();\n        if (fixtureA == this || fixtureB == this) {\n          contact.flagForFiltering();\n        }\n        edge = edge.next;\n      }\n      var world = this.m_body.getWorld();\n      if (world == null) {\n        return;\n      }\n      var broadPhase = world.m_broadPhase;\n      for (var i = 0; i < this.m_proxyCount; ++i) {\n        broadPhase.touchProxy(this.m_proxies[i].proxyId);\n      }\n    };\n    Fixture2.prototype.shouldCollide = function(that) {\n      if (that.m_filterGroupIndex === this.m_filterGroupIndex && that.m_filterGroupIndex !== 0) {\n        return that.m_filterGroupIndex > 0;\n      }\n      var collideA = (that.m_filterMaskBits & this.m_filterCategoryBits) !== 0;\n      var collideB = (that.m_filterCategoryBits & this.m_filterMaskBits) !== 0;\n      var collide = collideA && collideB;\n      return collide;\n    };\n    return Fixture2;\n  }()\n);\nvar STATIC = \"static\";\nvar KINEMATIC = \"kinematic\";\nvar DYNAMIC = \"dynamic\";\nvar oldCenter = vec2(0, 0);\nvar localCenter = vec2(0, 0);\nvar shift = vec2(0, 0);\nvar temp$6 = vec2(0, 0);\nvar xf$2 = transform(0, 0, 0);\nvar BodyDefDefault = {\n  type: STATIC,\n  position: Vec2.zero(),\n  angle: 0,\n  linearVelocity: Vec2.zero(),\n  angularVelocity: 0,\n  linearDamping: 0,\n  angularDamping: 0,\n  fixedRotation: false,\n  bullet: false,\n  gravityScale: 1,\n  allowSleep: true,\n  awake: true,\n  active: true,\n  userData: null\n};\nvar Body = (\n  /** @class */\n  function() {\n    function Body2(world, def) {\n      this.style = {};\n      this.appData = {};\n      def = options(def, BodyDefDefault);\n      this.m_world = world;\n      this.m_awakeFlag = def.awake;\n      this.m_autoSleepFlag = def.allowSleep;\n      this.m_bulletFlag = def.bullet;\n      this.m_fixedRotationFlag = def.fixedRotation;\n      this.m_activeFlag = def.active;\n      this.m_islandFlag = false;\n      this.m_toiFlag = false;\n      this.m_userData = def.userData;\n      this.m_type = def.type;\n      if (this.m_type == DYNAMIC) {\n        this.m_mass = 1;\n        this.m_invMass = 1;\n      } else {\n        this.m_mass = 0;\n        this.m_invMass = 0;\n      }\n      this.m_I = 0;\n      this.m_invI = 0;\n      this.m_xf = Transform.identity();\n      this.m_xf.p.setVec2(def.position);\n      this.m_xf.q.setAngle(def.angle);\n      this.m_sweep = new Sweep();\n      this.m_sweep.setTransform(this.m_xf);\n      this.c_velocity = new Velocity();\n      this.c_position = new Position();\n      this.m_force = Vec2.zero();\n      this.m_torque = 0;\n      this.m_linearVelocity = Vec2.clone(def.linearVelocity);\n      this.m_angularVelocity = def.angularVelocity;\n      this.m_linearDamping = def.linearDamping;\n      this.m_angularDamping = def.angularDamping;\n      this.m_gravityScale = def.gravityScale;\n      this.m_sleepTime = 0;\n      this.m_jointList = null;\n      this.m_contactList = null;\n      this.m_fixtureList = null;\n      this.m_prev = null;\n      this.m_next = null;\n      this.m_destroyed = false;\n      if (typeof def.style === \"object\" && def.style !== null) {\n        this.style = def.style;\n      }\n    }\n    Body2.prototype._serialize = function() {\n      var fixtures = [];\n      for (var f = this.m_fixtureList; f; f = f.m_next) {\n        fixtures.push(f);\n      }\n      return {\n        type: this.m_type,\n        bullet: this.m_bulletFlag,\n        position: this.m_xf.p,\n        angle: this.m_xf.q.getAngle(),\n        linearVelocity: this.m_linearVelocity,\n        angularVelocity: this.m_angularVelocity,\n        fixtures\n      };\n    };\n    Body2._deserialize = function(data, world, restore) {\n      var body = new Body2(world, data);\n      if (data.fixtures) {\n        for (var i = data.fixtures.length - 1; i >= 0; i--) {\n          var fixture = restore(Fixture, data.fixtures[i], body);\n          body._addFixture(fixture);\n        }\n      }\n      return body;\n    };\n    Body2.prototype.isWorldLocked = function() {\n      return this.m_world && this.m_world.isLocked() ? true : false;\n    };\n    Body2.prototype.getWorld = function() {\n      return this.m_world;\n    };\n    Body2.prototype.getNext = function() {\n      return this.m_next;\n    };\n    Body2.prototype.setUserData = function(data) {\n      this.m_userData = data;\n    };\n    Body2.prototype.getUserData = function() {\n      return this.m_userData;\n    };\n    Body2.prototype.getFixtureList = function() {\n      return this.m_fixtureList;\n    };\n    Body2.prototype.getJointList = function() {\n      return this.m_jointList;\n    };\n    Body2.prototype.getContactList = function() {\n      return this.m_contactList;\n    };\n    Body2.prototype.isStatic = function() {\n      return this.m_type == STATIC;\n    };\n    Body2.prototype.isDynamic = function() {\n      return this.m_type == DYNAMIC;\n    };\n    Body2.prototype.isKinematic = function() {\n      return this.m_type == KINEMATIC;\n    };\n    Body2.prototype.setStatic = function() {\n      this.setType(STATIC);\n      return this;\n    };\n    Body2.prototype.setDynamic = function() {\n      this.setType(DYNAMIC);\n      return this;\n    };\n    Body2.prototype.setKinematic = function() {\n      this.setType(KINEMATIC);\n      return this;\n    };\n    Body2.prototype.getType = function() {\n      return this.m_type;\n    };\n    Body2.prototype.setType = function(type) {\n      if (this.isWorldLocked() == true) {\n        return;\n      }\n      if (this.m_type == type) {\n        return;\n      }\n      this.m_type = type;\n      this.resetMassData();\n      if (this.m_type == STATIC) {\n        this.m_linearVelocity.setZero();\n        this.m_angularVelocity = 0;\n        this.m_sweep.forward();\n        this.synchronizeFixtures();\n      }\n      this.setAwake(true);\n      this.m_force.setZero();\n      this.m_torque = 0;\n      var ce = this.m_contactList;\n      while (ce) {\n        var ce0 = ce;\n        ce = ce.next;\n        this.m_world.destroyContact(ce0.contact);\n      }\n      this.m_contactList = null;\n      var broadPhase = this.m_world.m_broadPhase;\n      for (var f = this.m_fixtureList; f; f = f.m_next) {\n        for (var i = 0; i < f.m_proxyCount; ++i) {\n          broadPhase.touchProxy(f.m_proxies[i].proxyId);\n        }\n      }\n    };\n    Body2.prototype.isBullet = function() {\n      return this.m_bulletFlag;\n    };\n    Body2.prototype.setBullet = function(flag) {\n      this.m_bulletFlag = !!flag;\n    };\n    Body2.prototype.isSleepingAllowed = function() {\n      return this.m_autoSleepFlag;\n    };\n    Body2.prototype.setSleepingAllowed = function(flag) {\n      this.m_autoSleepFlag = !!flag;\n      if (this.m_autoSleepFlag == false) {\n        this.setAwake(true);\n      }\n    };\n    Body2.prototype.isAwake = function() {\n      return this.m_awakeFlag;\n    };\n    Body2.prototype.setAwake = function(flag) {\n      if (flag) {\n        this.m_awakeFlag = true;\n        this.m_sleepTime = 0;\n      } else {\n        this.m_awakeFlag = false;\n        this.m_sleepTime = 0;\n        this.m_linearVelocity.setZero();\n        this.m_angularVelocity = 0;\n        this.m_force.setZero();\n        this.m_torque = 0;\n      }\n    };\n    Body2.prototype.isActive = function() {\n      return this.m_activeFlag;\n    };\n    Body2.prototype.setActive = function(flag) {\n      if (flag == this.m_activeFlag) {\n        return;\n      }\n      this.m_activeFlag = !!flag;\n      if (this.m_activeFlag) {\n        var broadPhase = this.m_world.m_broadPhase;\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          f.createProxies(broadPhase, this.m_xf);\n        }\n        this.m_world.m_newFixture = true;\n      } else {\n        var broadPhase = this.m_world.m_broadPhase;\n        for (var f = this.m_fixtureList; f; f = f.m_next) {\n          f.destroyProxies(broadPhase);\n        }\n        var ce = this.m_contactList;\n        while (ce) {\n          var ce0 = ce;\n          ce = ce.next;\n          this.m_world.destroyContact(ce0.contact);\n        }\n        this.m_contactList = null;\n      }\n    };\n    Body2.prototype.isFixedRotation = function() {\n      return this.m_fixedRotationFlag;\n    };\n    Body2.prototype.setFixedRotation = function(flag) {\n      if (this.m_fixedRotationFlag == flag) {\n        return;\n      }\n      this.m_fixedRotationFlag = !!flag;\n      this.m_angularVelocity = 0;\n      this.resetMassData();\n    };\n    Body2.prototype.getTransform = function() {\n      return this.m_xf;\n    };\n    Body2.prototype.setTransform = function(a2, b2) {\n      if (this.isWorldLocked() == true) {\n        return;\n      }\n      if (typeof b2 === \"number\") {\n        this.m_xf.setNum(a2, b2);\n      } else {\n        this.m_xf.setTransform(a2);\n      }\n      this.m_sweep.setTransform(this.m_xf);\n      var broadPhase = this.m_world.m_broadPhase;\n      for (var f = this.m_fixtureList; f; f = f.m_next) {\n        f.synchronize(broadPhase, this.m_xf, this.m_xf);\n      }\n      this.setAwake(true);\n    };\n    Body2.prototype.synchronizeTransform = function() {\n      this.m_sweep.getTransform(this.m_xf, 1);\n    };\n    Body2.prototype.synchronizeFixtures = function() {\n      this.m_sweep.getTransform(xf$2, 0);\n      var broadPhase = this.m_world.m_broadPhase;\n      for (var f = this.m_fixtureList; f; f = f.m_next) {\n        f.synchronize(broadPhase, xf$2, this.m_xf);\n      }\n    };\n    Body2.prototype.advance = function(alpha) {\n      this.m_sweep.advance(alpha);\n      copyVec2(this.m_sweep.c, this.m_sweep.c0);\n      this.m_sweep.a = this.m_sweep.a0;\n      this.m_sweep.getTransform(this.m_xf, 1);\n    };\n    Body2.prototype.getPosition = function() {\n      return this.m_xf.p;\n    };\n    Body2.prototype.setPosition = function(p) {\n      this.setTransform(p, this.m_sweep.a);\n    };\n    Body2.prototype.getAngle = function() {\n      return this.m_sweep.a;\n    };\n    Body2.prototype.setAngle = function(angle) {\n      this.setTransform(this.m_xf.p, angle);\n    };\n    Body2.prototype.getWorldCenter = function() {\n      return this.m_sweep.c;\n    };\n    Body2.prototype.getLocalCenter = function() {\n      return this.m_sweep.localCenter;\n    };\n    Body2.prototype.getLinearVelocity = function() {\n      return this.m_linearVelocity;\n    };\n    Body2.prototype.getLinearVelocityFromWorldPoint = function(worldPoint) {\n      var localCenter2 = Vec2.sub(worldPoint, this.m_sweep.c);\n      return Vec2.add(this.m_linearVelocity, Vec2.crossNumVec2(this.m_angularVelocity, localCenter2));\n    };\n    Body2.prototype.getLinearVelocityFromLocalPoint = function(localPoint) {\n      return this.getLinearVelocityFromWorldPoint(this.getWorldPoint(localPoint));\n    };\n    Body2.prototype.setLinearVelocity = function(v3) {\n      if (this.m_type == STATIC) {\n        return;\n      }\n      if (Vec2.dot(v3, v3) > 0) {\n        this.setAwake(true);\n      }\n      this.m_linearVelocity.setVec2(v3);\n    };\n    Body2.prototype.getAngularVelocity = function() {\n      return this.m_angularVelocity;\n    };\n    Body2.prototype.setAngularVelocity = function(w) {\n      if (this.m_type == STATIC) {\n        return;\n      }\n      if (w * w > 0) {\n        this.setAwake(true);\n      }\n      this.m_angularVelocity = w;\n    };\n    Body2.prototype.getLinearDamping = function() {\n      return this.m_linearDamping;\n    };\n    Body2.prototype.setLinearDamping = function(linearDamping) {\n      this.m_linearDamping = linearDamping;\n    };\n    Body2.prototype.getAngularDamping = function() {\n      return this.m_angularDamping;\n    };\n    Body2.prototype.setAngularDamping = function(angularDamping) {\n      this.m_angularDamping = angularDamping;\n    };\n    Body2.prototype.getGravityScale = function() {\n      return this.m_gravityScale;\n    };\n    Body2.prototype.setGravityScale = function(scale) {\n      this.m_gravityScale = scale;\n    };\n    Body2.prototype.getMass = function() {\n      return this.m_mass;\n    };\n    Body2.prototype.getInertia = function() {\n      return this.m_I + this.m_mass * Vec2.dot(this.m_sweep.localCenter, this.m_sweep.localCenter);\n    };\n    Body2.prototype.getMassData = function(data) {\n      data.mass = this.m_mass;\n      data.I = this.getInertia();\n      copyVec2(data.center, this.m_sweep.localCenter);\n    };\n    Body2.prototype.resetMassData = function() {\n      this.m_mass = 0;\n      this.m_invMass = 0;\n      this.m_I = 0;\n      this.m_invI = 0;\n      zeroVec2(this.m_sweep.localCenter);\n      if (this.isStatic() || this.isKinematic()) {\n        copyVec2(this.m_sweep.c0, this.m_xf.p);\n        copyVec2(this.m_sweep.c, this.m_xf.p);\n        this.m_sweep.a0 = this.m_sweep.a;\n        return;\n      }\n      zeroVec2(localCenter);\n      for (var f = this.m_fixtureList; f; f = f.m_next) {\n        if (f.m_density == 0) {\n          continue;\n        }\n        var massData = {\n          mass: 0,\n          center: vec2(0, 0),\n          I: 0\n        };\n        f.getMassData(massData);\n        this.m_mass += massData.mass;\n        plusScaleVec2(localCenter, massData.mass, massData.center);\n        this.m_I += massData.I;\n      }\n      if (this.m_mass > 0) {\n        this.m_invMass = 1 / this.m_mass;\n        scaleVec2(localCenter, this.m_invMass, localCenter);\n      } else {\n        this.m_mass = 1;\n        this.m_invMass = 1;\n      }\n      if (this.m_I > 0 && this.m_fixedRotationFlag == false) {\n        this.m_I -= this.m_mass * dotVec2(localCenter, localCenter);\n        this.m_invI = 1 / this.m_I;\n      } else {\n        this.m_I = 0;\n        this.m_invI = 0;\n      }\n      copyVec2(oldCenter, this.m_sweep.c);\n      this.m_sweep.setLocalCenter(localCenter, this.m_xf);\n      subVec2(shift, this.m_sweep.c, oldCenter);\n      crossNumVec2(temp$6, this.m_angularVelocity, shift);\n      plusVec2(this.m_linearVelocity, temp$6);\n    };\n    Body2.prototype.setMassData = function(massData) {\n      if (this.isWorldLocked() == true) {\n        return;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      this.m_invMass = 0;\n      this.m_I = 0;\n      this.m_invI = 0;\n      this.m_mass = massData.mass;\n      if (this.m_mass <= 0) {\n        this.m_mass = 1;\n      }\n      this.m_invMass = 1 / this.m_mass;\n      if (massData.I > 0 && this.m_fixedRotationFlag == false) {\n        this.m_I = massData.I - this.m_mass * dotVec2(massData.center, massData.center);\n        this.m_invI = 1 / this.m_I;\n      }\n      copyVec2(oldCenter, this.m_sweep.c);\n      this.m_sweep.setLocalCenter(massData.center, this.m_xf);\n      subVec2(shift, this.m_sweep.c, oldCenter);\n      crossNumVec2(temp$6, this.m_angularVelocity, shift);\n      plusVec2(this.m_linearVelocity, temp$6);\n    };\n    Body2.prototype.applyForce = function(force, point2, wake) {\n      if (wake === void 0) {\n        wake = true;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      if (wake && this.m_awakeFlag == false) {\n        this.setAwake(true);\n      }\n      if (this.m_awakeFlag) {\n        this.m_force.add(force);\n        this.m_torque += Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), force);\n      }\n    };\n    Body2.prototype.applyForceToCenter = function(force, wake) {\n      if (wake === void 0) {\n        wake = true;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      if (wake && this.m_awakeFlag == false) {\n        this.setAwake(true);\n      }\n      if (this.m_awakeFlag) {\n        this.m_force.add(force);\n      }\n    };\n    Body2.prototype.applyTorque = function(torque, wake) {\n      if (wake === void 0) {\n        wake = true;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      if (wake && this.m_awakeFlag == false) {\n        this.setAwake(true);\n      }\n      if (this.m_awakeFlag) {\n        this.m_torque += torque;\n      }\n    };\n    Body2.prototype.applyLinearImpulse = function(impulse, point2, wake) {\n      if (wake === void 0) {\n        wake = true;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      if (wake && this.m_awakeFlag == false) {\n        this.setAwake(true);\n      }\n      if (this.m_awakeFlag) {\n        this.m_linearVelocity.addMul(this.m_invMass, impulse);\n        this.m_angularVelocity += this.m_invI * Vec2.crossVec2Vec2(Vec2.sub(point2, this.m_sweep.c), impulse);\n      }\n    };\n    Body2.prototype.applyAngularImpulse = function(impulse, wake) {\n      if (wake === void 0) {\n        wake = true;\n      }\n      if (this.m_type != DYNAMIC) {\n        return;\n      }\n      if (wake && this.m_awakeFlag == false) {\n        this.setAwake(true);\n      }\n      if (this.m_awakeFlag) {\n        this.m_angularVelocity += this.m_invI * impulse;\n      }\n    };\n    Body2.prototype.shouldCollide = function(that) {\n      if (this.m_type != DYNAMIC && that.m_type != DYNAMIC) {\n        return false;\n      }\n      for (var jn = this.m_jointList; jn; jn = jn.next) {\n        if (jn.other == that) {\n          if (jn.joint.m_collideConnected == false) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    Body2.prototype._addFixture = function(fixture) {\n      if (this.isWorldLocked() == true) {\n        return null;\n      }\n      if (this.m_activeFlag) {\n        var broadPhase = this.m_world.m_broadPhase;\n        fixture.createProxies(broadPhase, this.m_xf);\n      }\n      fixture.m_next = this.m_fixtureList;\n      this.m_fixtureList = fixture;\n      if (fixture.m_density > 0) {\n        this.resetMassData();\n      }\n      this.m_world.m_newFixture = true;\n      return fixture;\n    };\n    Body2.prototype.createFixture = function(shape, fixdef) {\n      if (this.isWorldLocked() == true) {\n        return null;\n      }\n      var fixture = new Fixture(this, shape, fixdef);\n      this._addFixture(fixture);\n      return fixture;\n    };\n    Body2.prototype.destroyFixture = function(fixture) {\n      if (this.isWorldLocked() == true) {\n        return;\n      }\n      if (this.m_fixtureList === fixture) {\n        this.m_fixtureList = fixture.m_next;\n      } else {\n        var node = this.m_fixtureList;\n        while (node != null) {\n          if (node.m_next === fixture) {\n            node.m_next = fixture.m_next;\n            break;\n          }\n          node = node.m_next;\n        }\n      }\n      var edge = this.m_contactList;\n      while (edge) {\n        var c2 = edge.contact;\n        edge = edge.next;\n        var fixtureA = c2.getFixtureA();\n        var fixtureB = c2.getFixtureB();\n        if (fixture == fixtureA || fixture == fixtureB) {\n          this.m_world.destroyContact(c2);\n        }\n      }\n      if (this.m_activeFlag) {\n        var broadPhase = this.m_world.m_broadPhase;\n        fixture.destroyProxies(broadPhase);\n      }\n      fixture.m_body = null;\n      fixture.m_next = null;\n      this.m_world.publish(\"remove-fixture\", fixture);\n      this.resetMassData();\n    };\n    Body2.prototype.getWorldPoint = function(localPoint) {\n      return Transform.mulVec2(this.m_xf, localPoint);\n    };\n    Body2.prototype.getWorldVector = function(localVector) {\n      return Rot.mulVec2(this.m_xf.q, localVector);\n    };\n    Body2.prototype.getLocalPoint = function(worldPoint) {\n      return Transform.mulTVec2(this.m_xf, worldPoint);\n    };\n    Body2.prototype.getLocalVector = function(worldVector) {\n      return Rot.mulTVec2(this.m_xf.q, worldVector);\n    };\n    Body2.STATIC = \"static\";\n    Body2.KINEMATIC = \"kinematic\";\n    Body2.DYNAMIC = \"dynamic\";\n    return Body2;\n  }()\n);\nvar JointEdge = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function JointEdge2() {\n      this.other = null;\n      this.joint = null;\n      this.prev = null;\n      this.next = null;\n    }\n    return JointEdge2;\n  }()\n);\nvar Joint = (\n  /** @class */\n  function() {\n    function Joint2(def, bodyA, bodyB) {\n      this.m_type = \"unknown-joint\";\n      this.m_prev = null;\n      this.m_next = null;\n      this.m_edgeA = new JointEdge();\n      this.m_edgeB = new JointEdge();\n      this.m_islandFlag = false;\n      this.style = {};\n      this.appData = {};\n      bodyA = \"bodyA\" in def ? def.bodyA : bodyA;\n      bodyB = \"bodyB\" in def ? def.bodyB : bodyB;\n      this.m_bodyA = bodyA;\n      this.m_bodyB = bodyB;\n      this.m_collideConnected = !!def.collideConnected;\n      this.m_userData = def.userData;\n      if (typeof def.style === \"object\" && def.style !== null) {\n        this.style = def.style;\n      }\n    }\n    Joint2.prototype.isActive = function() {\n      return this.m_bodyA.isActive() && this.m_bodyB.isActive();\n    };\n    Joint2.prototype.getType = function() {\n      return this.m_type;\n    };\n    Joint2.prototype.getBodyA = function() {\n      return this.m_bodyA;\n    };\n    Joint2.prototype.getBodyB = function() {\n      return this.m_bodyB;\n    };\n    Joint2.prototype.getNext = function() {\n      return this.m_next;\n    };\n    Joint2.prototype.getUserData = function() {\n      return this.m_userData;\n    };\n    Joint2.prototype.setUserData = function(data) {\n      this.m_userData = data;\n    };\n    Joint2.prototype.getCollideConnected = function() {\n      return this.m_collideConnected;\n    };\n    Joint2.prototype.shiftOrigin = function(newOrigin) {\n    };\n    Joint2.prototype._resetAnchors = function(def) {\n      return this._reset(def);\n    };\n    return Joint2;\n  }()\n);\nvar stats = {\n  gjkCalls: 0,\n  gjkIters: 0,\n  gjkMaxIters: 0,\n  toiTime: 0,\n  toiMaxTime: 0,\n  toiCalls: 0,\n  toiIters: 0,\n  toiMaxIters: 0,\n  toiRootIters: 0,\n  toiMaxRootIters: 0,\n  toString: function(newline) {\n    newline = typeof newline === \"string\" ? newline : \"\\n\";\n    var string = \"\";\n    for (var name_1 in this) {\n      if (typeof this[name_1] !== \"function\" && typeof this[name_1] !== \"object\") {\n        string += name_1 + \": \" + this[name_1] + newline;\n      }\n    }\n    return string;\n  }\n};\nvar now = function() {\n  return Date.now();\n};\nvar diff = function(time) {\n  return Date.now() - time;\n};\nconst Timer = {\n  now,\n  diff\n};\nvar math_max$4 = Math.max;\nvar temp$5 = vec2(0, 0);\nvar normal$4 = vec2(0, 0);\nvar e12 = vec2(0, 0);\nvar e13 = vec2(0, 0);\nvar e23 = vec2(0, 0);\nvar temp1 = vec2(0, 0);\nvar temp2 = vec2(0, 0);\nstats.gjkCalls = 0;\nstats.gjkIters = 0;\nstats.gjkMaxIters = 0;\nvar DistanceInput = (\n  /** @class */\n  function() {\n    function DistanceInput2() {\n      this.proxyA = new DistanceProxy();\n      this.proxyB = new DistanceProxy();\n      this.transformA = Transform.identity();\n      this.transformB = Transform.identity();\n      this.useRadii = false;\n    }\n    DistanceInput2.prototype.recycle = function() {\n      this.proxyA.recycle();\n      this.proxyB.recycle();\n      this.transformA.setIdentity();\n      this.transformB.setIdentity();\n      this.useRadii = false;\n    };\n    return DistanceInput2;\n  }()\n);\nvar DistanceOutput = (\n  /** @class */\n  function() {\n    function DistanceOutput2() {\n      this.pointA = vec2(0, 0);\n      this.pointB = vec2(0, 0);\n      this.distance = 0;\n      this.iterations = 0;\n    }\n    DistanceOutput2.prototype.recycle = function() {\n      zeroVec2(this.pointA);\n      zeroVec2(this.pointB);\n      this.distance = 0;\n      this.iterations = 0;\n    };\n    return DistanceOutput2;\n  }()\n);\nvar SimplexCache = (\n  /** @class */\n  function() {\n    function SimplexCache2() {\n      this.metric = 0;\n      this.indexA = [];\n      this.indexB = [];\n      this.count = 0;\n    }\n    SimplexCache2.prototype.recycle = function() {\n      this.metric = 0;\n      this.indexA.length = 0;\n      this.indexB.length = 0;\n      this.count = 0;\n    };\n    return SimplexCache2;\n  }()\n);\nvar Distance = function(output2, cache2, input2) {\n  ++stats.gjkCalls;\n  var proxyA = input2.proxyA;\n  var proxyB = input2.proxyB;\n  var xfA2 = input2.transformA;\n  var xfB2 = input2.transformB;\n  simplex.recycle();\n  simplex.readCache(cache2, proxyA, xfA2, proxyB, xfB2);\n  var vertices = simplex.m_v;\n  var k_maxIters = SettingsInternal.maxDistanceIterations;\n  var saveA = [];\n  var saveB = [];\n  var saveCount = 0;\n  var iter = 0;\n  while (iter < k_maxIters) {\n    saveCount = simplex.m_count;\n    for (var i = 0; i < saveCount; ++i) {\n      saveA[i] = vertices[i].indexA;\n      saveB[i] = vertices[i].indexB;\n    }\n    simplex.solve();\n    if (simplex.m_count === 3) {\n      break;\n    }\n    var d2 = simplex.getSearchDirection();\n    if (lengthSqrVec2(d2) < EPSILON * EPSILON) {\n      break;\n    }\n    var vertex = vertices[simplex.m_count];\n    vertex.indexA = proxyA.getSupport(derotVec2(temp$5, xfA2.q, scaleVec2(temp$5, -1, d2)));\n    transformVec2(vertex.wA, xfA2, proxyA.getVertex(vertex.indexA));\n    vertex.indexB = proxyB.getSupport(derotVec2(temp$5, xfB2.q, d2));\n    transformVec2(vertex.wB, xfB2, proxyB.getVertex(vertex.indexB));\n    subVec2(vertex.w, vertex.wB, vertex.wA);\n    ++iter;\n    ++stats.gjkIters;\n    var duplicate = false;\n    for (var i = 0; i < saveCount; ++i) {\n      if (vertex.indexA === saveA[i] && vertex.indexB === saveB[i]) {\n        duplicate = true;\n        break;\n      }\n    }\n    if (duplicate) {\n      break;\n    }\n    ++simplex.m_count;\n  }\n  stats.gjkMaxIters = math_max$4(stats.gjkMaxIters, iter);\n  simplex.getWitnessPoints(output2.pointA, output2.pointB);\n  output2.distance = distVec2(output2.pointA, output2.pointB);\n  output2.iterations = iter;\n  simplex.writeCache(cache2);\n  if (input2.useRadii) {\n    var rA2 = proxyA.m_radius;\n    var rB2 = proxyB.m_radius;\n    if (output2.distance > rA2 + rB2 && output2.distance > EPSILON) {\n      output2.distance -= rA2 + rB2;\n      subVec2(normal$4, output2.pointB, output2.pointA);\n      normalizeVec2(normal$4);\n      plusScaleVec2(output2.pointA, rA2, normal$4);\n      minusScaleVec2(output2.pointB, rB2, normal$4);\n    } else {\n      var p = subVec2(temp$5, output2.pointA, output2.pointB);\n      copyVec2(output2.pointA, p);\n      copyVec2(output2.pointB, p);\n      output2.distance = 0;\n    }\n  }\n};\nvar DistanceProxy = (\n  /** @class */\n  function() {\n    function DistanceProxy2() {\n      this.m_vertices = [];\n      this.m_count = 0;\n      this.m_radius = 0;\n    }\n    DistanceProxy2.prototype.recycle = function() {\n      this.m_vertices.length = 0;\n      this.m_count = 0;\n      this.m_radius = 0;\n    };\n    DistanceProxy2.prototype.getVertexCount = function() {\n      return this.m_count;\n    };\n    DistanceProxy2.prototype.getVertex = function(index) {\n      return this.m_vertices[index];\n    };\n    DistanceProxy2.prototype.getSupport = function(d2) {\n      var bestIndex = -1;\n      var bestValue = -Infinity;\n      for (var i = 0; i < this.m_count; ++i) {\n        var value = dotVec2(this.m_vertices[i], d2);\n        if (value > bestValue) {\n          bestIndex = i;\n          bestValue = value;\n        }\n      }\n      return bestIndex;\n    };\n    DistanceProxy2.prototype.getSupportVertex = function(d2) {\n      return this.m_vertices[this.getSupport(d2)];\n    };\n    DistanceProxy2.prototype.set = function(shape, index) {\n      shape.computeDistanceProxy(this, index);\n    };\n    DistanceProxy2.prototype.setVertices = function(vertices, count, radius) {\n      this.m_vertices = vertices;\n      this.m_count = count;\n      this.m_radius = radius;\n    };\n    return DistanceProxy2;\n  }()\n);\nvar SimplexVertex = (\n  /** @class */\n  function() {\n    function SimplexVertex2() {\n      this.wA = vec2(0, 0);\n      this.indexA = 0;\n      this.wB = vec2(0, 0);\n      this.indexB = 0;\n      this.w = vec2(0, 0);\n      this.a = 0;\n    }\n    SimplexVertex2.prototype.recycle = function() {\n      this.indexA = 0;\n      this.indexB = 0;\n      zeroVec2(this.wA);\n      zeroVec2(this.wB);\n      zeroVec2(this.w);\n      this.a = 0;\n    };\n    SimplexVertex2.prototype.set = function(v3) {\n      this.indexA = v3.indexA;\n      this.indexB = v3.indexB;\n      copyVec2(this.wA, v3.wA);\n      copyVec2(this.wB, v3.wB);\n      copyVec2(this.w, v3.w);\n      this.a = v3.a;\n    };\n    return SimplexVertex2;\n  }()\n);\nvar searchDirection_reuse = vec2(0, 0);\nvar closestPoint_reuse = vec2(0, 0);\nvar Simplex = (\n  /** @class */\n  function() {\n    function Simplex2() {\n      this.m_v1 = new SimplexVertex();\n      this.m_v2 = new SimplexVertex();\n      this.m_v3 = new SimplexVertex();\n      this.m_v = [this.m_v1, this.m_v2, this.m_v3];\n    }\n    Simplex2.prototype.recycle = function() {\n      this.m_v1.recycle();\n      this.m_v2.recycle();\n      this.m_v3.recycle();\n      this.m_count = 0;\n    };\n    Simplex2.prototype.toString = function() {\n      if (this.m_count === 3) {\n        return [\n          \"+\" + this.m_count,\n          this.m_v1.a,\n          this.m_v1.wA.x,\n          this.m_v1.wA.y,\n          this.m_v1.wB.x,\n          this.m_v1.wB.y,\n          this.m_v2.a,\n          this.m_v2.wA.x,\n          this.m_v2.wA.y,\n          this.m_v2.wB.x,\n          this.m_v2.wB.y,\n          this.m_v3.a,\n          this.m_v3.wA.x,\n          this.m_v3.wA.y,\n          this.m_v3.wB.x,\n          this.m_v3.wB.y\n        ].toString();\n      } else if (this.m_count === 2) {\n        return [\n          \"+\" + this.m_count,\n          this.m_v1.a,\n          this.m_v1.wA.x,\n          this.m_v1.wA.y,\n          this.m_v1.wB.x,\n          this.m_v1.wB.y,\n          this.m_v2.a,\n          this.m_v2.wA.x,\n          this.m_v2.wA.y,\n          this.m_v2.wB.x,\n          this.m_v2.wB.y\n        ].toString();\n      } else if (this.m_count === 1) {\n        return [\n          \"+\" + this.m_count,\n          this.m_v1.a,\n          this.m_v1.wA.x,\n          this.m_v1.wA.y,\n          this.m_v1.wB.x,\n          this.m_v1.wB.y\n        ].toString();\n      } else {\n        return \"+\" + this.m_count;\n      }\n    };\n    Simplex2.prototype.readCache = function(cache2, proxyA, transformA, proxyB, transformB) {\n      this.m_count = cache2.count;\n      for (var i = 0; i < this.m_count; ++i) {\n        var v3 = this.m_v[i];\n        v3.indexA = cache2.indexA[i];\n        v3.indexB = cache2.indexB[i];\n        var wALocal = proxyA.getVertex(v3.indexA);\n        var wBLocal = proxyB.getVertex(v3.indexB);\n        transformVec2(v3.wA, transformA, wALocal);\n        transformVec2(v3.wB, transformB, wBLocal);\n        subVec2(v3.w, v3.wB, v3.wA);\n        v3.a = 0;\n      }\n      if (this.m_count > 1) {\n        var metric1 = cache2.metric;\n        var metric2 = this.getMetric();\n        if (metric2 < 0.5 * metric1 || 2 * metric1 < metric2 || metric2 < EPSILON) {\n          this.m_count = 0;\n        }\n      }\n      if (this.m_count === 0) {\n        var v3 = this.m_v[0];\n        v3.indexA = 0;\n        v3.indexB = 0;\n        var wALocal = proxyA.getVertex(0);\n        var wBLocal = proxyB.getVertex(0);\n        transformVec2(v3.wA, transformA, wALocal);\n        transformVec2(v3.wB, transformB, wBLocal);\n        subVec2(v3.w, v3.wB, v3.wA);\n        v3.a = 1;\n        this.m_count = 1;\n      }\n    };\n    Simplex2.prototype.writeCache = function(cache2) {\n      cache2.metric = this.getMetric();\n      cache2.count = this.m_count;\n      for (var i = 0; i < this.m_count; ++i) {\n        cache2.indexA[i] = this.m_v[i].indexA;\n        cache2.indexB[i] = this.m_v[i].indexB;\n      }\n    };\n    Simplex2.prototype.getSearchDirection = function() {\n      var v13 = this.m_v1;\n      var v22 = this.m_v2;\n      this.m_v3;\n      switch (this.m_count) {\n        case 1:\n          return setVec2(searchDirection_reuse, -v13.w.x, -v13.w.y);\n        case 2: {\n          subVec2(e12, v22.w, v13.w);\n          var sgn = -crossVec2Vec2(e12, v13.w);\n          if (sgn > 0) {\n            return setVec2(searchDirection_reuse, -e12.y, e12.x);\n          } else {\n            return setVec2(searchDirection_reuse, e12.y, -e12.x);\n          }\n        }\n        default:\n          return zeroVec2(searchDirection_reuse);\n      }\n    };\n    Simplex2.prototype.getClosestPoint = function() {\n      var v13 = this.m_v1;\n      var v22 = this.m_v2;\n      this.m_v3;\n      switch (this.m_count) {\n        case 0:\n          return zeroVec2(closestPoint_reuse);\n        case 1:\n          return copyVec2(closestPoint_reuse, v13.w);\n        case 2:\n          return combine2Vec2(closestPoint_reuse, v13.a, v13.w, v22.a, v22.w);\n        case 3:\n          return zeroVec2(closestPoint_reuse);\n        default:\n          return zeroVec2(closestPoint_reuse);\n      }\n    };\n    Simplex2.prototype.getWitnessPoints = function(pA2, pB2) {\n      var v13 = this.m_v1;\n      var v22 = this.m_v2;\n      var v3 = this.m_v3;\n      switch (this.m_count) {\n        case 0:\n          break;\n        case 1:\n          copyVec2(pA2, v13.wA);\n          copyVec2(pB2, v13.wB);\n          break;\n        case 2:\n          combine2Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA);\n          combine2Vec2(pB2, v13.a, v13.wB, v22.a, v22.wB);\n          break;\n        case 3:\n          combine3Vec2(pA2, v13.a, v13.wA, v22.a, v22.wA, v3.a, v3.wA);\n          copyVec2(pB2, pA2);\n          break;\n      }\n    };\n    Simplex2.prototype.getMetric = function() {\n      switch (this.m_count) {\n        case 0:\n          return 0;\n        case 1:\n          return 0;\n        case 2:\n          return distVec2(this.m_v1.w, this.m_v2.w);\n        case 3:\n          return crossVec2Vec2(subVec2(temp1, this.m_v2.w, this.m_v1.w), subVec2(temp2, this.m_v3.w, this.m_v1.w));\n        default:\n          return 0;\n      }\n    };\n    Simplex2.prototype.solve = function() {\n      switch (this.m_count) {\n        case 1:\n          break;\n        case 2:\n          this.solve2();\n          break;\n        case 3:\n          this.solve3();\n          break;\n      }\n    };\n    Simplex2.prototype.solve2 = function() {\n      var w1 = this.m_v1.w;\n      var w2 = this.m_v2.w;\n      subVec2(e12, w2, w1);\n      var d12_2 = -dotVec2(w1, e12);\n      if (d12_2 <= 0) {\n        this.m_v1.a = 1;\n        this.m_count = 1;\n        return;\n      }\n      var d12_1 = dotVec2(w2, e12);\n      if (d12_1 <= 0) {\n        this.m_v2.a = 1;\n        this.m_count = 1;\n        this.m_v1.set(this.m_v2);\n        return;\n      }\n      var inv_d12 = 1 / (d12_1 + d12_2);\n      this.m_v1.a = d12_1 * inv_d12;\n      this.m_v2.a = d12_2 * inv_d12;\n      this.m_count = 2;\n    };\n    Simplex2.prototype.solve3 = function() {\n      var w1 = this.m_v1.w;\n      var w2 = this.m_v2.w;\n      var w3 = this.m_v3.w;\n      subVec2(e12, w2, w1);\n      var w1e12 = dotVec2(w1, e12);\n      var w2e12 = dotVec2(w2, e12);\n      var d12_1 = w2e12;\n      var d12_2 = -w1e12;\n      subVec2(e13, w3, w1);\n      var w1e13 = dotVec2(w1, e13);\n      var w3e13 = dotVec2(w3, e13);\n      var d13_1 = w3e13;\n      var d13_2 = -w1e13;\n      subVec2(e23, w3, w2);\n      var w2e23 = dotVec2(w2, e23);\n      var w3e23 = dotVec2(w3, e23);\n      var d23_1 = w3e23;\n      var d23_2 = -w2e23;\n      var n123 = crossVec2Vec2(e12, e13);\n      var d123_1 = n123 * crossVec2Vec2(w2, w3);\n      var d123_2 = n123 * crossVec2Vec2(w3, w1);\n      var d123_3 = n123 * crossVec2Vec2(w1, w2);\n      if (d12_2 <= 0 && d13_2 <= 0) {\n        this.m_v1.a = 1;\n        this.m_count = 1;\n        return;\n      }\n      if (d12_1 > 0 && d12_2 > 0 && d123_3 <= 0) {\n        var inv_d12 = 1 / (d12_1 + d12_2);\n        this.m_v1.a = d12_1 * inv_d12;\n        this.m_v2.a = d12_2 * inv_d12;\n        this.m_count = 2;\n        return;\n      }\n      if (d13_1 > 0 && d13_2 > 0 && d123_2 <= 0) {\n        var inv_d13 = 1 / (d13_1 + d13_2);\n        this.m_v1.a = d13_1 * inv_d13;\n        this.m_v3.a = d13_2 * inv_d13;\n        this.m_count = 2;\n        this.m_v2.set(this.m_v3);\n        return;\n      }\n      if (d12_1 <= 0 && d23_2 <= 0) {\n        this.m_v2.a = 1;\n        this.m_count = 1;\n        this.m_v1.set(this.m_v2);\n        return;\n      }\n      if (d13_1 <= 0 && d23_1 <= 0) {\n        this.m_v3.a = 1;\n        this.m_count = 1;\n        this.m_v1.set(this.m_v3);\n        return;\n      }\n      if (d23_1 > 0 && d23_2 > 0 && d123_1 <= 0) {\n        var inv_d23 = 1 / (d23_1 + d23_2);\n        this.m_v2.a = d23_1 * inv_d23;\n        this.m_v3.a = d23_2 * inv_d23;\n        this.m_count = 2;\n        this.m_v1.set(this.m_v3);\n        return;\n      }\n      var inv_d123 = 1 / (d123_1 + d123_2 + d123_3);\n      this.m_v1.a = d123_1 * inv_d123;\n      this.m_v2.a = d123_2 * inv_d123;\n      this.m_v3.a = d123_3 * inv_d123;\n      this.m_count = 3;\n    };\n    return Simplex2;\n  }()\n);\nvar simplex = new Simplex();\nvar input$1 = new DistanceInput();\nvar cache$1 = new SimplexCache();\nvar output$1 = new DistanceOutput();\nvar testOverlap = function(shapeA, indexA, shapeB, indexB, xfA2, xfB2) {\n  input$1.recycle();\n  input$1.proxyA.set(shapeA, indexA);\n  input$1.proxyB.set(shapeB, indexB);\n  copyTransform(input$1.transformA, xfA2);\n  copyTransform(input$1.transformB, xfB2);\n  input$1.useRadii = true;\n  output$1.recycle();\n  cache$1.recycle();\n  Distance(output$1, cache$1, input$1);\n  return output$1.distance < 10 * EPSILON;\n};\nDistance.testOverlap = testOverlap;\nDistance.Input = DistanceInput;\nDistance.Output = DistanceOutput;\nDistance.Proxy = DistanceProxy;\nDistance.Cache = SimplexCache;\nvar ShapeCastInput = (\n  /** @class */\n  function() {\n    function ShapeCastInput2() {\n      this.proxyA = new DistanceProxy();\n      this.proxyB = new DistanceProxy();\n      this.transformA = Transform.identity();\n      this.transformB = Transform.identity();\n      this.translationB = Vec2.zero();\n    }\n    ShapeCastInput2.prototype.recycle = function() {\n      this.proxyA.recycle();\n      this.proxyB.recycle();\n      this.transformA.setIdentity();\n      this.transformB.setIdentity();\n      zeroVec2(this.translationB);\n    };\n    return ShapeCastInput2;\n  }()\n);\nvar ShapeCastOutput = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function ShapeCastOutput2() {\n      this.point = Vec2.zero();\n      this.normal = Vec2.zero();\n      this.lambda = 1;\n      this.iterations = 0;\n    }\n    return ShapeCastOutput2;\n  }()\n);\nvar ShapeCast = function(output2, input2) {\n  output2.iterations = 0;\n  output2.lambda = 1;\n  output2.normal.setZero();\n  output2.point.setZero();\n  var proxyA = input2.proxyA;\n  var proxyB = input2.proxyB;\n  var radiusA = math_max$4(proxyA.m_radius, SettingsInternal.polygonRadius);\n  var radiusB = math_max$4(proxyB.m_radius, SettingsInternal.polygonRadius);\n  var radius = radiusA + radiusB;\n  var xfA2 = input2.transformA;\n  var xfB2 = input2.transformB;\n  var r = input2.translationB;\n  var n2 = Vec2.zero();\n  var lambda = 0;\n  var simplex2 = new Simplex();\n  simplex2.m_count = 0;\n  var vertices = simplex2.m_v;\n  var indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(r)));\n  var wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));\n  var indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, r));\n  var wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));\n  var v3 = Vec2.sub(wA, wB);\n  var sigma = math_max$4(SettingsInternal.polygonRadius, radius - SettingsInternal.polygonRadius);\n  var tolerance = 0.5 * SettingsInternal.linearSlop;\n  var k_maxIters = 20;\n  var iter = 0;\n  while (iter < k_maxIters && v3.length() - sigma > tolerance) {\n    output2.iterations += 1;\n    indexA = proxyA.getSupport(Rot.mulTVec2(xfA2.q, Vec2.neg(v3)));\n    wA = Transform.mulVec2(xfA2, proxyA.getVertex(indexA));\n    indexB = proxyB.getSupport(Rot.mulTVec2(xfB2.q, v3));\n    wB = Transform.mulVec2(xfB2, proxyB.getVertex(indexB));\n    var p = Vec2.sub(wA, wB);\n    v3.normalize();\n    var vp = Vec2.dot(v3, p);\n    var vr = Vec2.dot(v3, r);\n    if (vp - sigma > lambda * vr) {\n      if (vr <= 0) {\n        return false;\n      }\n      lambda = (vp - sigma) / vr;\n      if (lambda > 1) {\n        return false;\n      }\n      n2.setMul(-1, v3);\n      simplex2.m_count = 0;\n    }\n    var vertex = vertices[simplex2.m_count];\n    vertex.indexA = indexB;\n    vertex.wA = Vec2.combine(1, wB, lambda, r);\n    vertex.indexB = indexA;\n    vertex.wB = wA;\n    vertex.w = Vec2.sub(vertex.wB, vertex.wA);\n    vertex.a = 1;\n    simplex2.m_count += 1;\n    switch (simplex2.m_count) {\n      case 1:\n        break;\n      case 2:\n        simplex2.solve2();\n        break;\n      case 3:\n        simplex2.solve3();\n        break;\n    }\n    if (simplex2.m_count == 3) {\n      return false;\n    }\n    v3.setVec2(simplex2.getClosestPoint());\n    ++iter;\n  }\n  if (iter == 0) {\n    return false;\n  }\n  var pointA2 = Vec2.zero();\n  var pointB2 = Vec2.zero();\n  simplex2.getWitnessPoints(pointB2, pointA2);\n  if (v3.lengthSquared() > 0) {\n    n2.setMul(-1, v3);\n    n2.normalize();\n  }\n  output2.point = Vec2.combine(1, pointA2, radiusA, n2);\n  output2.normal = n2;\n  output2.lambda = lambda;\n  output2.iterations = iter;\n  return true;\n};\nvar math_abs$7 = Math.abs;\nvar math_max$3 = Math.max;\nvar TOIInput = (\n  /** @class */\n  function() {\n    function TOIInput2() {\n      this.proxyA = new DistanceProxy();\n      this.proxyB = new DistanceProxy();\n      this.sweepA = new Sweep();\n      this.sweepB = new Sweep();\n    }\n    TOIInput2.prototype.recycle = function() {\n      this.proxyA.recycle();\n      this.proxyB.recycle();\n      this.sweepA.recycle();\n      this.sweepB.recycle();\n      this.tMax = -1;\n    };\n    return TOIInput2;\n  }()\n);\nvar TOIOutputState;\n(function(TOIOutputState2) {\n  TOIOutputState2[TOIOutputState2[\"e_unset\"] = -1] = \"e_unset\";\n  TOIOutputState2[TOIOutputState2[\"e_unknown\"] = 0] = \"e_unknown\";\n  TOIOutputState2[TOIOutputState2[\"e_failed\"] = 1] = \"e_failed\";\n  TOIOutputState2[TOIOutputState2[\"e_overlapped\"] = 2] = \"e_overlapped\";\n  TOIOutputState2[TOIOutputState2[\"e_touching\"] = 3] = \"e_touching\";\n  TOIOutputState2[TOIOutputState2[\"e_separated\"] = 4] = \"e_separated\";\n})(TOIOutputState || (TOIOutputState = {}));\nvar TOIOutput = (\n  /** @class */\n  function() {\n    function TOIOutput2() {\n      this.state = TOIOutputState.e_unset;\n      this.t = -1;\n    }\n    TOIOutput2.prototype.recycle = function() {\n      this.state = TOIOutputState.e_unset;\n      this.t = -1;\n    };\n    return TOIOutput2;\n  }()\n);\nstats.toiTime = 0;\nstats.toiMaxTime = 0;\nstats.toiCalls = 0;\nstats.toiIters = 0;\nstats.toiMaxIters = 0;\nstats.toiRootIters = 0;\nstats.toiMaxRootIters = 0;\nvar distanceInput = new DistanceInput();\nvar distanceOutput = new DistanceOutput();\nvar cache = new SimplexCache();\nvar xfA$1 = transform(0, 0, 0);\nvar xfB$1 = transform(0, 0, 0);\nvar temp$4 = vec2(0, 0);\nvar pointA$2 = vec2(0, 0);\nvar pointB$2 = vec2(0, 0);\nvar normal$3 = vec2(0, 0);\nvar axisA = vec2(0, 0);\nvar axisB = vec2(0, 0);\nvar localPointA = vec2(0, 0);\nvar localPointB = vec2(0, 0);\nvar TimeOfImpact = function(output2, input2) {\n  var timer = Timer.now();\n  ++stats.toiCalls;\n  output2.state = TOIOutputState.e_unknown;\n  output2.t = input2.tMax;\n  var proxyA = input2.proxyA;\n  var proxyB = input2.proxyB;\n  var sweepA = input2.sweepA;\n  var sweepB = input2.sweepB;\n  sweepA.normalize();\n  sweepB.normalize();\n  var tMax = input2.tMax;\n  var totalRadius = proxyA.m_radius + proxyB.m_radius;\n  var target = math_max$3(SettingsInternal.linearSlop, totalRadius - 3 * SettingsInternal.linearSlop);\n  var tolerance = 0.25 * SettingsInternal.linearSlop;\n  var t1 = 0;\n  var k_maxIterations = SettingsInternal.maxTOIIterations;\n  var iter = 0;\n  cache.recycle();\n  distanceInput.proxyA.setVertices(proxyA.m_vertices, proxyA.m_count, proxyA.m_radius);\n  distanceInput.proxyB.setVertices(proxyB.m_vertices, proxyB.m_count, proxyB.m_radius);\n  distanceInput.useRadii = false;\n  while (true) {\n    sweepA.getTransform(xfA$1, t1);\n    sweepB.getTransform(xfB$1, t1);\n    copyTransform(distanceInput.transformA, xfA$1);\n    copyTransform(distanceInput.transformB, xfB$1);\n    Distance(distanceOutput, cache, distanceInput);\n    if (distanceOutput.distance <= 0) {\n      output2.state = TOIOutputState.e_overlapped;\n      output2.t = 0;\n      break;\n    }\n    if (distanceOutput.distance < target + tolerance) {\n      output2.state = TOIOutputState.e_touching;\n      output2.t = t1;\n      break;\n    }\n    separationFunction.initialize(cache, proxyA, sweepA, proxyB, sweepB, t1);\n    var done = false;\n    var t2 = tMax;\n    var pushBackIter = 0;\n    while (true) {\n      var s2 = separationFunction.findMinSeparation(t2);\n      if (s2 > target + tolerance) {\n        output2.state = TOIOutputState.e_separated;\n        output2.t = tMax;\n        done = true;\n        break;\n      }\n      if (s2 > target - tolerance) {\n        t1 = t2;\n        break;\n      }\n      var s1 = separationFunction.evaluate(t1);\n      if (s1 < target - tolerance) {\n        output2.state = TOIOutputState.e_failed;\n        output2.t = t1;\n        done = true;\n        break;\n      }\n      if (s1 <= target + tolerance) {\n        output2.state = TOIOutputState.e_touching;\n        output2.t = t1;\n        done = true;\n        break;\n      }\n      var rootIterCount = 0;\n      var a1 = t1;\n      var a2 = t2;\n      while (true) {\n        var t = void 0;\n        if (rootIterCount & 1) {\n          t = a1 + (target - s1) * (a2 - a1) / (s2 - s1);\n        } else {\n          t = 0.5 * (a1 + a2);\n        }\n        ++rootIterCount;\n        ++stats.toiRootIters;\n        var s3 = separationFunction.evaluate(t);\n        if (math_abs$7(s3 - target) < tolerance) {\n          t2 = t;\n          break;\n        }\n        if (s3 > target) {\n          a1 = t;\n          s1 = s3;\n        } else {\n          a2 = t;\n          s2 = s3;\n        }\n        if (rootIterCount === 50) {\n          break;\n        }\n      }\n      stats.toiMaxRootIters = math_max$3(stats.toiMaxRootIters, rootIterCount);\n      ++pushBackIter;\n      if (pushBackIter === SettingsInternal.maxPolygonVertices) {\n        break;\n      }\n    }\n    ++iter;\n    ++stats.toiIters;\n    if (done) {\n      break;\n    }\n    if (iter === k_maxIterations) {\n      output2.state = TOIOutputState.e_failed;\n      output2.t = t1;\n      break;\n    }\n  }\n  stats.toiMaxIters = math_max$3(stats.toiMaxIters, iter);\n  var time = Timer.diff(timer);\n  stats.toiMaxTime = math_max$3(stats.toiMaxTime, time);\n  stats.toiTime += time;\n  separationFunction.recycle();\n};\nvar SeparationFunctionType;\n(function(SeparationFunctionType2) {\n  SeparationFunctionType2[SeparationFunctionType2[\"e_unset\"] = -1] = \"e_unset\";\n  SeparationFunctionType2[SeparationFunctionType2[\"e_points\"] = 1] = \"e_points\";\n  SeparationFunctionType2[SeparationFunctionType2[\"e_faceA\"] = 2] = \"e_faceA\";\n  SeparationFunctionType2[SeparationFunctionType2[\"e_faceB\"] = 3] = \"e_faceB\";\n})(SeparationFunctionType || (SeparationFunctionType = {}));\nvar SeparationFunction = (\n  /** @class */\n  function() {\n    function SeparationFunction2() {\n      this.m_proxyA = null;\n      this.m_proxyB = null;\n      this.m_sweepA = null;\n      this.m_sweepB = null;\n      this.m_type = SeparationFunctionType.e_unset;\n      this.m_localPoint = vec2(0, 0);\n      this.m_axis = vec2(0, 0);\n      this.indexA = -1;\n      this.indexB = -1;\n    }\n    SeparationFunction2.prototype.recycle = function() {\n      this.m_proxyA = null;\n      this.m_proxyB = null;\n      this.m_sweepA = null;\n      this.m_sweepB = null;\n      this.m_type = SeparationFunctionType.e_unset;\n      zeroVec2(this.m_localPoint);\n      zeroVec2(this.m_axis);\n      this.indexA = -1;\n      this.indexB = -1;\n    };\n    SeparationFunction2.prototype.initialize = function(cache2, proxyA, sweepA, proxyB, sweepB, t1) {\n      var count = cache2.count;\n      this.m_proxyA = proxyA;\n      this.m_proxyB = proxyB;\n      this.m_sweepA = sweepA;\n      this.m_sweepB = sweepB;\n      this.m_sweepA.getTransform(xfA$1, t1);\n      this.m_sweepB.getTransform(xfB$1, t1);\n      if (count === 1) {\n        this.m_type = SeparationFunctionType.e_points;\n        var localPointA_1 = this.m_proxyA.getVertex(cache2.indexA[0]);\n        var localPointB_1 = this.m_proxyB.getVertex(cache2.indexB[0]);\n        transformVec2(pointA$2, xfA$1, localPointA_1);\n        transformVec2(pointB$2, xfB$1, localPointB_1);\n        subVec2(this.m_axis, pointB$2, pointA$2);\n        var s2 = normalizeVec2Length(this.m_axis);\n        return s2;\n      } else if (cache2.indexA[0] === cache2.indexA[1]) {\n        this.m_type = SeparationFunctionType.e_faceB;\n        var localPointB1 = proxyB.getVertex(cache2.indexB[0]);\n        var localPointB2 = proxyB.getVertex(cache2.indexB[1]);\n        crossVec2Num(this.m_axis, subVec2(temp$4, localPointB2, localPointB1), 1);\n        normalizeVec2(this.m_axis);\n        rotVec2(normal$3, xfB$1.q, this.m_axis);\n        combine2Vec2(this.m_localPoint, 0.5, localPointB1, 0.5, localPointB2);\n        transformVec2(pointB$2, xfB$1, this.m_localPoint);\n        var localPointA_2 = proxyA.getVertex(cache2.indexA[0]);\n        var pointA_1 = Transform.mulVec2(xfA$1, localPointA_2);\n        var s2 = dotVec2(pointA_1, normal$3) - dotVec2(pointB$2, normal$3);\n        if (s2 < 0) {\n          negVec2(this.m_axis);\n          s2 = -s2;\n        }\n        return s2;\n      } else {\n        this.m_type = SeparationFunctionType.e_faceA;\n        var localPointA1 = this.m_proxyA.getVertex(cache2.indexA[0]);\n        var localPointA2 = this.m_proxyA.getVertex(cache2.indexA[1]);\n        crossVec2Num(this.m_axis, subVec2(temp$4, localPointA2, localPointA1), 1);\n        normalizeVec2(this.m_axis);\n        rotVec2(normal$3, xfA$1.q, this.m_axis);\n        combine2Vec2(this.m_localPoint, 0.5, localPointA1, 0.5, localPointA2);\n        transformVec2(pointA$2, xfA$1, this.m_localPoint);\n        var localPointB_2 = this.m_proxyB.getVertex(cache2.indexB[0]);\n        transformVec2(pointB$2, xfB$1, localPointB_2);\n        var s2 = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);\n        if (s2 < 0) {\n          negVec2(this.m_axis);\n          s2 = -s2;\n        }\n        return s2;\n      }\n    };\n    SeparationFunction2.prototype.compute = function(find, t) {\n      this.m_sweepA.getTransform(xfA$1, t);\n      this.m_sweepB.getTransform(xfB$1, t);\n      switch (this.m_type) {\n        case SeparationFunctionType.e_points: {\n          if (find) {\n            derotVec2(axisA, xfA$1.q, this.m_axis);\n            derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, this.m_axis));\n            this.indexA = this.m_proxyA.getSupport(axisA);\n            this.indexB = this.m_proxyB.getSupport(axisB);\n          }\n          copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n          copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n          transformVec2(pointA$2, xfA$1, localPointA);\n          transformVec2(pointB$2, xfB$1, localPointB);\n          var sep = dotVec2(pointB$2, this.m_axis) - dotVec2(pointA$2, this.m_axis);\n          return sep;\n        }\n        case SeparationFunctionType.e_faceA: {\n          rotVec2(normal$3, xfA$1.q, this.m_axis);\n          transformVec2(pointA$2, xfA$1, this.m_localPoint);\n          if (find) {\n            derotVec2(axisB, xfB$1.q, scaleVec2(temp$4, -1, normal$3));\n            this.indexA = -1;\n            this.indexB = this.m_proxyB.getSupport(axisB);\n          }\n          copyVec2(localPointB, this.m_proxyB.getVertex(this.indexB));\n          transformVec2(pointB$2, xfB$1, localPointB);\n          var sep = dotVec2(pointB$2, normal$3) - dotVec2(pointA$2, normal$3);\n          return sep;\n        }\n        case SeparationFunctionType.e_faceB: {\n          rotVec2(normal$3, xfB$1.q, this.m_axis);\n          transformVec2(pointB$2, xfB$1, this.m_localPoint);\n          if (find) {\n            derotVec2(axisA, xfA$1.q, scaleVec2(temp$4, -1, normal$3));\n            this.indexB = -1;\n            this.indexA = this.m_proxyA.getSupport(axisA);\n          }\n          copyVec2(localPointA, this.m_proxyA.getVertex(this.indexA));\n          transformVec2(pointA$2, xfA$1, localPointA);\n          var sep = dotVec2(pointA$2, normal$3) - dotVec2(pointB$2, normal$3);\n          return sep;\n        }\n        default:\n          if (find) {\n            this.indexA = -1;\n            this.indexB = -1;\n          }\n          return 0;\n      }\n    };\n    SeparationFunction2.prototype.findMinSeparation = function(t) {\n      return this.compute(true, t);\n    };\n    SeparationFunction2.prototype.evaluate = function(t) {\n      return this.compute(false, t);\n    };\n    return SeparationFunction2;\n  }()\n);\nvar separationFunction = new SeparationFunction();\nTimeOfImpact.Input = TOIInput;\nTimeOfImpact.Output = TOIOutput;\nvar math_abs$6 = Math.abs;\nvar math_sqrt$3 = Math.sqrt;\nvar math_min$5 = Math.min;\nvar TimeStep = (\n  /** @class */\n  function() {\n    function TimeStep2() {\n      this.dt = 0;\n      this.inv_dt = 0;\n      this.velocityIterations = 0;\n      this.positionIterations = 0;\n      this.warmStarting = false;\n      this.blockSolve = true;\n      this.inv_dt0 = 0;\n      this.dtRatio = 1;\n    }\n    TimeStep2.prototype.reset = function(dt) {\n      if (this.dt > 0) {\n        this.inv_dt0 = this.inv_dt;\n      }\n      this.dt = dt;\n      this.inv_dt = dt == 0 ? 0 : 1 / dt;\n      this.dtRatio = dt * this.inv_dt0;\n    };\n    return TimeStep2;\n  }()\n);\nvar s_subStep = new TimeStep();\nvar c = vec2(0, 0);\nvar v = vec2(0, 0);\nvar translation = vec2(0, 0);\nvar input = new TOIInput();\nvar output = new TOIOutput();\nvar backup = new Sweep();\nvar backup1 = new Sweep();\nvar backup2 = new Sweep();\nvar ContactImpulse = (\n  /** @class */\n  function() {\n    function ContactImpulse2(contact) {\n      this.contact = contact;\n      this.normals = [];\n      this.tangents = [];\n    }\n    ContactImpulse2.prototype.recycle = function() {\n      this.normals.length = 0;\n      this.tangents.length = 0;\n    };\n    Object.defineProperty(ContactImpulse2.prototype, \"normalImpulses\", {\n      get: function() {\n        var contact = this.contact;\n        var normals = this.normals;\n        normals.length = 0;\n        for (var p = 0; p < contact.v_points.length; ++p) {\n          normals.push(contact.v_points[p].normalImpulse);\n        }\n        return normals;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    Object.defineProperty(ContactImpulse2.prototype, \"tangentImpulses\", {\n      get: function() {\n        var contact = this.contact;\n        var tangents = this.tangents;\n        tangents.length = 0;\n        for (var p = 0; p < contact.v_points.length; ++p) {\n          tangents.push(contact.v_points[p].tangentImpulse);\n        }\n        return tangents;\n      },\n      enumerable: false,\n      configurable: true\n    });\n    return ContactImpulse2;\n  }()\n);\nvar Solver = (\n  /** @class */\n  function() {\n    function Solver2(world) {\n      this.m_world = world;\n      this.m_stack = [];\n      this.m_bodies = [];\n      this.m_contacts = [];\n      this.m_joints = [];\n    }\n    Solver2.prototype.clear = function() {\n      this.m_stack.length = 0;\n      this.m_bodies.length = 0;\n      this.m_contacts.length = 0;\n      this.m_joints.length = 0;\n    };\n    Solver2.prototype.addBody = function(body) {\n      this.m_bodies.push(body);\n    };\n    Solver2.prototype.addContact = function(contact) {\n      this.m_contacts.push(contact);\n    };\n    Solver2.prototype.addJoint = function(joint) {\n      this.m_joints.push(joint);\n    };\n    Solver2.prototype.solveWorld = function(step) {\n      var world = this.m_world;\n      for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {\n        b2.m_islandFlag = false;\n      }\n      for (var c_1 = world.m_contactList; c_1; c_1 = c_1.m_next) {\n        c_1.m_islandFlag = false;\n      }\n      for (var j = world.m_jointList; j; j = j.m_next) {\n        j.m_islandFlag = false;\n      }\n      var stack = this.m_stack;\n      for (var seed = world.m_bodyList; seed; seed = seed.m_next) {\n        if (seed.m_islandFlag) {\n          continue;\n        }\n        if (seed.isAwake() == false || seed.isActive() == false) {\n          continue;\n        }\n        if (seed.isStatic()) {\n          continue;\n        }\n        this.clear();\n        stack.push(seed);\n        seed.m_islandFlag = true;\n        while (stack.length > 0) {\n          var b2 = stack.pop();\n          this.addBody(b2);\n          b2.m_awakeFlag = true;\n          if (b2.isStatic()) {\n            continue;\n          }\n          for (var ce = b2.m_contactList; ce; ce = ce.next) {\n            var contact = ce.contact;\n            if (contact.m_islandFlag) {\n              continue;\n            }\n            if (contact.isEnabled() == false || contact.isTouching() == false) {\n              continue;\n            }\n            var sensorA = contact.m_fixtureA.m_isSensor;\n            var sensorB = contact.m_fixtureB.m_isSensor;\n            if (sensorA || sensorB) {\n              continue;\n            }\n            this.addContact(contact);\n            contact.m_islandFlag = true;\n            var other = ce.other;\n            if (other.m_islandFlag) {\n              continue;\n            }\n            stack.push(other);\n            other.m_islandFlag = true;\n          }\n          for (var je = b2.m_jointList; je; je = je.next) {\n            if (je.joint.m_islandFlag == true) {\n              continue;\n            }\n            var other = je.other;\n            if (other.isActive() == false) {\n              continue;\n            }\n            this.addJoint(je.joint);\n            je.joint.m_islandFlag = true;\n            if (other.m_islandFlag) {\n              continue;\n            }\n            stack.push(other);\n            other.m_islandFlag = true;\n          }\n        }\n        this.solveIsland(step);\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var b2 = this.m_bodies[i];\n          if (b2.isStatic()) {\n            b2.m_islandFlag = false;\n          }\n        }\n      }\n    };\n    Solver2.prototype.solveIsland = function(step) {\n      var world = this.m_world;\n      var gravity = world.m_gravity;\n      var allowSleep = world.m_allowSleep;\n      var h = step.dt;\n      for (var i = 0; i < this.m_bodies.length; ++i) {\n        var body = this.m_bodies[i];\n        copyVec2(c, body.m_sweep.c);\n        var a2 = body.m_sweep.a;\n        copyVec2(v, body.m_linearVelocity);\n        var w = body.m_angularVelocity;\n        copyVec2(body.m_sweep.c0, body.m_sweep.c);\n        body.m_sweep.a0 = body.m_sweep.a;\n        if (body.isDynamic()) {\n          plusScaleVec2(v, h * body.m_gravityScale, gravity);\n          plusScaleVec2(v, h * body.m_invMass, body.m_force);\n          w += h * body.m_invI * body.m_torque;\n          scaleVec2(v, 1 / (1 + h * body.m_linearDamping), v);\n          w *= 1 / (1 + h * body.m_angularDamping);\n        }\n        copyVec2(body.c_position.c, c);\n        body.c_position.a = a2;\n        copyVec2(body.c_velocity.v, v);\n        body.c_velocity.w = w;\n      }\n      for (var i = 0; i < this.m_contacts.length; ++i) {\n        var contact = this.m_contacts[i];\n        contact.initConstraint(step);\n      }\n      for (var i = 0; i < this.m_contacts.length; ++i) {\n        var contact = this.m_contacts[i];\n        contact.initVelocityConstraint(step);\n      }\n      if (step.warmStarting) {\n        for (var i = 0; i < this.m_contacts.length; ++i) {\n          var contact = this.m_contacts[i];\n          contact.warmStartConstraint(step);\n        }\n      }\n      for (var i = 0; i < this.m_joints.length; ++i) {\n        var joint = this.m_joints[i];\n        joint.initVelocityConstraints(step);\n      }\n      for (var i = 0; i < step.velocityIterations; ++i) {\n        for (var j = 0; j < this.m_joints.length; ++j) {\n          var joint = this.m_joints[j];\n          joint.solveVelocityConstraints(step);\n        }\n        for (var j = 0; j < this.m_contacts.length; ++j) {\n          var contact = this.m_contacts[j];\n          contact.solveVelocityConstraint(step);\n        }\n      }\n      for (var i = 0; i < this.m_contacts.length; ++i) {\n        var contact = this.m_contacts[i];\n        contact.storeConstraintImpulses(step);\n      }\n      for (var i = 0; i < this.m_bodies.length; ++i) {\n        var body = this.m_bodies[i];\n        copyVec2(c, body.c_position.c);\n        var a2 = body.c_position.a;\n        copyVec2(v, body.c_velocity.v);\n        var w = body.c_velocity.w;\n        scaleVec2(translation, h, v);\n        var translationLengthSqr = lengthSqrVec2(translation);\n        if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {\n          var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);\n          mulVec2(v, ratio);\n        }\n        var rotation2 = h * w;\n        if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {\n          var ratio = SettingsInternal.maxRotation / math_abs$6(rotation2);\n          w *= ratio;\n        }\n        plusScaleVec2(c, h, v);\n        a2 += h * w;\n        copyVec2(body.c_position.c, c);\n        body.c_position.a = a2;\n        copyVec2(body.c_velocity.v, v);\n        body.c_velocity.w = w;\n      }\n      var positionSolved = false;\n      for (var i = 0; i < step.positionIterations; ++i) {\n        var minSeparation = 0;\n        for (var j = 0; j < this.m_contacts.length; ++j) {\n          var contact = this.m_contacts[j];\n          var separation = contact.solvePositionConstraint(step);\n          minSeparation = math_min$5(minSeparation, separation);\n        }\n        var contactsOkay = minSeparation >= -3 * SettingsInternal.linearSlop;\n        var jointsOkay = true;\n        for (var j = 0; j < this.m_joints.length; ++j) {\n          var joint = this.m_joints[j];\n          var jointOkay = joint.solvePositionConstraints(step);\n          jointsOkay = jointsOkay && jointOkay;\n        }\n        if (contactsOkay && jointsOkay) {\n          positionSolved = true;\n          break;\n        }\n      }\n      for (var i = 0; i < this.m_bodies.length; ++i) {\n        var body = this.m_bodies[i];\n        copyVec2(body.m_sweep.c, body.c_position.c);\n        body.m_sweep.a = body.c_position.a;\n        copyVec2(body.m_linearVelocity, body.c_velocity.v);\n        body.m_angularVelocity = body.c_velocity.w;\n        body.synchronizeTransform();\n      }\n      this.postSolveIsland();\n      if (allowSleep) {\n        var minSleepTime = Infinity;\n        var linTolSqr = SettingsInternal.linearSleepToleranceSqr;\n        var angTolSqr = SettingsInternal.angularSleepToleranceSqr;\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          if (body.isStatic()) {\n            continue;\n          }\n          if (body.m_autoSleepFlag == false || body.m_angularVelocity * body.m_angularVelocity > angTolSqr || lengthSqrVec2(body.m_linearVelocity) > linTolSqr) {\n            body.m_sleepTime = 0;\n            minSleepTime = 0;\n          } else {\n            body.m_sleepTime += h;\n            minSleepTime = math_min$5(minSleepTime, body.m_sleepTime);\n          }\n        }\n        if (minSleepTime >= SettingsInternal.timeToSleep && positionSolved) {\n          for (var i = 0; i < this.m_bodies.length; ++i) {\n            var body = this.m_bodies[i];\n            body.setAwake(false);\n          }\n        }\n      }\n    };\n    Solver2.prototype.solveWorldTOI = function(step) {\n      var world = this.m_world;\n      if (world.m_stepComplete) {\n        for (var b2 = world.m_bodyList; b2; b2 = b2.m_next) {\n          b2.m_islandFlag = false;\n          b2.m_sweep.alpha0 = 0;\n        }\n        for (var c_2 = world.m_contactList; c_2; c_2 = c_2.m_next) {\n          c_2.m_toiFlag = false;\n          c_2.m_islandFlag = false;\n          c_2.m_toiCount = 0;\n          c_2.m_toi = 1;\n        }\n      }\n      while (true) {\n        var minContact = null;\n        var minAlpha = 1;\n        for (var c_3 = world.m_contactList; c_3; c_3 = c_3.m_next) {\n          if (c_3.isEnabled() == false) {\n            continue;\n          }\n          if (c_3.m_toiCount > SettingsInternal.maxSubSteps) {\n            continue;\n          }\n          var alpha = 1;\n          if (c_3.m_toiFlag) {\n            alpha = c_3.m_toi;\n          } else {\n            var fA_1 = c_3.getFixtureA();\n            var fB_1 = c_3.getFixtureB();\n            if (fA_1.isSensor() || fB_1.isSensor()) {\n              continue;\n            }\n            var bA_1 = fA_1.getBody();\n            var bB_1 = fB_1.getBody();\n            var activeA = bA_1.isAwake() && !bA_1.isStatic();\n            var activeB = bB_1.isAwake() && !bB_1.isStatic();\n            if (activeA == false && activeB == false) {\n              continue;\n            }\n            var collideA = bA_1.isBullet() || !bA_1.isDynamic();\n            var collideB = bB_1.isBullet() || !bB_1.isDynamic();\n            if (collideA == false && collideB == false) {\n              continue;\n            }\n            var alpha0 = bA_1.m_sweep.alpha0;\n            if (bA_1.m_sweep.alpha0 < bB_1.m_sweep.alpha0) {\n              alpha0 = bB_1.m_sweep.alpha0;\n              bA_1.m_sweep.advance(alpha0);\n            } else if (bB_1.m_sweep.alpha0 < bA_1.m_sweep.alpha0) {\n              alpha0 = bA_1.m_sweep.alpha0;\n              bB_1.m_sweep.advance(alpha0);\n            }\n            var indexA = c_3.getChildIndexA();\n            var indexB = c_3.getChildIndexB();\n            bA_1.m_sweep;\n            bB_1.m_sweep;\n            input.proxyA.set(fA_1.getShape(), indexA);\n            input.proxyB.set(fB_1.getShape(), indexB);\n            input.sweepA.set(bA_1.m_sweep);\n            input.sweepB.set(bB_1.m_sweep);\n            input.tMax = 1;\n            TimeOfImpact(output, input);\n            var beta = output.t;\n            if (output.state == TOIOutputState.e_touching) {\n              alpha = math_min$5(alpha0 + (1 - alpha0) * beta, 1);\n            } else {\n              alpha = 1;\n            }\n            c_3.m_toi = alpha;\n            c_3.m_toiFlag = true;\n          }\n          if (alpha < minAlpha) {\n            minContact = c_3;\n            minAlpha = alpha;\n          }\n        }\n        if (minContact == null || 1 - 10 * EPSILON < minAlpha) {\n          world.m_stepComplete = true;\n          break;\n        }\n        var fA = minContact.getFixtureA();\n        var fB = minContact.getFixtureB();\n        var bA = fA.getBody();\n        var bB = fB.getBody();\n        backup1.set(bA.m_sweep);\n        backup2.set(bB.m_sweep);\n        bA.advance(minAlpha);\n        bB.advance(minAlpha);\n        minContact.update(world);\n        minContact.m_toiFlag = false;\n        ++minContact.m_toiCount;\n        if (minContact.isEnabled() == false || minContact.isTouching() == false) {\n          minContact.setEnabled(false);\n          bA.m_sweep.set(backup1);\n          bB.m_sweep.set(backup2);\n          bA.synchronizeTransform();\n          bB.synchronizeTransform();\n          continue;\n        }\n        bA.setAwake(true);\n        bB.setAwake(true);\n        this.clear();\n        this.addBody(bA);\n        this.addBody(bB);\n        this.addContact(minContact);\n        bA.m_islandFlag = true;\n        bB.m_islandFlag = true;\n        minContact.m_islandFlag = true;\n        var bodies = [bA, bB];\n        for (var i = 0; i < bodies.length; ++i) {\n          var body = bodies[i];\n          if (body.isDynamic()) {\n            for (var ce = body.m_contactList; ce; ce = ce.next) {\n              var contact = ce.contact;\n              if (contact.m_islandFlag) {\n                continue;\n              }\n              var other = ce.other;\n              if (other.isDynamic() && !body.isBullet() && !other.isBullet()) {\n                continue;\n              }\n              var sensorA = contact.m_fixtureA.m_isSensor;\n              var sensorB = contact.m_fixtureB.m_isSensor;\n              if (sensorA || sensorB) {\n                continue;\n              }\n              backup.set(other.m_sweep);\n              if (other.m_islandFlag == false) {\n                other.advance(minAlpha);\n              }\n              contact.update(world);\n              if (contact.isEnabled() == false || contact.isTouching() == false) {\n                other.m_sweep.set(backup);\n                other.synchronizeTransform();\n                continue;\n              }\n              contact.m_islandFlag = true;\n              this.addContact(contact);\n              if (other.m_islandFlag) {\n                continue;\n              }\n              other.m_islandFlag = true;\n              if (!other.isStatic()) {\n                other.setAwake(true);\n              }\n              this.addBody(other);\n            }\n          }\n        }\n        s_subStep.reset((1 - minAlpha) * step.dt);\n        s_subStep.dtRatio = 1;\n        s_subStep.positionIterations = 20;\n        s_subStep.velocityIterations = step.velocityIterations;\n        s_subStep.warmStarting = false;\n        this.solveIslandTOI(s_subStep, bA, bB);\n        for (var i = 0; i < this.m_bodies.length; ++i) {\n          var body = this.m_bodies[i];\n          body.m_islandFlag = false;\n          if (!body.isDynamic()) {\n            continue;\n          }\n          body.synchronizeFixtures();\n          for (var ce = body.m_contactList; ce; ce = ce.next) {\n            ce.contact.m_toiFlag = false;\n            ce.contact.m_islandFlag = false;\n          }\n        }\n        world.findNewContacts();\n        if (world.m_subStepping) {\n          world.m_stepComplete = false;\n          break;\n        }\n      }\n    };\n    Solver2.prototype.solveIslandTOI = function(subStep, toiA, toiB) {\n      for (var i = 0; i < this.m_bodies.length; ++i) {\n        var body = this.m_bodies[i];\n        copyVec2(body.c_position.c, body.m_sweep.c);\n        body.c_position.a = body.m_sweep.a;\n        copyVec2(body.c_velocity.v, body.m_linearVelocity);\n        body.c_velocity.w = body.m_angularVelocity;\n      }\n      for (var i = 0; i < this.m_contacts.length; ++i) {\n        var contact = this.m_contacts[i];\n        contact.initConstraint(subStep);\n      }\n      for (var i = 0; i < subStep.positionIterations; ++i) {\n        var minSeparation = 0;\n        for (var j = 0; j < this.m_contacts.length; ++j) {\n          var contact = this.m_contacts[j];\n          var separation = contact.solvePositionConstraintTOI(subStep, toiA, toiB);\n          minSeparation = math_min$5(minSeparation, separation);\n        }\n        var contactsOkay = minSeparation >= -1.5 * SettingsInternal.linearSlop;\n        if (contactsOkay) {\n          break;\n        }\n      }\n      var i;\n      copyVec2(toiA.m_sweep.c0, toiA.c_position.c);\n      toiA.m_sweep.a0 = toiA.c_position.a;\n      copyVec2(toiB.m_sweep.c0, toiB.c_position.c);\n      toiB.m_sweep.a0 = toiB.c_position.a;\n      for (var i = 0; i < this.m_contacts.length; ++i) {\n        var contact = this.m_contacts[i];\n        contact.initVelocityConstraint(subStep);\n      }\n      for (var i = 0; i < subStep.velocityIterations; ++i) {\n        for (var j = 0; j < this.m_contacts.length; ++j) {\n          var contact = this.m_contacts[j];\n          contact.solveVelocityConstraint(subStep);\n        }\n      }\n      var h = subStep.dt;\n      for (var i = 0; i < this.m_bodies.length; ++i) {\n        var body = this.m_bodies[i];\n        copyVec2(c, body.c_position.c);\n        var a2 = body.c_position.a;\n        copyVec2(v, body.c_velocity.v);\n        var w = body.c_velocity.w;\n        scaleVec2(translation, h, v);\n        var translationLengthSqr = lengthSqrVec2(translation);\n        if (translationLengthSqr > SettingsInternal.maxTranslationSquared) {\n          var ratio = SettingsInternal.maxTranslation / math_sqrt$3(translationLengthSqr);\n          mulVec2(v, ratio);\n        }\n        var rotation2 = h * w;\n        if (rotation2 * rotation2 > SettingsInternal.maxRotationSquared) {\n          var ratio = SettingsInternal.maxRotation / math_abs$6(rotation2);\n          w *= ratio;\n        }\n        plusScaleVec2(c, h, v);\n        a2 += h * w;\n        copyVec2(body.c_position.c, c);\n        body.c_position.a = a2;\n        copyVec2(body.c_velocity.v, v);\n        body.c_velocity.w = w;\n        copyVec2(body.m_sweep.c, c);\n        body.m_sweep.a = a2;\n        copyVec2(body.m_linearVelocity, v);\n        body.m_angularVelocity = w;\n        body.synchronizeTransform();\n      }\n      this.postSolveIsland();\n    };\n    Solver2.prototype.postSolveIsland = function() {\n      for (var c_5 = 0; c_5 < this.m_contacts.length; ++c_5) {\n        var contact = this.m_contacts[c_5];\n        this.m_world.postSolve(contact, contact.m_impulse);\n      }\n    };\n    return Solver2;\n  }()\n);\nSolver.TimeStep = TimeStep;\nvar Mat22 = (\n  /** @class */\n  function() {\n    function Mat222(a2, b2, c2, d2) {\n      if (typeof a2 === \"object\" && a2 !== null) {\n        this.ex = Vec2.clone(a2);\n        this.ey = Vec2.clone(b2);\n      } else if (typeof a2 === \"number\") {\n        this.ex = Vec2.neo(a2, c2);\n        this.ey = Vec2.neo(b2, d2);\n      } else {\n        this.ex = Vec2.zero();\n        this.ey = Vec2.zero();\n      }\n    }\n    Mat222.prototype.toString = function() {\n      return JSON.stringify(this);\n    };\n    Mat222.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Vec2.isValid(obj.ex) && Vec2.isValid(obj.ey);\n    };\n    Mat222.assert = function(o) {\n    };\n    Mat222.prototype.set = function(a2, b2, c2, d2) {\n      if (typeof a2 === \"number\" && typeof b2 === \"number\" && typeof c2 === \"number\" && typeof d2 === \"number\") {\n        this.ex.setNum(a2, c2);\n        this.ey.setNum(b2, d2);\n      } else if (typeof a2 === \"object\" && typeof b2 === \"object\") {\n        this.ex.setVec2(a2);\n        this.ey.setVec2(b2);\n      } else if (typeof a2 === \"object\") {\n        this.ex.setVec2(a2.ex);\n        this.ey.setVec2(a2.ey);\n      } else ;\n    };\n    Mat222.prototype.setIdentity = function() {\n      this.ex.x = 1;\n      this.ey.x = 0;\n      this.ex.y = 0;\n      this.ey.y = 1;\n    };\n    Mat222.prototype.setZero = function() {\n      this.ex.x = 0;\n      this.ey.x = 0;\n      this.ex.y = 0;\n      this.ey.y = 0;\n    };\n    Mat222.prototype.getInverse = function() {\n      var a2 = this.ex.x;\n      var b2 = this.ey.x;\n      var c2 = this.ex.y;\n      var d2 = this.ey.y;\n      var det = a2 * d2 - b2 * c2;\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      var imx = new Mat222();\n      imx.ex.x = det * d2;\n      imx.ey.x = -det * b2;\n      imx.ex.y = -det * c2;\n      imx.ey.y = det * a2;\n      return imx;\n    };\n    Mat222.prototype.solve = function(v3) {\n      var a2 = this.ex.x;\n      var b2 = this.ey.x;\n      var c2 = this.ex.y;\n      var d2 = this.ey.y;\n      var det = a2 * d2 - b2 * c2;\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      var w = Vec2.zero();\n      w.x = det * (d2 * v3.x - b2 * v3.y);\n      w.y = det * (a2 * v3.y - c2 * v3.x);\n      return w;\n    };\n    Mat222.mul = function(mx, v3) {\n      if (v3 && \"x\" in v3 && \"y\" in v3) {\n        var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;\n        var y = mx.ex.y * v3.x + mx.ey.y * v3.y;\n        return Vec2.neo(x2, y);\n      } else if (v3 && \"ex\" in v3 && \"ey\" in v3) {\n        var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;\n        var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;\n        var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;\n        var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;\n        return new Mat222(a2, b2, c2, d2);\n      }\n    };\n    Mat222.mulVec2 = function(mx, v3) {\n      var x2 = mx.ex.x * v3.x + mx.ey.x * v3.y;\n      var y = mx.ex.y * v3.x + mx.ey.y * v3.y;\n      return Vec2.neo(x2, y);\n    };\n    Mat222.mulMat22 = function(mx, v3) {\n      var a2 = mx.ex.x * v3.ex.x + mx.ey.x * v3.ex.y;\n      var b2 = mx.ex.x * v3.ey.x + mx.ey.x * v3.ey.y;\n      var c2 = mx.ex.y * v3.ex.x + mx.ey.y * v3.ex.y;\n      var d2 = mx.ex.y * v3.ey.x + mx.ey.y * v3.ey.y;\n      return new Mat222(a2, b2, c2, d2);\n    };\n    Mat222.mulT = function(mx, v3) {\n      if (v3 && \"x\" in v3 && \"y\" in v3) {\n        return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));\n      } else if (v3 && \"ex\" in v3 && \"ey\" in v3) {\n        var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));\n        var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));\n        return new Mat222(c1, c2);\n      }\n    };\n    Mat222.mulTVec2 = function(mx, v3) {\n      return Vec2.neo(Vec2.dot(v3, mx.ex), Vec2.dot(v3, mx.ey));\n    };\n    Mat222.mulTMat22 = function(mx, v3) {\n      var c1 = Vec2.neo(Vec2.dot(mx.ex, v3.ex), Vec2.dot(mx.ey, v3.ex));\n      var c2 = Vec2.neo(Vec2.dot(mx.ex, v3.ey), Vec2.dot(mx.ey, v3.ey));\n      return new Mat222(c1, c2);\n    };\n    Mat222.abs = function(mx) {\n      return new Mat222(Vec2.abs(mx.ex), Vec2.abs(mx.ey));\n    };\n    Mat222.add = function(mx1, mx2) {\n      return new Mat222(Vec2.add(mx1.ex, mx2.ex), Vec2.add(mx1.ey, mx2.ey));\n    };\n    return Mat222;\n  }()\n);\nvar math_sqrt$2 = Math.sqrt;\nvar pointA$1 = vec2(0, 0);\nvar pointB$1 = vec2(0, 0);\nvar temp$3 = vec2(0, 0);\nvar cA$1 = vec2(0, 0);\nvar cB$1 = vec2(0, 0);\nvar dist = vec2(0, 0);\nvar planePoint$2 = vec2(0, 0);\nvar clipPoint$1 = vec2(0, 0);\nvar ManifoldType;\n(function(ManifoldType2) {\n  ManifoldType2[ManifoldType2[\"e_unset\"] = -1] = \"e_unset\";\n  ManifoldType2[ManifoldType2[\"e_circles\"] = 0] = \"e_circles\";\n  ManifoldType2[ManifoldType2[\"e_faceA\"] = 1] = \"e_faceA\";\n  ManifoldType2[ManifoldType2[\"e_faceB\"] = 2] = \"e_faceB\";\n})(ManifoldType || (ManifoldType = {}));\nvar ContactFeatureType;\n(function(ContactFeatureType2) {\n  ContactFeatureType2[ContactFeatureType2[\"e_unset\"] = -1] = \"e_unset\";\n  ContactFeatureType2[ContactFeatureType2[\"e_vertex\"] = 0] = \"e_vertex\";\n  ContactFeatureType2[ContactFeatureType2[\"e_face\"] = 1] = \"e_face\";\n})(ContactFeatureType || (ContactFeatureType = {}));\nvar PointState;\n(function(PointState2) {\n  PointState2[PointState2[\"nullState\"] = 0] = \"nullState\";\n  PointState2[PointState2[\"addState\"] = 1] = \"addState\";\n  PointState2[PointState2[\"persistState\"] = 2] = \"persistState\";\n  PointState2[PointState2[\"removeState\"] = 3] = \"removeState\";\n})(PointState || (PointState = {}));\nvar ClipVertex = (\n  /** @class */\n  function() {\n    function ClipVertex2() {\n      this.v = vec2(0, 0);\n      this.id = new ContactID();\n    }\n    ClipVertex2.prototype.set = function(o) {\n      copyVec2(this.v, o.v);\n      this.id.set(o.id);\n    };\n    ClipVertex2.prototype.recycle = function() {\n      zeroVec2(this.v);\n      this.id.recycle();\n    };\n    return ClipVertex2;\n  }()\n);\nvar Manifold = (\n  /** @class */\n  function() {\n    function Manifold2() {\n      this.localNormal = vec2(0, 0);\n      this.localPoint = vec2(0, 0);\n      this.points = [new ManifoldPoint(), new ManifoldPoint()];\n      this.pointCount = 0;\n    }\n    Manifold2.prototype.set = function(that) {\n      this.type = that.type;\n      copyVec2(this.localNormal, that.localNormal);\n      copyVec2(this.localPoint, that.localPoint);\n      this.pointCount = that.pointCount;\n      this.points[0].set(that.points[0]);\n      this.points[1].set(that.points[1]);\n    };\n    Manifold2.prototype.recycle = function() {\n      this.type = ManifoldType.e_unset;\n      zeroVec2(this.localNormal);\n      zeroVec2(this.localPoint);\n      this.pointCount = 0;\n      this.points[0].recycle();\n      this.points[1].recycle();\n    };\n    Manifold2.prototype.getWorldManifold = function(wm, xfA2, radiusA, xfB2, radiusB) {\n      if (this.pointCount == 0) {\n        return wm;\n      }\n      wm = wm || new WorldManifold();\n      wm.pointCount = this.pointCount;\n      var normal3 = wm.normal;\n      var points = wm.points;\n      var separations = wm.separations;\n      switch (this.type) {\n        case ManifoldType.e_circles: {\n          setVec2(normal3, 1, 0);\n          var manifoldPoint = this.points[0];\n          transformVec2(pointA$1, xfA2, this.localPoint);\n          transformVec2(pointB$1, xfB2, manifoldPoint.localPoint);\n          subVec2(dist, pointB$1, pointA$1);\n          var lengthSqr = lengthSqrVec2(dist);\n          if (lengthSqr > EPSILON * EPSILON) {\n            var length_1 = math_sqrt$2(lengthSqr);\n            scaleVec2(normal3, 1 / length_1, dist);\n          }\n          combine2Vec2(cA$1, 1, pointA$1, radiusA, normal3);\n          combine2Vec2(cB$1, 1, pointB$1, -radiusB, normal3);\n          combine2Vec2(points[0], 0.5, cA$1, 0.5, cB$1);\n          separations[0] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);\n          break;\n        }\n        case ManifoldType.e_faceA: {\n          rotVec2(normal3, xfA2.q, this.localNormal);\n          transformVec2(planePoint$2, xfA2, this.localPoint);\n          for (var i = 0; i < this.pointCount; ++i) {\n            var manifoldPoint = this.points[i];\n            transformVec2(clipPoint$1, xfB2, manifoldPoint.localPoint);\n            combine2Vec2(cA$1, 1, clipPoint$1, radiusA - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);\n            combine2Vec2(cB$1, 1, clipPoint$1, -radiusB, normal3);\n            combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);\n            separations[i] = dotVec2(subVec2(temp$3, cB$1, cA$1), normal3);\n          }\n          break;\n        }\n        case ManifoldType.e_faceB: {\n          rotVec2(normal3, xfB2.q, this.localNormal);\n          transformVec2(planePoint$2, xfB2, this.localPoint);\n          for (var i = 0; i < this.pointCount; ++i) {\n            var manifoldPoint = this.points[i];\n            transformVec2(clipPoint$1, xfA2, manifoldPoint.localPoint);\n            combine2Vec2(cB$1, 1, clipPoint$1, radiusB - dotVec2(subVec2(temp$3, clipPoint$1, planePoint$2), normal3), normal3);\n            combine2Vec2(cA$1, 1, clipPoint$1, -radiusA, normal3);\n            combine2Vec2(points[i], 0.5, cA$1, 0.5, cB$1);\n            separations[i] = dotVec2(subVec2(temp$3, cA$1, cB$1), normal3);\n          }\n          negVec2(normal3);\n          break;\n        }\n      }\n      return wm;\n    };\n    Manifold2.clipSegmentToLine = clipSegmentToLine;\n    Manifold2.ClipVertex = ClipVertex;\n    Manifold2.getPointStates = getPointStates;\n    Manifold2.PointState = PointState;\n    return Manifold2;\n  }()\n);\nvar ManifoldPoint = (\n  /** @class */\n  function() {\n    function ManifoldPoint2() {\n      this.localPoint = vec2(0, 0);\n      this.normalImpulse = 0;\n      this.tangentImpulse = 0;\n      this.id = new ContactID();\n    }\n    ManifoldPoint2.prototype.set = function(that) {\n      copyVec2(this.localPoint, that.localPoint);\n      this.normalImpulse = that.normalImpulse;\n      this.tangentImpulse = that.tangentImpulse;\n      this.id.set(that.id);\n    };\n    ManifoldPoint2.prototype.recycle = function() {\n      zeroVec2(this.localPoint);\n      this.normalImpulse = 0;\n      this.tangentImpulse = 0;\n      this.id.recycle();\n    };\n    return ManifoldPoint2;\n  }()\n);\nvar ContactID = (\n  /** @class */\n  function() {\n    function ContactID2() {\n      this.key = -1;\n      this.indexA = -1;\n      this.indexB = -1;\n      this.typeA = ContactFeatureType.e_unset;\n      this.typeB = ContactFeatureType.e_unset;\n    }\n    ContactID2.prototype.setFeatures = function(indexA, typeA, indexB, typeB) {\n      this.indexA = indexA;\n      this.indexB = indexB;\n      this.typeA = typeA;\n      this.typeB = typeB;\n      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n    };\n    ContactID2.prototype.set = function(that) {\n      this.indexA = that.indexA;\n      this.indexB = that.indexB;\n      this.typeA = that.typeA;\n      this.typeB = that.typeB;\n      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n    };\n    ContactID2.prototype.swapFeatures = function() {\n      var indexA = this.indexA;\n      var indexB = this.indexB;\n      var typeA = this.typeA;\n      var typeB = this.typeB;\n      this.indexA = indexB;\n      this.indexB = indexA;\n      this.typeA = typeB;\n      this.typeB = typeA;\n      this.key = this.indexA + this.indexB * 4 + this.typeA * 16 + this.typeB * 64;\n    };\n    ContactID2.prototype.recycle = function() {\n      this.indexA = 0;\n      this.indexB = 0;\n      this.typeA = ContactFeatureType.e_unset;\n      this.typeB = ContactFeatureType.e_unset;\n      this.key = -1;\n    };\n    return ContactID2;\n  }()\n);\nvar WorldManifold = (\n  /** @class */\n  function() {\n    function WorldManifold2() {\n      this.normal = vec2(0, 0);\n      this.points = [vec2(0, 0), vec2(0, 0)];\n      this.separations = [0, 0];\n      this.pointCount = 0;\n    }\n    WorldManifold2.prototype.recycle = function() {\n      zeroVec2(this.normal);\n      zeroVec2(this.points[0]);\n      zeroVec2(this.points[1]);\n      this.separations[0] = 0;\n      this.separations[1] = 0;\n      this.pointCount = 0;\n    };\n    return WorldManifold2;\n  }()\n);\nfunction getPointStates(state1, state2, manifold1, manifold2) {\n  for (var i = 0; i < manifold1.pointCount; ++i) {\n    var id = manifold1.points[i].id;\n    state1[i] = PointState.removeState;\n    for (var j = 0; j < manifold2.pointCount; ++j) {\n      if (manifold2.points[j].id.key === id.key) {\n        state1[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n  for (var i = 0; i < manifold2.pointCount; ++i) {\n    var id = manifold2.points[i].id;\n    state2[i] = PointState.addState;\n    for (var j = 0; j < manifold1.pointCount; ++j) {\n      if (manifold1.points[j].id.key === id.key) {\n        state2[i] = PointState.persistState;\n        break;\n      }\n    }\n  }\n}\nfunction clipSegmentToLine(vOut, vIn, normal3, offset, vertexIndexA) {\n  var numOut = 0;\n  var distance0 = dotVec2(normal3, vIn[0].v) - offset;\n  var distance1 = dotVec2(normal3, vIn[1].v) - offset;\n  if (distance0 <= 0)\n    vOut[numOut++].set(vIn[0]);\n  if (distance1 <= 0)\n    vOut[numOut++].set(vIn[1]);\n  if (distance0 * distance1 < 0) {\n    var interp = distance0 / (distance0 - distance1);\n    combine2Vec2(vOut[numOut].v, 1 - interp, vIn[0].v, interp, vIn[1].v);\n    vOut[numOut].id.setFeatures(vertexIndexA, ContactFeatureType.e_vertex, vIn[0].id.indexB, ContactFeatureType.e_face);\n    ++numOut;\n  }\n  return numOut;\n}\nvar math_sqrt$1 = Math.sqrt;\nvar math_max$2 = Math.max;\nvar math_min$4 = Math.min;\nvar contactPool = new Pool({\n  create: function() {\n    return new Contact();\n  },\n  release: function(contact) {\n    contact.recycle();\n  }\n});\nvar oldManifold = new Manifold();\nvar worldManifold = new WorldManifold();\nvar ContactEdge = (\n  /** @class */\n  function() {\n    function ContactEdge2(contact) {\n      this.prev = null;\n      this.next = null;\n      this.other = null;\n      this.contact = contact;\n    }\n    ContactEdge2.prototype.recycle = function() {\n      this.prev = null;\n      this.next = null;\n      this.other = null;\n    };\n    return ContactEdge2;\n  }()\n);\nfunction mixFriction(friction1, friction2) {\n  return math_sqrt$1(friction1 * friction2);\n}\nfunction mixRestitution(restitution1, restitution2) {\n  return restitution1 > restitution2 ? restitution1 : restitution2;\n}\nvar s_registers = [];\nvar VelocityConstraintPoint = (\n  /** @class */\n  function() {\n    function VelocityConstraintPoint2() {\n      this.rA = vec2(0, 0);\n      this.rB = vec2(0, 0);\n      this.normalImpulse = 0;\n      this.tangentImpulse = 0;\n      this.normalMass = 0;\n      this.tangentMass = 0;\n      this.velocityBias = 0;\n    }\n    VelocityConstraintPoint2.prototype.recycle = function() {\n      zeroVec2(this.rA);\n      zeroVec2(this.rB);\n      this.normalImpulse = 0;\n      this.tangentImpulse = 0;\n      this.normalMass = 0;\n      this.tangentMass = 0;\n      this.velocityBias = 0;\n    };\n    return VelocityConstraintPoint2;\n  }()\n);\nvar cA = vec2(0, 0);\nvar vA = vec2(0, 0);\nvar cB = vec2(0, 0);\nvar vB = vec2(0, 0);\nvar tangent$1 = vec2(0, 0);\nvar xfA = transform(0, 0, 0);\nvar xfB = transform(0, 0, 0);\nvar pointA = vec2(0, 0);\nvar pointB = vec2(0, 0);\nvar clipPoint = vec2(0, 0);\nvar planePoint$1 = vec2(0, 0);\nvar rA = vec2(0, 0);\nvar rB = vec2(0, 0);\nvar P$1 = vec2(0, 0);\nvar normal$2 = vec2(0, 0);\nvar point = vec2(0, 0);\nvar dv = vec2(0, 0);\nvar dv1 = vec2(0, 0);\nvar dv2 = vec2(0, 0);\nvar b = vec2(0, 0);\nvar a = vec2(0, 0);\nvar x = vec2(0, 0);\nvar d = vec2(0, 0);\nvar P1 = vec2(0, 0);\nvar P2 = vec2(0, 0);\nvar temp$2 = vec2(0, 0);\nvar Contact = (\n  /** @class */\n  function() {\n    function Contact2() {\n      this.m_nodeA = new ContactEdge(this);\n      this.m_nodeB = new ContactEdge(this);\n      this.m_fixtureA = null;\n      this.m_fixtureB = null;\n      this.m_indexA = -1;\n      this.m_indexB = -1;\n      this.m_evaluateFcn = null;\n      this.m_manifold = new Manifold();\n      this.m_prev = null;\n      this.m_next = null;\n      this.m_toi = 1;\n      this.m_toiCount = 0;\n      this.m_toiFlag = false;\n      this.m_friction = 0;\n      this.m_restitution = 0;\n      this.m_tangentSpeed = 0;\n      this.m_enabledFlag = true;\n      this.m_islandFlag = false;\n      this.m_touchingFlag = false;\n      this.m_filterFlag = false;\n      this.m_bulletHitFlag = false;\n      this.m_impulse = new ContactImpulse(this);\n      this.v_points = [new VelocityConstraintPoint(), new VelocityConstraintPoint()];\n      this.v_normal = vec2(0, 0);\n      this.v_normalMass = new Mat22();\n      this.v_K = new Mat22();\n      this.v_pointCount = 0;\n      this.v_tangentSpeed = 0;\n      this.v_friction = 0;\n      this.v_restitution = 0;\n      this.v_invMassA = 0;\n      this.v_invMassB = 0;\n      this.v_invIA = 0;\n      this.v_invIB = 0;\n      this.p_localPoints = [vec2(0, 0), vec2(0, 0)];\n      this.p_localNormal = vec2(0, 0);\n      this.p_localPoint = vec2(0, 0);\n      this.p_localCenterA = vec2(0, 0);\n      this.p_localCenterB = vec2(0, 0);\n      this.p_type = ManifoldType.e_unset;\n      this.p_radiusA = 0;\n      this.p_radiusB = 0;\n      this.p_pointCount = 0;\n      this.p_invMassA = 0;\n      this.p_invMassB = 0;\n      this.p_invIA = 0;\n      this.p_invIB = 0;\n    }\n    Contact2.prototype.initialize = function(fA, indexA, fB, indexB, evaluateFcn) {\n      this.m_fixtureA = fA;\n      this.m_fixtureB = fB;\n      this.m_indexA = indexA;\n      this.m_indexB = indexB;\n      this.m_evaluateFcn = evaluateFcn;\n      this.m_friction = mixFriction(this.m_fixtureA.m_friction, this.m_fixtureB.m_friction);\n      this.m_restitution = mixRestitution(this.m_fixtureA.m_restitution, this.m_fixtureB.m_restitution);\n    };\n    Contact2.prototype.recycle = function() {\n      this.m_nodeA.recycle();\n      this.m_nodeB.recycle();\n      this.m_fixtureA = null;\n      this.m_fixtureB = null;\n      this.m_indexA = -1;\n      this.m_indexB = -1;\n      this.m_evaluateFcn = null;\n      this.m_manifold.recycle();\n      this.m_prev = null;\n      this.m_next = null;\n      this.m_toi = 1;\n      this.m_toiCount = 0;\n      this.m_toiFlag = false;\n      this.m_friction = 0;\n      this.m_restitution = 0;\n      this.m_tangentSpeed = 0;\n      this.m_enabledFlag = true;\n      this.m_islandFlag = false;\n      this.m_touchingFlag = false;\n      this.m_filterFlag = false;\n      this.m_bulletHitFlag = false;\n      this.m_impulse.recycle();\n      for (var _i = 0, _a2 = this.v_points; _i < _a2.length; _i++) {\n        var point_1 = _a2[_i];\n        point_1.recycle();\n      }\n      zeroVec2(this.v_normal);\n      this.v_normalMass.setZero();\n      this.v_K.setZero();\n      this.v_pointCount = 0;\n      this.v_tangentSpeed = 0;\n      this.v_friction = 0;\n      this.v_restitution = 0;\n      this.v_invMassA = 0;\n      this.v_invMassB = 0;\n      this.v_invIA = 0;\n      this.v_invIB = 0;\n      for (var _b = 0, _c = this.p_localPoints; _b < _c.length; _b++) {\n        var point_2 = _c[_b];\n        zeroVec2(point_2);\n      }\n      zeroVec2(this.p_localNormal);\n      zeroVec2(this.p_localPoint);\n      zeroVec2(this.p_localCenterA);\n      zeroVec2(this.p_localCenterB);\n      this.p_type = ManifoldType.e_unset;\n      this.p_radiusA = 0;\n      this.p_radiusB = 0;\n      this.p_pointCount = 0;\n      this.p_invMassA = 0;\n      this.p_invMassB = 0;\n      this.p_invIA = 0;\n      this.p_invIB = 0;\n    };\n    Contact2.prototype.initConstraint = function(step) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var shapeA = fixtureA.m_shape;\n      var shapeB = fixtureB.m_shape;\n      if (shapeA === null || shapeB === null)\n        return;\n      var manifold = this.m_manifold;\n      var pointCount = manifold.pointCount;\n      this.v_invMassA = bodyA.m_invMass;\n      this.v_invMassB = bodyB.m_invMass;\n      this.v_invIA = bodyA.m_invI;\n      this.v_invIB = bodyB.m_invI;\n      this.v_friction = this.m_friction;\n      this.v_restitution = this.m_restitution;\n      this.v_tangentSpeed = this.m_tangentSpeed;\n      this.v_pointCount = pointCount;\n      this.v_K.setZero();\n      this.v_normalMass.setZero();\n      this.p_invMassA = bodyA.m_invMass;\n      this.p_invMassB = bodyB.m_invMass;\n      this.p_invIA = bodyA.m_invI;\n      this.p_invIB = bodyB.m_invI;\n      copyVec2(this.p_localCenterA, bodyA.m_sweep.localCenter);\n      copyVec2(this.p_localCenterB, bodyB.m_sweep.localCenter);\n      this.p_radiusA = shapeA.m_radius;\n      this.p_radiusB = shapeB.m_radius;\n      this.p_type = manifold.type;\n      copyVec2(this.p_localNormal, manifold.localNormal);\n      copyVec2(this.p_localPoint, manifold.localPoint);\n      this.p_pointCount = pointCount;\n      for (var j = 0; j < SettingsInternal.maxManifoldPoints; ++j) {\n        this.v_points[j].recycle();\n        zeroVec2(this.p_localPoints[j]);\n      }\n      for (var j = 0; j < pointCount; ++j) {\n        var cp = manifold.points[j];\n        var vcp = this.v_points[j];\n        if (step.warmStarting) {\n          vcp.normalImpulse = step.dtRatio * cp.normalImpulse;\n          vcp.tangentImpulse = step.dtRatio * cp.tangentImpulse;\n        }\n        copyVec2(this.p_localPoints[j], cp.localPoint);\n      }\n    };\n    Contact2.prototype.getManifold = function() {\n      return this.m_manifold;\n    };\n    Contact2.prototype.getWorldManifold = function(worldManifold2) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var shapeA = fixtureA.m_shape;\n      var shapeB = fixtureB.m_shape;\n      if (shapeA === null || shapeB === null)\n        return;\n      return this.m_manifold.getWorldManifold(worldManifold2, bodyA.getTransform(), shapeA.m_radius, bodyB.getTransform(), shapeB.m_radius);\n    };\n    Contact2.prototype.setEnabled = function(flag) {\n      this.m_enabledFlag = !!flag;\n    };\n    Contact2.prototype.isEnabled = function() {\n      return this.m_enabledFlag;\n    };\n    Contact2.prototype.isTouching = function() {\n      return this.m_touchingFlag;\n    };\n    Contact2.prototype.getNext = function() {\n      return this.m_next;\n    };\n    Contact2.prototype.getFixtureA = function() {\n      return this.m_fixtureA;\n    };\n    Contact2.prototype.getFixtureB = function() {\n      return this.m_fixtureB;\n    };\n    Contact2.prototype.getChildIndexA = function() {\n      return this.m_indexA;\n    };\n    Contact2.prototype.getChildIndexB = function() {\n      return this.m_indexB;\n    };\n    Contact2.prototype.flagForFiltering = function() {\n      this.m_filterFlag = true;\n    };\n    Contact2.prototype.setFriction = function(friction) {\n      this.m_friction = friction;\n    };\n    Contact2.prototype.getFriction = function() {\n      return this.m_friction;\n    };\n    Contact2.prototype.resetFriction = function() {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      this.m_friction = mixFriction(fixtureA.m_friction, fixtureB.m_friction);\n    };\n    Contact2.prototype.setRestitution = function(restitution) {\n      this.m_restitution = restitution;\n    };\n    Contact2.prototype.getRestitution = function() {\n      return this.m_restitution;\n    };\n    Contact2.prototype.resetRestitution = function() {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      this.m_restitution = mixRestitution(fixtureA.m_restitution, fixtureB.m_restitution);\n    };\n    Contact2.prototype.setTangentSpeed = function(speed) {\n      this.m_tangentSpeed = speed;\n    };\n    Contact2.prototype.getTangentSpeed = function() {\n      return this.m_tangentSpeed;\n    };\n    Contact2.prototype.evaluate = function(manifold, xfA2, xfB2) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      this.m_evaluateFcn(manifold, xfA2, fixtureA, this.m_indexA, xfB2, fixtureB, this.m_indexB);\n    };\n    Contact2.prototype.update = function(listener) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var shapeA = fixtureA.m_shape;\n      var shapeB = fixtureB.m_shape;\n      if (shapeA === null || shapeB === null)\n        return;\n      this.m_enabledFlag = true;\n      var touching = false;\n      var wasTouching = this.m_touchingFlag;\n      var sensorA = fixtureA.m_isSensor;\n      var sensorB = fixtureB.m_isSensor;\n      var sensor = sensorA || sensorB;\n      var xfA2 = bodyA.m_xf;\n      var xfB2 = bodyB.m_xf;\n      if (sensor) {\n        touching = testOverlap(shapeA, this.m_indexA, shapeB, this.m_indexB, xfA2, xfB2);\n        this.m_manifold.pointCount = 0;\n      } else {\n        oldManifold.recycle();\n        oldManifold.set(this.m_manifold);\n        this.m_manifold.recycle();\n        this.evaluate(this.m_manifold, xfA2, xfB2);\n        touching = this.m_manifold.pointCount > 0;\n        for (var i = 0; i < this.m_manifold.pointCount; ++i) {\n          var nmp = this.m_manifold.points[i];\n          nmp.normalImpulse = 0;\n          nmp.tangentImpulse = 0;\n          for (var j = 0; j < oldManifold.pointCount; ++j) {\n            var omp = oldManifold.points[j];\n            if (omp.id.key === nmp.id.key) {\n              nmp.normalImpulse = omp.normalImpulse;\n              nmp.tangentImpulse = omp.tangentImpulse;\n              break;\n            }\n          }\n        }\n        if (touching !== wasTouching) {\n          bodyA.setAwake(true);\n          bodyB.setAwake(true);\n        }\n      }\n      this.m_touchingFlag = touching;\n      var hasListener = typeof listener === \"object\" && listener !== null;\n      if (!wasTouching && touching && hasListener) {\n        listener.beginContact(this);\n      }\n      if (wasTouching && !touching && hasListener) {\n        listener.endContact(this);\n      }\n      if (!sensor && touching && hasListener && oldManifold) {\n        listener.preSolve(this, oldManifold);\n      }\n    };\n    Contact2.prototype.solvePositionConstraint = function(step) {\n      return this._solvePositionConstraint(step, null, null);\n    };\n    Contact2.prototype.solvePositionConstraintTOI = function(step, toiA, toiB) {\n      return this._solvePositionConstraint(step, toiA, toiB);\n    };\n    Contact2.prototype._solvePositionConstraint = function(step, toiA, toiB) {\n      var toi = toiA !== null && toiB !== null ? true : false;\n      var minSeparation = 0;\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return minSeparation;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return minSeparation;\n      bodyA.c_velocity;\n      bodyB.c_velocity;\n      var positionA = bodyA.c_position;\n      var positionB = bodyB.c_position;\n      var localCenterA = this.p_localCenterA;\n      var localCenterB = this.p_localCenterB;\n      var mA = 0;\n      var iA = 0;\n      if (!toi || (bodyA === toiA || bodyA === toiB)) {\n        mA = this.p_invMassA;\n        iA = this.p_invIA;\n      }\n      var mB = 0;\n      var iB = 0;\n      if (!toi || (bodyB === toiA || bodyB === toiB)) {\n        mB = this.p_invMassB;\n        iB = this.p_invIB;\n      }\n      copyVec2(cA, positionA.c);\n      var aA = positionA.a;\n      copyVec2(cB, positionB.c);\n      var aB = positionB.a;\n      for (var j = 0; j < this.p_pointCount; ++j) {\n        getTransform(xfA, localCenterA, cA, aA);\n        getTransform(xfB, localCenterB, cB, aB);\n        var separation = void 0;\n        switch (this.p_type) {\n          case ManifoldType.e_circles: {\n            transformVec2(pointA, xfA, this.p_localPoint);\n            transformVec2(pointB, xfB, this.p_localPoints[0]);\n            subVec2(normal$2, pointB, pointA);\n            normalizeVec2(normal$2);\n            combine2Vec2(point, 0.5, pointA, 0.5, pointB);\n            separation = dotVec2(pointB, normal$2) - dotVec2(pointA, normal$2) - this.p_radiusA - this.p_radiusB;\n            break;\n          }\n          case ManifoldType.e_faceA: {\n            rotVec2(normal$2, xfA.q, this.p_localNormal);\n            transformVec2(planePoint$1, xfA, this.p_localPoint);\n            transformVec2(clipPoint, xfB, this.p_localPoints[j]);\n            separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;\n            copyVec2(point, clipPoint);\n            break;\n          }\n          case ManifoldType.e_faceB: {\n            rotVec2(normal$2, xfB.q, this.p_localNormal);\n            transformVec2(planePoint$1, xfB, this.p_localPoint);\n            transformVec2(clipPoint, xfA, this.p_localPoints[j]);\n            separation = dotVec2(clipPoint, normal$2) - dotVec2(planePoint$1, normal$2) - this.p_radiusA - this.p_radiusB;\n            copyVec2(point, clipPoint);\n            negVec2(normal$2);\n            break;\n          }\n          default: {\n            return minSeparation;\n          }\n        }\n        subVec2(rA, point, cA);\n        subVec2(rB, point, cB);\n        minSeparation = math_min$4(minSeparation, separation);\n        var baumgarte = toi ? SettingsInternal.toiBaugarte : SettingsInternal.baumgarte;\n        var linearSlop = SettingsInternal.linearSlop;\n        var maxLinearCorrection = SettingsInternal.maxLinearCorrection;\n        var C = clamp(baumgarte * (separation + linearSlop), -maxLinearCorrection, 0);\n        var rnA = crossVec2Vec2(rA, normal$2);\n        var rnB = crossVec2Vec2(rB, normal$2);\n        var K = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n        var impulse = K > 0 ? -C / K : 0;\n        scaleVec2(P$1, impulse, normal$2);\n        minusScaleVec2(cA, mA, P$1);\n        aA -= iA * crossVec2Vec2(rA, P$1);\n        plusScaleVec2(cB, mB, P$1);\n        aB += iB * crossVec2Vec2(rB, P$1);\n      }\n      copyVec2(positionA.c, cA);\n      positionA.a = aA;\n      copyVec2(positionB.c, cB);\n      positionB.a = aB;\n      return minSeparation;\n    };\n    Contact2.prototype.initVelocityConstraint = function(step) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var velocityA = bodyA.c_velocity;\n      var velocityB = bodyB.c_velocity;\n      var positionA = bodyA.c_position;\n      var positionB = bodyB.c_position;\n      var radiusA = this.p_radiusA;\n      var radiusB = this.p_radiusB;\n      var manifold = this.m_manifold;\n      var mA = this.v_invMassA;\n      var mB = this.v_invMassB;\n      var iA = this.v_invIA;\n      var iB = this.v_invIB;\n      var localCenterA = this.p_localCenterA;\n      var localCenterB = this.p_localCenterB;\n      copyVec2(cA, positionA.c);\n      var aA = positionA.a;\n      copyVec2(vA, velocityA.v);\n      var wA = velocityA.w;\n      copyVec2(cB, positionB.c);\n      var aB = positionB.a;\n      copyVec2(vB, velocityB.v);\n      var wB = velocityB.w;\n      getTransform(xfA, localCenterA, cA, aA);\n      getTransform(xfB, localCenterB, cB, aB);\n      worldManifold.recycle();\n      manifold.getWorldManifold(worldManifold, xfA, radiusA, xfB, radiusB);\n      copyVec2(this.v_normal, worldManifold.normal);\n      for (var j = 0; j < this.v_pointCount; ++j) {\n        var vcp = this.v_points[j];\n        var wmp = worldManifold.points[j];\n        subVec2(vcp.rA, wmp, cA);\n        subVec2(vcp.rB, wmp, cB);\n        var rnA = crossVec2Vec2(vcp.rA, this.v_normal);\n        var rnB = crossVec2Vec2(vcp.rB, this.v_normal);\n        var kNormal = mA + mB + iA * rnA * rnA + iB * rnB * rnB;\n        vcp.normalMass = kNormal > 0 ? 1 / kNormal : 0;\n        crossVec2Num(tangent$1, this.v_normal, 1);\n        var rtA = crossVec2Vec2(vcp.rA, tangent$1);\n        var rtB = crossVec2Vec2(vcp.rB, tangent$1);\n        var kTangent = mA + mB + iA * rtA * rtA + iB * rtB * rtB;\n        vcp.tangentMass = kTangent > 0 ? 1 / kTangent : 0;\n        vcp.velocityBias = 0;\n        var vRel = 0;\n        vRel += dotVec2(this.v_normal, vB);\n        vRel += dotVec2(this.v_normal, crossNumVec2(temp$2, wB, vcp.rB));\n        vRel -= dotVec2(this.v_normal, vA);\n        vRel -= dotVec2(this.v_normal, crossNumVec2(temp$2, wA, vcp.rA));\n        if (vRel < -SettingsInternal.velocityThreshold) {\n          vcp.velocityBias = -this.v_restitution * vRel;\n        }\n      }\n      if (this.v_pointCount == 2 && step.blockSolve) {\n        var vcp1 = this.v_points[0];\n        var vcp2 = this.v_points[1];\n        var rn1A = crossVec2Vec2(vcp1.rA, this.v_normal);\n        var rn1B = crossVec2Vec2(vcp1.rB, this.v_normal);\n        var rn2A = crossVec2Vec2(vcp2.rA, this.v_normal);\n        var rn2B = crossVec2Vec2(vcp2.rB, this.v_normal);\n        var k11 = mA + mB + iA * rn1A * rn1A + iB * rn1B * rn1B;\n        var k22 = mA + mB + iA * rn2A * rn2A + iB * rn2B * rn2B;\n        var k12 = mA + mB + iA * rn1A * rn2A + iB * rn1B * rn2B;\n        var k_maxConditionNumber = 1e3;\n        if (k11 * k11 < k_maxConditionNumber * (k11 * k22 - k12 * k12)) {\n          this.v_K.ex.setNum(k11, k12);\n          this.v_K.ey.setNum(k12, k22);\n          var a_1 = this.v_K.ex.x;\n          var b_1 = this.v_K.ey.x;\n          var c2 = this.v_K.ex.y;\n          var d_1 = this.v_K.ey.y;\n          var det = a_1 * d_1 - b_1 * c2;\n          if (det !== 0) {\n            det = 1 / det;\n          }\n          this.v_normalMass.ex.x = det * d_1;\n          this.v_normalMass.ey.x = -det * b_1;\n          this.v_normalMass.ex.y = -det * c2;\n          this.v_normalMass.ey.y = det * a_1;\n        } else {\n          this.v_pointCount = 1;\n        }\n      }\n      copyVec2(positionA.c, cA);\n      positionA.a = aA;\n      copyVec2(velocityA.v, vA);\n      velocityA.w = wA;\n      copyVec2(positionB.c, cB);\n      positionB.a = aB;\n      copyVec2(velocityB.v, vB);\n      velocityB.w = wB;\n    };\n    Contact2.prototype.warmStartConstraint = function(step) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var velocityA = bodyA.c_velocity;\n      var velocityB = bodyB.c_velocity;\n      bodyA.c_position;\n      bodyB.c_position;\n      var mA = this.v_invMassA;\n      var iA = this.v_invIA;\n      var mB = this.v_invMassB;\n      var iB = this.v_invIB;\n      copyVec2(vA, velocityA.v);\n      var wA = velocityA.w;\n      copyVec2(vB, velocityB.v);\n      var wB = velocityB.w;\n      copyVec2(normal$2, this.v_normal);\n      crossVec2Num(tangent$1, normal$2, 1);\n      for (var j = 0; j < this.v_pointCount; ++j) {\n        var vcp = this.v_points[j];\n        combine2Vec2(P$1, vcp.normalImpulse, normal$2, vcp.tangentImpulse, tangent$1);\n        wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n        minusScaleVec2(vA, mA, P$1);\n        wB += iB * crossVec2Vec2(vcp.rB, P$1);\n        plusScaleVec2(vB, mB, P$1);\n      }\n      copyVec2(velocityA.v, vA);\n      velocityA.w = wA;\n      copyVec2(velocityB.v, vB);\n      velocityB.w = wB;\n    };\n    Contact2.prototype.storeConstraintImpulses = function(step) {\n      var manifold = this.m_manifold;\n      for (var j = 0; j < this.v_pointCount; ++j) {\n        manifold.points[j].normalImpulse = this.v_points[j].normalImpulse;\n        manifold.points[j].tangentImpulse = this.v_points[j].tangentImpulse;\n      }\n    };\n    Contact2.prototype.solveVelocityConstraint = function(step) {\n      var fixtureA = this.m_fixtureA;\n      var fixtureB = this.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      var velocityA = bodyA.c_velocity;\n      bodyA.c_position;\n      var velocityB = bodyB.c_velocity;\n      bodyB.c_position;\n      var mA = this.v_invMassA;\n      var iA = this.v_invIA;\n      var mB = this.v_invMassB;\n      var iB = this.v_invIB;\n      copyVec2(vA, velocityA.v);\n      var wA = velocityA.w;\n      copyVec2(vB, velocityB.v);\n      var wB = velocityB.w;\n      copyVec2(normal$2, this.v_normal);\n      crossVec2Num(tangent$1, normal$2, 1);\n      var friction = this.v_friction;\n      for (var j = 0; j < this.v_pointCount; ++j) {\n        var vcp = this.v_points[j];\n        zeroVec2(dv);\n        plusVec2(dv, vB);\n        plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));\n        minusVec2(dv, vA);\n        minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));\n        var vt = dotVec2(dv, tangent$1) - this.v_tangentSpeed;\n        var lambda = vcp.tangentMass * -vt;\n        var maxFriction = friction * vcp.normalImpulse;\n        var newImpulse = clamp(vcp.tangentImpulse + lambda, -maxFriction, maxFriction);\n        lambda = newImpulse - vcp.tangentImpulse;\n        vcp.tangentImpulse = newImpulse;\n        scaleVec2(P$1, lambda, tangent$1);\n        minusScaleVec2(vA, mA, P$1);\n        wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n        plusScaleVec2(vB, mB, P$1);\n        wB += iB * crossVec2Vec2(vcp.rB, P$1);\n      }\n      if (this.v_pointCount == 1 || step.blockSolve == false) {\n        for (var i = 0; i < this.v_pointCount; ++i) {\n          var vcp = this.v_points[i];\n          zeroVec2(dv);\n          plusVec2(dv, vB);\n          plusVec2(dv, crossNumVec2(temp$2, wB, vcp.rB));\n          minusVec2(dv, vA);\n          minusVec2(dv, crossNumVec2(temp$2, wA, vcp.rA));\n          var vn = dotVec2(dv, normal$2);\n          var lambda = -vcp.normalMass * (vn - vcp.velocityBias);\n          var newImpulse = math_max$2(vcp.normalImpulse + lambda, 0);\n          lambda = newImpulse - vcp.normalImpulse;\n          vcp.normalImpulse = newImpulse;\n          scaleVec2(P$1, lambda, normal$2);\n          minusScaleVec2(vA, mA, P$1);\n          wA -= iA * crossVec2Vec2(vcp.rA, P$1);\n          plusScaleVec2(vB, mB, P$1);\n          wB += iB * crossVec2Vec2(vcp.rB, P$1);\n        }\n      } else {\n        var vcp1 = this.v_points[0];\n        var vcp2 = this.v_points[1];\n        setVec2(a, vcp1.normalImpulse, vcp2.normalImpulse);\n        zeroVec2(dv1);\n        plusVec2(dv1, vB);\n        plusVec2(dv1, crossNumVec2(temp$2, wB, vcp1.rB));\n        minusVec2(dv1, vA);\n        minusVec2(dv1, crossNumVec2(temp$2, wA, vcp1.rA));\n        zeroVec2(dv2);\n        plusVec2(dv2, vB);\n        plusVec2(dv2, crossNumVec2(temp$2, wB, vcp2.rB));\n        minusVec2(dv2, vA);\n        minusVec2(dv2, crossNumVec2(temp$2, wA, vcp2.rA));\n        var vn1 = dotVec2(dv1, normal$2);\n        var vn2 = dotVec2(dv2, normal$2);\n        setVec2(b, vn1 - vcp1.velocityBias, vn2 - vcp2.velocityBias);\n        b.x -= this.v_K.ex.x * a.x + this.v_K.ey.x * a.y;\n        b.y -= this.v_K.ex.y * a.x + this.v_K.ey.y * a.y;\n        while (true) {\n          zeroVec2(x);\n          x.x = -(this.v_normalMass.ex.x * b.x + this.v_normalMass.ey.x * b.y);\n          x.y = -(this.v_normalMass.ex.y * b.x + this.v_normalMass.ey.y * b.y);\n          if (x.x >= 0 && x.y >= 0) {\n            subVec2(d, x, a);\n            scaleVec2(P1, d.x, normal$2);\n            scaleVec2(P2, d.y, normal$2);\n            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n            vcp1.normalImpulse = x.x;\n            vcp2.normalImpulse = x.y;\n            break;\n          }\n          x.x = -vcp1.normalMass * b.x;\n          x.y = 0;\n          vn1 = 0;\n          vn2 = this.v_K.ex.y * x.x + b.y;\n          if (x.x >= 0 && vn2 >= 0) {\n            subVec2(d, x, a);\n            scaleVec2(P1, d.x, normal$2);\n            scaleVec2(P2, d.y, normal$2);\n            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n            vcp1.normalImpulse = x.x;\n            vcp2.normalImpulse = x.y;\n            break;\n          }\n          x.x = 0;\n          x.y = -vcp2.normalMass * b.y;\n          vn1 = this.v_K.ey.x * x.y + b.x;\n          vn2 = 0;\n          if (x.y >= 0 && vn1 >= 0) {\n            subVec2(d, x, a);\n            scaleVec2(P1, d.x, normal$2);\n            scaleVec2(P2, d.y, normal$2);\n            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n            vcp1.normalImpulse = x.x;\n            vcp2.normalImpulse = x.y;\n            break;\n          }\n          x.x = 0;\n          x.y = 0;\n          vn1 = b.x;\n          vn2 = b.y;\n          if (vn1 >= 0 && vn2 >= 0) {\n            subVec2(d, x, a);\n            scaleVec2(P1, d.x, normal$2);\n            scaleVec2(P2, d.y, normal$2);\n            combine3Vec2(vA, -mA, P1, -mA, P2, 1, vA);\n            wA -= iA * (crossVec2Vec2(vcp1.rA, P1) + crossVec2Vec2(vcp2.rA, P2));\n            combine3Vec2(vB, mB, P1, mB, P2, 1, vB);\n            wB += iB * (crossVec2Vec2(vcp1.rB, P1) + crossVec2Vec2(vcp2.rB, P2));\n            vcp1.normalImpulse = x.x;\n            vcp2.normalImpulse = x.y;\n            break;\n          }\n          break;\n        }\n      }\n      copyVec2(velocityA.v, vA);\n      velocityA.w = wA;\n      copyVec2(velocityB.v, vB);\n      velocityB.w = wB;\n    };\n    Contact2.addType = function(type1, type2, callback) {\n      s_registers[type1] = s_registers[type1] || {};\n      s_registers[type1][type2] = callback;\n    };\n    Contact2.create = function(fixtureA, indexA, fixtureB, indexB) {\n      var typeA = fixtureA.m_shape.m_type;\n      var typeB = fixtureB.m_shape.m_type;\n      var contact = contactPool.allocate();\n      var evaluateFcn;\n      if (evaluateFcn = s_registers[typeA] && s_registers[typeA][typeB]) {\n        contact.initialize(fixtureA, indexA, fixtureB, indexB, evaluateFcn);\n      } else if (evaluateFcn = s_registers[typeB] && s_registers[typeB][typeA]) {\n        contact.initialize(fixtureB, indexB, fixtureA, indexA, evaluateFcn);\n      } else {\n        return null;\n      }\n      fixtureA = contact.m_fixtureA;\n      fixtureB = contact.m_fixtureB;\n      indexA = contact.getChildIndexA();\n      indexB = contact.getChildIndexB();\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      contact.m_nodeA.contact = contact;\n      contact.m_nodeA.other = bodyB;\n      contact.m_nodeA.prev = null;\n      contact.m_nodeA.next = bodyA.m_contactList;\n      if (bodyA.m_contactList != null) {\n        bodyA.m_contactList.prev = contact.m_nodeA;\n      }\n      bodyA.m_contactList = contact.m_nodeA;\n      contact.m_nodeB.contact = contact;\n      contact.m_nodeB.other = bodyA;\n      contact.m_nodeB.prev = null;\n      contact.m_nodeB.next = bodyB.m_contactList;\n      if (bodyB.m_contactList != null) {\n        bodyB.m_contactList.prev = contact.m_nodeB;\n      }\n      bodyB.m_contactList = contact.m_nodeB;\n      if (fixtureA.isSensor() == false && fixtureB.isSensor() == false) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n      return contact;\n    };\n    Contact2.destroy = function(contact, listener) {\n      var fixtureA = contact.m_fixtureA;\n      var fixtureB = contact.m_fixtureB;\n      if (fixtureA === null || fixtureB === null)\n        return;\n      var bodyA = fixtureA.m_body;\n      var bodyB = fixtureB.m_body;\n      if (bodyA === null || bodyB === null)\n        return;\n      if (contact.isTouching()) {\n        listener.endContact(contact);\n      }\n      if (contact.m_nodeA.prev) {\n        contact.m_nodeA.prev.next = contact.m_nodeA.next;\n      }\n      if (contact.m_nodeA.next) {\n        contact.m_nodeA.next.prev = contact.m_nodeA.prev;\n      }\n      if (contact.m_nodeA == bodyA.m_contactList) {\n        bodyA.m_contactList = contact.m_nodeA.next;\n      }\n      if (contact.m_nodeB.prev) {\n        contact.m_nodeB.prev.next = contact.m_nodeB.next;\n      }\n      if (contact.m_nodeB.next) {\n        contact.m_nodeB.next.prev = contact.m_nodeB.prev;\n      }\n      if (contact.m_nodeB == bodyB.m_contactList) {\n        bodyB.m_contactList = contact.m_nodeB.next;\n      }\n      if (contact.m_manifold.pointCount > 0 && !fixtureA.m_isSensor && !fixtureB.m_isSensor) {\n        bodyA.setAwake(true);\n        bodyB.setAwake(true);\n      }\n      contactPool.release(contact);\n    };\n    return Contact2;\n  }()\n);\nvar DEFAULTS$b = {\n  gravity: Vec2.zero(),\n  allowSleep: true,\n  warmStarting: true,\n  continuousPhysics: true,\n  subStepping: false,\n  blockSolve: true,\n  velocityIterations: 8,\n  positionIterations: 3\n};\nvar World = (\n  /** @class */\n  function() {\n    function World2(def) {\n      if (!(this instanceof World2)) {\n        return new World2(def);\n      }\n      this.s_step = new TimeStep();\n      if (!def) {\n        def = {};\n      } else if (Vec2.isValid(def)) {\n        def = { gravity: def };\n      }\n      def = options(def, DEFAULTS$b);\n      this.m_solver = new Solver(this);\n      this.m_broadPhase = new BroadPhase();\n      this.m_contactList = null;\n      this.m_contactCount = 0;\n      this.m_bodyList = null;\n      this.m_bodyCount = 0;\n      this.m_jointList = null;\n      this.m_jointCount = 0;\n      this.m_stepComplete = true;\n      this.m_allowSleep = def.allowSleep;\n      this.m_gravity = Vec2.clone(def.gravity);\n      this.m_clearForces = true;\n      this.m_newFixture = false;\n      this.m_locked = false;\n      this.m_warmStarting = def.warmStarting;\n      this.m_continuousPhysics = def.continuousPhysics;\n      this.m_subStepping = def.subStepping;\n      this.m_blockSolve = def.blockSolve;\n      this.m_velocityIterations = def.velocityIterations;\n      this.m_positionIterations = def.positionIterations;\n      this.m_t = 0;\n      this.m_step_callback = [];\n    }\n    World2.prototype._serialize = function() {\n      var bodies = [];\n      var joints = [];\n      for (var b2 = this.getBodyList(); b2; b2 = b2.getNext()) {\n        bodies.push(b2);\n      }\n      for (var j = this.getJointList(); j; j = j.getNext()) {\n        if (typeof j._serialize === \"function\") {\n          joints.push(j);\n        }\n      }\n      return {\n        gravity: this.m_gravity,\n        bodies,\n        joints\n      };\n    };\n    World2._deserialize = function(data, context, restore) {\n      if (!data) {\n        return new World2();\n      }\n      var world = new World2(data.gravity);\n      if (data.bodies) {\n        for (var i = data.bodies.length - 1; i >= 0; i -= 1) {\n          world._addBody(restore(Body, data.bodies[i], world));\n        }\n      }\n      if (data.joints) {\n        for (var i = data.joints.length - 1; i >= 0; i--) {\n          world.createJoint(restore(Joint, data.joints[i], world));\n        }\n      }\n      return world;\n    };\n    World2.prototype.getBodyList = function() {\n      return this.m_bodyList;\n    };\n    World2.prototype.getJointList = function() {\n      return this.m_jointList;\n    };\n    World2.prototype.getContactList = function() {\n      return this.m_contactList;\n    };\n    World2.prototype.getBodyCount = function() {\n      return this.m_bodyCount;\n    };\n    World2.prototype.getJointCount = function() {\n      return this.m_jointCount;\n    };\n    World2.prototype.getContactCount = function() {\n      return this.m_contactCount;\n    };\n    World2.prototype.setGravity = function(gravity) {\n      this.m_gravity.set(gravity);\n    };\n    World2.prototype.getGravity = function() {\n      return this.m_gravity;\n    };\n    World2.prototype.isLocked = function() {\n      return this.m_locked;\n    };\n    World2.prototype.setAllowSleeping = function(flag) {\n      if (flag == this.m_allowSleep) {\n        return;\n      }\n      this.m_allowSleep = flag;\n      if (this.m_allowSleep == false) {\n        for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {\n          b2.setAwake(true);\n        }\n      }\n    };\n    World2.prototype.getAllowSleeping = function() {\n      return this.m_allowSleep;\n    };\n    World2.prototype.setWarmStarting = function(flag) {\n      this.m_warmStarting = flag;\n    };\n    World2.prototype.getWarmStarting = function() {\n      return this.m_warmStarting;\n    };\n    World2.prototype.setContinuousPhysics = function(flag) {\n      this.m_continuousPhysics = flag;\n    };\n    World2.prototype.getContinuousPhysics = function() {\n      return this.m_continuousPhysics;\n    };\n    World2.prototype.setSubStepping = function(flag) {\n      this.m_subStepping = flag;\n    };\n    World2.prototype.getSubStepping = function() {\n      return this.m_subStepping;\n    };\n    World2.prototype.setAutoClearForces = function(flag) {\n      this.m_clearForces = flag;\n    };\n    World2.prototype.getAutoClearForces = function() {\n      return this.m_clearForces;\n    };\n    World2.prototype.clearForces = function() {\n      for (var body = this.m_bodyList; body; body = body.getNext()) {\n        body.m_force.setZero();\n        body.m_torque = 0;\n      }\n    };\n    World2.prototype.queryAABB = function(aabb, callback) {\n      var broadPhase = this.m_broadPhase;\n      this.m_broadPhase.query(aabb, function(proxyId) {\n        var proxy = broadPhase.getUserData(proxyId);\n        return callback(proxy.fixture);\n      });\n    };\n    World2.prototype.rayCast = function(point1, point2, callback) {\n      var broadPhase = this.m_broadPhase;\n      this.m_broadPhase.rayCast({\n        maxFraction: 1,\n        p1: point1,\n        p2: point2\n      }, function(input2, proxyId) {\n        var proxy = broadPhase.getUserData(proxyId);\n        var fixture = proxy.fixture;\n        var index = proxy.childIndex;\n        var output2 = {};\n        var hit = fixture.rayCast(output2, input2, index);\n        if (hit) {\n          var fraction = output2.fraction;\n          var point3 = Vec2.add(Vec2.mulNumVec2(1 - fraction, input2.p1), Vec2.mulNumVec2(fraction, input2.p2));\n          return callback(fixture, point3, output2.normal, fraction);\n        }\n        return input2.maxFraction;\n      });\n    };\n    World2.prototype.getProxyCount = function() {\n      return this.m_broadPhase.getProxyCount();\n    };\n    World2.prototype.getTreeHeight = function() {\n      return this.m_broadPhase.getTreeHeight();\n    };\n    World2.prototype.getTreeBalance = function() {\n      return this.m_broadPhase.getTreeBalance();\n    };\n    World2.prototype.getTreeQuality = function() {\n      return this.m_broadPhase.getTreeQuality();\n    };\n    World2.prototype.shiftOrigin = function(newOrigin) {\n      if (this.isLocked()) {\n        return;\n      }\n      for (var b2 = this.m_bodyList; b2; b2 = b2.m_next) {\n        b2.m_xf.p.sub(newOrigin);\n        b2.m_sweep.c0.sub(newOrigin);\n        b2.m_sweep.c.sub(newOrigin);\n      }\n      for (var j = this.m_jointList; j; j = j.m_next) {\n        j.shiftOrigin(newOrigin);\n      }\n      this.m_broadPhase.shiftOrigin(newOrigin);\n    };\n    World2.prototype._addBody = function(body) {\n      if (this.isLocked()) {\n        return;\n      }\n      body.m_prev = null;\n      body.m_next = this.m_bodyList;\n      if (this.m_bodyList) {\n        this.m_bodyList.m_prev = body;\n      }\n      this.m_bodyList = body;\n      ++this.m_bodyCount;\n    };\n    World2.prototype.createBody = function(arg1, arg2) {\n      if (this.isLocked()) {\n        return null;\n      }\n      var def = {};\n      if (!arg1) ;\n      else if (Vec2.isValid(arg1)) {\n        def = { position: arg1, angle: arg2 };\n      } else if (typeof arg1 === \"object\") {\n        def = arg1;\n      }\n      var body = new Body(this, def);\n      this._addBody(body);\n      return body;\n    };\n    World2.prototype.createDynamicBody = function(arg1, arg2) {\n      var def = {};\n      if (!arg1) ;\n      else if (Vec2.isValid(arg1)) {\n        def = { position: arg1, angle: arg2 };\n      } else if (typeof arg1 === \"object\") {\n        def = arg1;\n      }\n      def.type = \"dynamic\";\n      return this.createBody(def);\n    };\n    World2.prototype.createKinematicBody = function(arg1, arg2) {\n      var def = {};\n      if (!arg1) ;\n      else if (Vec2.isValid(arg1)) {\n        def = { position: arg1, angle: arg2 };\n      } else if (typeof arg1 === \"object\") {\n        def = arg1;\n      }\n      def.type = \"kinematic\";\n      return this.createBody(def);\n    };\n    World2.prototype.destroyBody = function(b2) {\n      if (this.isLocked()) {\n        return;\n      }\n      if (b2.m_destroyed) {\n        return false;\n      }\n      var je = b2.m_jointList;\n      while (je) {\n        var je0 = je;\n        je = je.next;\n        this.publish(\"remove-joint\", je0.joint);\n        this.destroyJoint(je0.joint);\n        b2.m_jointList = je;\n      }\n      b2.m_jointList = null;\n      var ce = b2.m_contactList;\n      while (ce) {\n        var ce0 = ce;\n        ce = ce.next;\n        this.destroyContact(ce0.contact);\n        b2.m_contactList = ce;\n      }\n      b2.m_contactList = null;\n      var f = b2.m_fixtureList;\n      while (f) {\n        var f0 = f;\n        f = f.m_next;\n        this.publish(\"remove-fixture\", f0);\n        f0.destroyProxies(this.m_broadPhase);\n        b2.m_fixtureList = f;\n      }\n      b2.m_fixtureList = null;\n      if (b2.m_prev) {\n        b2.m_prev.m_next = b2.m_next;\n      }\n      if (b2.m_next) {\n        b2.m_next.m_prev = b2.m_prev;\n      }\n      if (b2 == this.m_bodyList) {\n        this.m_bodyList = b2.m_next;\n      }\n      b2.m_destroyed = true;\n      --this.m_bodyCount;\n      this.publish(\"remove-body\", b2);\n      return true;\n    };\n    World2.prototype.createJoint = function(joint) {\n      if (this.isLocked()) {\n        return null;\n      }\n      joint.m_prev = null;\n      joint.m_next = this.m_jointList;\n      if (this.m_jointList) {\n        this.m_jointList.m_prev = joint;\n      }\n      this.m_jointList = joint;\n      ++this.m_jointCount;\n      joint.m_edgeA.joint = joint;\n      joint.m_edgeA.other = joint.m_bodyB;\n      joint.m_edgeA.prev = null;\n      joint.m_edgeA.next = joint.m_bodyA.m_jointList;\n      if (joint.m_bodyA.m_jointList)\n        joint.m_bodyA.m_jointList.prev = joint.m_edgeA;\n      joint.m_bodyA.m_jointList = joint.m_edgeA;\n      joint.m_edgeB.joint = joint;\n      joint.m_edgeB.other = joint.m_bodyA;\n      joint.m_edgeB.prev = null;\n      joint.m_edgeB.next = joint.m_bodyB.m_jointList;\n      if (joint.m_bodyB.m_jointList)\n        joint.m_bodyB.m_jointList.prev = joint.m_edgeB;\n      joint.m_bodyB.m_jointList = joint.m_edgeB;\n      if (joint.m_collideConnected == false) {\n        for (var edge = joint.m_bodyB.getContactList(); edge; edge = edge.next) {\n          if (edge.other == joint.m_bodyA) {\n            edge.contact.flagForFiltering();\n          }\n        }\n      }\n      return joint;\n    };\n    World2.prototype.destroyJoint = function(joint) {\n      if (this.isLocked()) {\n        return;\n      }\n      if (joint.m_prev) {\n        joint.m_prev.m_next = joint.m_next;\n      }\n      if (joint.m_next) {\n        joint.m_next.m_prev = joint.m_prev;\n      }\n      if (joint == this.m_jointList) {\n        this.m_jointList = joint.m_next;\n      }\n      var bodyA = joint.m_bodyA;\n      var bodyB = joint.m_bodyB;\n      bodyA.setAwake(true);\n      bodyB.setAwake(true);\n      if (joint.m_edgeA.prev) {\n        joint.m_edgeA.prev.next = joint.m_edgeA.next;\n      }\n      if (joint.m_edgeA.next) {\n        joint.m_edgeA.next.prev = joint.m_edgeA.prev;\n      }\n      if (joint.m_edgeA == bodyA.m_jointList) {\n        bodyA.m_jointList = joint.m_edgeA.next;\n      }\n      joint.m_edgeA.prev = null;\n      joint.m_edgeA.next = null;\n      if (joint.m_edgeB.prev) {\n        joint.m_edgeB.prev.next = joint.m_edgeB.next;\n      }\n      if (joint.m_edgeB.next) {\n        joint.m_edgeB.next.prev = joint.m_edgeB.prev;\n      }\n      if (joint.m_edgeB == bodyB.m_jointList) {\n        bodyB.m_jointList = joint.m_edgeB.next;\n      }\n      joint.m_edgeB.prev = null;\n      joint.m_edgeB.next = null;\n      --this.m_jointCount;\n      if (joint.m_collideConnected == false) {\n        var edge = bodyB.getContactList();\n        while (edge) {\n          if (edge.other == bodyA) {\n            edge.contact.flagForFiltering();\n          }\n          edge = edge.next;\n        }\n      }\n      this.publish(\"remove-joint\", joint);\n    };\n    World2.prototype.step = function(timeStep, velocityIterations, positionIterations) {\n      this.publish(\"pre-step\", timeStep);\n      if ((velocityIterations | 0) !== velocityIterations) {\n        velocityIterations = 0;\n      }\n      velocityIterations = velocityIterations || this.m_velocityIterations;\n      positionIterations = positionIterations || this.m_positionIterations;\n      if (this.m_newFixture) {\n        this.findNewContacts();\n        this.m_newFixture = false;\n      }\n      this.m_locked = true;\n      this.s_step.reset(timeStep);\n      this.s_step.velocityIterations = velocityIterations;\n      this.s_step.positionIterations = positionIterations;\n      this.s_step.warmStarting = this.m_warmStarting;\n      this.s_step.blockSolve = this.m_blockSolve;\n      this.updateContacts();\n      if (this.m_stepComplete && timeStep > 0) {\n        this.m_solver.solveWorld(this.s_step);\n        for (var b2 = this.m_bodyList; b2; b2 = b2.getNext()) {\n          if (b2.m_islandFlag == false) {\n            continue;\n          }\n          if (b2.isStatic()) {\n            continue;\n          }\n          b2.synchronizeFixtures();\n        }\n        this.findNewContacts();\n      }\n      if (this.m_continuousPhysics && timeStep > 0) {\n        this.m_solver.solveWorldTOI(this.s_step);\n      }\n      if (this.m_clearForces) {\n        this.clearForces();\n      }\n      this.m_locked = false;\n      var callback;\n      while (callback = this.m_step_callback.shift()) {\n        callback(this);\n      }\n      this.publish(\"post-step\", timeStep);\n    };\n    World2.prototype.queueUpdate = function(callback) {\n      if (!this.isLocked()) {\n        callback(this);\n      } else {\n        this.m_step_callback.push(callback);\n      }\n    };\n    World2.prototype.findNewContacts = function() {\n      var _this = this;\n      this.m_broadPhase.updatePairs(function(proxyA, proxyB) {\n        return _this.createContact(proxyA, proxyB);\n      });\n    };\n    World2.prototype.createContact = function(proxyA, proxyB) {\n      var fixtureA = proxyA.fixture;\n      var fixtureB = proxyB.fixture;\n      var indexA = proxyA.childIndex;\n      var indexB = proxyB.childIndex;\n      var bodyA = fixtureA.getBody();\n      var bodyB = fixtureB.getBody();\n      if (bodyA == bodyB) {\n        return;\n      }\n      var edge = bodyB.getContactList();\n      while (edge) {\n        if (edge.other == bodyA) {\n          var fA = edge.contact.getFixtureA();\n          var fB = edge.contact.getFixtureB();\n          var iA = edge.contact.getChildIndexA();\n          var iB = edge.contact.getChildIndexB();\n          if (fA == fixtureA && fB == fixtureB && iA == indexA && iB == indexB) {\n            return;\n          }\n          if (fA == fixtureB && fB == fixtureA && iA == indexB && iB == indexA) {\n            return;\n          }\n        }\n        edge = edge.next;\n      }\n      if (bodyB.shouldCollide(bodyA) == false) {\n        return;\n      }\n      if (fixtureB.shouldCollide(fixtureA) == false) {\n        return;\n      }\n      var contact = Contact.create(fixtureA, indexA, fixtureB, indexB);\n      if (contact == null) {\n        return;\n      }\n      contact.m_prev = null;\n      if (this.m_contactList != null) {\n        contact.m_next = this.m_contactList;\n        this.m_contactList.m_prev = contact;\n      }\n      this.m_contactList = contact;\n      ++this.m_contactCount;\n    };\n    World2.prototype.updateContacts = function() {\n      var c2;\n      var next_c = this.m_contactList;\n      while (c2 = next_c) {\n        next_c = c2.getNext();\n        var fixtureA = c2.getFixtureA();\n        var fixtureB = c2.getFixtureB();\n        var indexA = c2.getChildIndexA();\n        var indexB = c2.getChildIndexB();\n        var bodyA = fixtureA.getBody();\n        var bodyB = fixtureB.getBody();\n        if (c2.m_filterFlag) {\n          if (bodyB.shouldCollide(bodyA) == false) {\n            this.destroyContact(c2);\n            continue;\n          }\n          if (fixtureB.shouldCollide(fixtureA) == false) {\n            this.destroyContact(c2);\n            continue;\n          }\n          c2.m_filterFlag = false;\n        }\n        var activeA = bodyA.isAwake() && !bodyA.isStatic();\n        var activeB = bodyB.isAwake() && !bodyB.isStatic();\n        if (activeA == false && activeB == false) {\n          continue;\n        }\n        var proxyIdA = fixtureA.m_proxies[indexA].proxyId;\n        var proxyIdB = fixtureB.m_proxies[indexB].proxyId;\n        var overlap = this.m_broadPhase.testOverlap(proxyIdA, proxyIdB);\n        if (overlap == false) {\n          this.destroyContact(c2);\n          continue;\n        }\n        c2.update(this);\n      }\n    };\n    World2.prototype.destroyContact = function(contact) {\n      if (contact.m_prev) {\n        contact.m_prev.m_next = contact.m_next;\n      }\n      if (contact.m_next) {\n        contact.m_next.m_prev = contact.m_prev;\n      }\n      if (contact == this.m_contactList) {\n        this.m_contactList = contact.m_next;\n      }\n      Contact.destroy(contact, this);\n      --this.m_contactCount;\n    };\n    World2.prototype.on = function(name, listener) {\n      if (typeof name !== \"string\" || typeof listener !== \"function\") {\n        return this;\n      }\n      if (!this._listeners) {\n        this._listeners = {};\n      }\n      if (!this._listeners[name]) {\n        this._listeners[name] = [];\n      }\n      this._listeners[name].push(listener);\n      return this;\n    };\n    World2.prototype.off = function(name, listener) {\n      if (typeof name !== \"string\" || typeof listener !== \"function\") {\n        return this;\n      }\n      var listeners = this._listeners && this._listeners[name];\n      if (!listeners || !listeners.length) {\n        return this;\n      }\n      var index = listeners.indexOf(listener);\n      if (index >= 0) {\n        listeners.splice(index, 1);\n      }\n      return this;\n    };\n    World2.prototype.publish = function(name, arg1, arg2, arg3) {\n      var listeners = this._listeners && this._listeners[name];\n      if (!listeners || !listeners.length) {\n        return 0;\n      }\n      for (var l = 0; l < listeners.length; l++) {\n        listeners[l].call(this, arg1, arg2, arg3);\n      }\n      return listeners.length;\n    };\n    World2.prototype.beginContact = function(contact) {\n      this.publish(\"begin-contact\", contact);\n    };\n    World2.prototype.endContact = function(contact) {\n      this.publish(\"end-contact\", contact);\n    };\n    World2.prototype.preSolve = function(contact, oldManifold2) {\n      this.publish(\"pre-solve\", contact, oldManifold2);\n    };\n    World2.prototype.postSolve = function(contact, impulse) {\n      this.publish(\"post-solve\", contact, impulse);\n    };\n    return World2;\n  }()\n);\nvar Vec3 = (\n  /** @class */\n  function() {\n    function Vec32(x2, y, z) {\n      if (!(this instanceof Vec32)) {\n        return new Vec32(x2, y, z);\n      }\n      if (typeof x2 === \"undefined\") {\n        this.x = 0;\n        this.y = 0;\n        this.z = 0;\n      } else if (typeof x2 === \"object\") {\n        this.x = x2.x;\n        this.y = x2.y;\n        this.z = x2.z;\n      } else {\n        this.x = x2;\n        this.y = y;\n        this.z = z;\n      }\n    }\n    Vec32.prototype._serialize = function() {\n      return {\n        x: this.x,\n        y: this.y,\n        z: this.z\n      };\n    };\n    Vec32._deserialize = function(data) {\n      var obj = Object.create(Vec32.prototype);\n      obj.x = data.x;\n      obj.y = data.y;\n      obj.z = data.z;\n      return obj;\n    };\n    Vec32.neo = function(x2, y, z) {\n      var obj = Object.create(Vec32.prototype);\n      obj.x = x2;\n      obj.y = y;\n      obj.z = z;\n      return obj;\n    };\n    Vec32.zero = function() {\n      var obj = Object.create(Vec32.prototype);\n      obj.x = 0;\n      obj.y = 0;\n      obj.z = 0;\n      return obj;\n    };\n    Vec32.clone = function(v3) {\n      return Vec32.neo(v3.x, v3.y, v3.z);\n    };\n    Vec32.prototype.toString = function() {\n      return JSON.stringify(this);\n    };\n    Vec32.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Number.isFinite(obj.x) && Number.isFinite(obj.y) && Number.isFinite(obj.z);\n    };\n    Vec32.assert = function(o) {\n    };\n    Vec32.prototype.setZero = function() {\n      this.x = 0;\n      this.y = 0;\n      this.z = 0;\n      return this;\n    };\n    Vec32.prototype.set = function(x2, y, z) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    };\n    Vec32.prototype.add = function(w) {\n      this.x += w.x;\n      this.y += w.y;\n      this.z += w.z;\n      return this;\n    };\n    Vec32.prototype.sub = function(w) {\n      this.x -= w.x;\n      this.y -= w.y;\n      this.z -= w.z;\n      return this;\n    };\n    Vec32.prototype.mul = function(m) {\n      this.x *= m;\n      this.y *= m;\n      this.z *= m;\n      return this;\n    };\n    Vec32.areEqual = function(v3, w) {\n      return v3 === w || typeof v3 === \"object\" && v3 !== null && typeof w === \"object\" && w !== null && v3.x === w.x && v3.y === w.y && v3.z === w.z;\n    };\n    Vec32.dot = function(v3, w) {\n      return v3.x * w.x + v3.y * w.y + v3.z * w.z;\n    };\n    Vec32.cross = function(v3, w) {\n      return new Vec32(v3.y * w.z - v3.z * w.y, v3.z * w.x - v3.x * w.z, v3.x * w.y - v3.y * w.x);\n    };\n    Vec32.add = function(v3, w) {\n      return new Vec32(v3.x + w.x, v3.y + w.y, v3.z + w.z);\n    };\n    Vec32.sub = function(v3, w) {\n      return new Vec32(v3.x - w.x, v3.y - w.y, v3.z - w.z);\n    };\n    Vec32.mul = function(v3, m) {\n      return new Vec32(m * v3.x, m * v3.y, m * v3.z);\n    };\n    Vec32.prototype.neg = function() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    };\n    Vec32.neg = function(v3) {\n      return new Vec32(-v3.x, -v3.y, -v3.z);\n    };\n    return Vec32;\n  }()\n);\nvar v1$2 = vec2(0, 0);\nvar v2$1 = vec2(0, 0);\nvar EdgeShape = (\n  /** @class */\n  function(_super) {\n    __extends(EdgeShape2, _super);\n    function EdgeShape2(v122, v22) {\n      var _this = this;\n      if (!(_this instanceof EdgeShape2)) {\n        return new EdgeShape2(v122, v22);\n      }\n      _this = _super.call(this) || this;\n      _this.m_type = EdgeShape2.TYPE;\n      _this.m_radius = SettingsInternal.polygonRadius;\n      _this.m_vertex1 = v122 ? Vec2.clone(v122) : Vec2.zero();\n      _this.m_vertex2 = v22 ? Vec2.clone(v22) : Vec2.zero();\n      _this.m_vertex0 = Vec2.zero();\n      _this.m_vertex3 = Vec2.zero();\n      _this.m_hasVertex0 = false;\n      _this.m_hasVertex3 = false;\n      return _this;\n    }\n    EdgeShape2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        vertex1: this.m_vertex1,\n        vertex2: this.m_vertex2,\n        vertex0: this.m_vertex0,\n        vertex3: this.m_vertex3,\n        hasVertex0: this.m_hasVertex0,\n        hasVertex3: this.m_hasVertex3\n      };\n    };\n    EdgeShape2._deserialize = function(data) {\n      var shape = new EdgeShape2(data.vertex1, data.vertex2);\n      if (shape.m_hasVertex0) {\n        shape.setPrevVertex(data.vertex0);\n      }\n      if (shape.m_hasVertex3) {\n        shape.setNextVertex(data.vertex3);\n      }\n      return shape;\n    };\n    EdgeShape2.prototype._reset = function() {\n    };\n    EdgeShape2.prototype.getRadius = function() {\n      return this.m_radius;\n    };\n    EdgeShape2.prototype.getType = function() {\n      return this.m_type;\n    };\n    EdgeShape2.prototype.setNext = function(v3) {\n      return this.setNextVertex(v3);\n    };\n    EdgeShape2.prototype.setNextVertex = function(v3) {\n      if (v3) {\n        this.m_vertex3.setVec2(v3);\n        this.m_hasVertex3 = true;\n      } else {\n        this.m_vertex3.setZero();\n        this.m_hasVertex3 = false;\n      }\n      return this;\n    };\n    EdgeShape2.prototype.getNextVertex = function() {\n      return this.m_vertex3;\n    };\n    EdgeShape2.prototype.setPrev = function(v3) {\n      return this.setPrevVertex(v3);\n    };\n    EdgeShape2.prototype.setPrevVertex = function(v3) {\n      if (v3) {\n        this.m_vertex0.setVec2(v3);\n        this.m_hasVertex0 = true;\n      } else {\n        this.m_vertex0.setZero();\n        this.m_hasVertex0 = false;\n      }\n      return this;\n    };\n    EdgeShape2.prototype.getPrevVertex = function() {\n      return this.m_vertex0;\n    };\n    EdgeShape2.prototype._set = function(v122, v22) {\n      this.m_vertex1.setVec2(v122);\n      this.m_vertex2.setVec2(v22);\n      this.m_hasVertex0 = false;\n      this.m_hasVertex3 = false;\n      return this;\n    };\n    EdgeShape2.prototype._clone = function() {\n      var clone = new EdgeShape2();\n      clone.m_type = this.m_type;\n      clone.m_radius = this.m_radius;\n      clone.m_vertex1.setVec2(this.m_vertex1);\n      clone.m_vertex2.setVec2(this.m_vertex2);\n      clone.m_vertex0.setVec2(this.m_vertex0);\n      clone.m_vertex3.setVec2(this.m_vertex3);\n      clone.m_hasVertex0 = this.m_hasVertex0;\n      clone.m_hasVertex3 = this.m_hasVertex3;\n      return clone;\n    };\n    EdgeShape2.prototype.getChildCount = function() {\n      return 1;\n    };\n    EdgeShape2.prototype.testPoint = function(xf2, p) {\n      return false;\n    };\n    EdgeShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n      var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));\n      var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));\n      var d2 = Vec2.sub(p2, p1);\n      var v122 = this.m_vertex1;\n      var v22 = this.m_vertex2;\n      var e3 = Vec2.sub(v22, v122);\n      var normal3 = Vec2.neo(e3.y, -e3.x);\n      normal3.normalize();\n      var numerator = Vec2.dot(normal3, Vec2.sub(v122, p1));\n      var denominator = Vec2.dot(normal3, d2);\n      if (denominator == 0) {\n        return false;\n      }\n      var t = numerator / denominator;\n      if (t < 0 || input2.maxFraction < t) {\n        return false;\n      }\n      var q = Vec2.add(p1, Vec2.mulNumVec2(t, d2));\n      var r = Vec2.sub(v22, v122);\n      var rr = Vec2.dot(r, r);\n      if (rr == 0) {\n        return false;\n      }\n      var s2 = Vec2.dot(Vec2.sub(q, v122), r) / rr;\n      if (s2 < 0 || 1 < s2) {\n        return false;\n      }\n      output2.fraction = t;\n      if (numerator > 0) {\n        output2.normal = Rot.mulVec2(xf2.q, normal3).neg();\n      } else {\n        output2.normal = Rot.mulVec2(xf2.q, normal3);\n      }\n      return true;\n    };\n    EdgeShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n      transformVec2(v1$2, xf2, this.m_vertex1);\n      transformVec2(v2$1, xf2, this.m_vertex2);\n      AABB.combinePoints(aabb, v1$2, v2$1);\n      AABB.extend(aabb, this.m_radius);\n    };\n    EdgeShape2.prototype.computeMass = function(massData, density) {\n      massData.mass = 0;\n      combine2Vec2(massData.center, 0.5, this.m_vertex1, 0.5, this.m_vertex2);\n      massData.I = 0;\n    };\n    EdgeShape2.prototype.computeDistanceProxy = function(proxy) {\n      proxy.m_vertices[0] = this.m_vertex1;\n      proxy.m_vertices[1] = this.m_vertex2;\n      proxy.m_vertices.length = 2;\n      proxy.m_count = 2;\n      proxy.m_radius = this.m_radius;\n    };\n    EdgeShape2.TYPE = \"edge\";\n    return EdgeShape2;\n  }(Shape)\n);\nvar Edge = EdgeShape;\nvar v1$1 = vec2(0, 0);\nvar v2 = vec2(0, 0);\nvar ChainShape = (\n  /** @class */\n  function(_super) {\n    __extends(ChainShape2, _super);\n    function ChainShape2(vertices, loop) {\n      var _this = this;\n      if (!(_this instanceof ChainShape2)) {\n        return new ChainShape2(vertices, loop);\n      }\n      _this = _super.call(this) || this;\n      _this.m_type = ChainShape2.TYPE;\n      _this.m_radius = SettingsInternal.polygonRadius;\n      _this.m_vertices = [];\n      _this.m_count = 0;\n      _this.m_prevVertex = null;\n      _this.m_nextVertex = null;\n      _this.m_hasPrevVertex = false;\n      _this.m_hasNextVertex = false;\n      _this.m_isLoop = !!loop;\n      if (vertices && vertices.length) {\n        if (loop) {\n          _this._createLoop(vertices);\n        } else {\n          _this._createChain(vertices);\n        }\n      }\n      return _this;\n    }\n    ChainShape2.prototype._serialize = function() {\n      var data = {\n        type: this.m_type,\n        vertices: this.m_isLoop ? this.m_vertices.slice(0, this.m_vertices.length - 1) : this.m_vertices,\n        isLoop: this.m_isLoop,\n        hasPrevVertex: this.m_hasPrevVertex,\n        hasNextVertex: this.m_hasNextVertex,\n        prevVertex: null,\n        nextVertex: null\n      };\n      if (this.m_prevVertex) {\n        data.prevVertex = this.m_prevVertex;\n      }\n      if (this.m_nextVertex) {\n        data.nextVertex = this.m_nextVertex;\n      }\n      return data;\n    };\n    ChainShape2._deserialize = function(data, fixture, restore) {\n      var vertices = [];\n      if (data.vertices) {\n        for (var i = 0; i < data.vertices.length; i++) {\n          vertices.push(restore(Vec2, data.vertices[i]));\n        }\n      }\n      var shape = new ChainShape2(vertices, data.isLoop);\n      if (data.prevVertex) {\n        shape.setPrevVertex(data.prevVertex);\n      }\n      if (data.nextVertex) {\n        shape.setNextVertex(data.nextVertex);\n      }\n      return shape;\n    };\n    ChainShape2.prototype.getType = function() {\n      return this.m_type;\n    };\n    ChainShape2.prototype.getRadius = function() {\n      return this.m_radius;\n    };\n    ChainShape2.prototype._createLoop = function(vertices) {\n      if (vertices.length < 3) {\n        return;\n      }\n      for (var i = 1; i < vertices.length; ++i) {\n        vertices[i - 1];\n        vertices[i];\n      }\n      this.m_vertices = [];\n      this.m_count = vertices.length + 1;\n      for (var i = 0; i < vertices.length; ++i) {\n        this.m_vertices[i] = Vec2.clone(vertices[i]);\n      }\n      this.m_vertices[vertices.length] = Vec2.clone(vertices[0]);\n      this.m_prevVertex = this.m_vertices[this.m_count - 2];\n      this.m_nextVertex = this.m_vertices[1];\n      this.m_hasPrevVertex = true;\n      this.m_hasNextVertex = true;\n      return this;\n    };\n    ChainShape2.prototype._createChain = function(vertices) {\n      for (var i = 1; i < vertices.length; ++i) {\n        vertices[i - 1];\n        vertices[i];\n      }\n      this.m_vertices = [];\n      this.m_count = vertices.length;\n      for (var i = 0; i < vertices.length; ++i) {\n        this.m_vertices[i] = Vec2.clone(vertices[i]);\n      }\n      this.m_prevVertex = null;\n      this.m_nextVertex = null;\n      this.m_hasPrevVertex = false;\n      this.m_hasNextVertex = false;\n      return this;\n    };\n    ChainShape2.prototype._reset = function() {\n      if (this.m_isLoop) {\n        this._createLoop(this.m_vertices.slice(0, this.m_vertices.length - 1));\n      } else {\n        this._createChain(this.m_vertices);\n      }\n    };\n    ChainShape2.prototype.setPrevVertex = function(prevVertex) {\n      this.m_prevVertex = prevVertex;\n      this.m_hasPrevVertex = true;\n    };\n    ChainShape2.prototype.getPrevVertex = function() {\n      return this.m_prevVertex;\n    };\n    ChainShape2.prototype.setNextVertex = function(nextVertex) {\n      this.m_nextVertex = nextVertex;\n      this.m_hasNextVertex = true;\n    };\n    ChainShape2.prototype.getNextVertex = function() {\n      return this.m_nextVertex;\n    };\n    ChainShape2.prototype._clone = function() {\n      var clone = new ChainShape2();\n      clone._createChain(this.m_vertices);\n      clone.m_type = this.m_type;\n      clone.m_radius = this.m_radius;\n      clone.m_prevVertex = this.m_prevVertex;\n      clone.m_nextVertex = this.m_nextVertex;\n      clone.m_hasPrevVertex = this.m_hasPrevVertex;\n      clone.m_hasNextVertex = this.m_hasNextVertex;\n      return clone;\n    };\n    ChainShape2.prototype.getChildCount = function() {\n      return this.m_count - 1;\n    };\n    ChainShape2.prototype.getChildEdge = function(edge, childIndex) {\n      edge.m_type = EdgeShape.TYPE;\n      edge.m_radius = this.m_radius;\n      edge.m_vertex1 = this.m_vertices[childIndex];\n      edge.m_vertex2 = this.m_vertices[childIndex + 1];\n      if (childIndex > 0) {\n        edge.m_vertex0 = this.m_vertices[childIndex - 1];\n        edge.m_hasVertex0 = true;\n      } else {\n        edge.m_vertex0 = this.m_prevVertex;\n        edge.m_hasVertex0 = this.m_hasPrevVertex;\n      }\n      if (childIndex < this.m_count - 2) {\n        edge.m_vertex3 = this.m_vertices[childIndex + 2];\n        edge.m_hasVertex3 = true;\n      } else {\n        edge.m_vertex3 = this.m_nextVertex;\n        edge.m_hasVertex3 = this.m_hasNextVertex;\n      }\n    };\n    ChainShape2.prototype.getVertex = function(index) {\n      if (index < this.m_count) {\n        return this.m_vertices[index];\n      } else {\n        return this.m_vertices[0];\n      }\n    };\n    ChainShape2.prototype.isLoop = function() {\n      return this.m_isLoop;\n    };\n    ChainShape2.prototype.testPoint = function(xf2, p) {\n      return false;\n    };\n    ChainShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n      var edgeShape = new EdgeShape(this.getVertex(childIndex), this.getVertex(childIndex + 1));\n      return edgeShape.rayCast(output2, input2, xf2, 0);\n    };\n    ChainShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n      transformVec2(v1$1, xf2, this.getVertex(childIndex));\n      transformVec2(v2, xf2, this.getVertex(childIndex + 1));\n      AABB.combinePoints(aabb, v1$1, v2);\n    };\n    ChainShape2.prototype.computeMass = function(massData, density) {\n      massData.mass = 0;\n      zeroVec2(massData.center);\n      massData.I = 0;\n    };\n    ChainShape2.prototype.computeDistanceProxy = function(proxy, childIndex) {\n      proxy.m_vertices[0] = this.getVertex(childIndex);\n      proxy.m_vertices[1] = this.getVertex(childIndex + 1);\n      proxy.m_count = 2;\n      proxy.m_radius = this.m_radius;\n    };\n    ChainShape2.TYPE = \"chain\";\n    return ChainShape2;\n  }(Shape)\n);\nvar Chain = ChainShape;\nvar math_max$1 = Math.max;\nvar math_min$3 = Math.min;\nvar temp$1 = vec2(0, 0);\nvar e$1 = vec2(0, 0);\nvar e1$1 = vec2(0, 0);\nvar e2$1 = vec2(0, 0);\nvar center = vec2(0, 0);\nvar s = vec2(0, 0);\nvar PolygonShape = (\n  /** @class */\n  function(_super) {\n    __extends(PolygonShape2, _super);\n    function PolygonShape2(vertices) {\n      var _this = this;\n      if (!(_this instanceof PolygonShape2)) {\n        return new PolygonShape2(vertices);\n      }\n      _this = _super.call(this) || this;\n      _this.m_type = PolygonShape2.TYPE;\n      _this.m_radius = SettingsInternal.polygonRadius;\n      _this.m_centroid = Vec2.zero();\n      _this.m_vertices = [];\n      _this.m_normals = [];\n      _this.m_count = 0;\n      if (vertices && vertices.length) {\n        _this._set(vertices);\n      }\n      return _this;\n    }\n    PolygonShape2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        vertices: this.m_vertices\n      };\n    };\n    PolygonShape2._deserialize = function(data, fixture, restore) {\n      var vertices = [];\n      if (data.vertices) {\n        for (var i = 0; i < data.vertices.length; i++) {\n          vertices.push(restore(Vec2, data.vertices[i]));\n        }\n      }\n      var shape = new PolygonShape2(vertices);\n      return shape;\n    };\n    PolygonShape2.prototype.getType = function() {\n      return this.m_type;\n    };\n    PolygonShape2.prototype.getRadius = function() {\n      return this.m_radius;\n    };\n    PolygonShape2.prototype._clone = function() {\n      var clone = new PolygonShape2();\n      clone.m_type = this.m_type;\n      clone.m_radius = this.m_radius;\n      clone.m_count = this.m_count;\n      clone.m_centroid.setVec2(this.m_centroid);\n      for (var i = 0; i < this.m_count; i++) {\n        clone.m_vertices.push(this.m_vertices[i].clone());\n      }\n      for (var i = 0; i < this.m_normals.length; i++) {\n        clone.m_normals.push(this.m_normals[i].clone());\n      }\n      return clone;\n    };\n    PolygonShape2.prototype.getChildCount = function() {\n      return 1;\n    };\n    PolygonShape2.prototype._reset = function() {\n      this._set(this.m_vertices);\n    };\n    PolygonShape2.prototype._set = function(vertices) {\n      if (vertices.length < 3) {\n        this._setAsBox(1, 1);\n        return;\n      }\n      var n2 = math_min$3(vertices.length, SettingsInternal.maxPolygonVertices);\n      var ps = [];\n      for (var i = 0; i < n2; ++i) {\n        var v3 = vertices[i];\n        var unique = true;\n        for (var j = 0; j < ps.length; ++j) {\n          if (Vec2.distanceSquared(v3, ps[j]) < 0.25 * SettingsInternal.linearSlopSquared) {\n            unique = false;\n            break;\n          }\n        }\n        if (unique) {\n          ps.push(Vec2.clone(v3));\n        }\n      }\n      n2 = ps.length;\n      if (n2 < 3) {\n        this._setAsBox(1, 1);\n        return;\n      }\n      var i0 = 0;\n      var x0 = ps[0].x;\n      for (var i = 1; i < n2; ++i) {\n        var x2 = ps[i].x;\n        if (x2 > x0 || x2 === x0 && ps[i].y < ps[i0].y) {\n          i0 = i;\n          x0 = x2;\n        }\n      }\n      var hull = [];\n      var m = 0;\n      var ih = i0;\n      while (true) {\n        hull[m] = ih;\n        var ie2 = 0;\n        for (var j = 1; j < n2; ++j) {\n          if (ie2 === ih) {\n            ie2 = j;\n            continue;\n          }\n          var r = Vec2.sub(ps[ie2], ps[hull[m]]);\n          var v3 = Vec2.sub(ps[j], ps[hull[m]]);\n          var c2 = Vec2.crossVec2Vec2(r, v3);\n          if (c2 < 0) {\n            ie2 = j;\n          }\n          if (c2 === 0 && v3.lengthSquared() > r.lengthSquared()) {\n            ie2 = j;\n          }\n        }\n        ++m;\n        ih = ie2;\n        if (ie2 === i0) {\n          break;\n        }\n      }\n      if (m < 3) {\n        this._setAsBox(1, 1);\n        return;\n      }\n      this.m_count = m;\n      this.m_vertices = [];\n      for (var i = 0; i < m; ++i) {\n        this.m_vertices[i] = ps[hull[i]];\n      }\n      for (var i = 0; i < m; ++i) {\n        var i1 = i;\n        var i2 = i + 1 < m ? i + 1 : 0;\n        var edge = Vec2.sub(this.m_vertices[i2], this.m_vertices[i1]);\n        this.m_normals[i] = Vec2.crossVec2Num(edge, 1);\n        this.m_normals[i].normalize();\n      }\n      this.m_centroid = computeCentroid(this.m_vertices, m);\n    };\n    PolygonShape2.prototype._setAsBox = function(hx, hy, center2, angle) {\n      this.m_vertices[0] = Vec2.neo(hx, -hy);\n      this.m_vertices[1] = Vec2.neo(hx, hy);\n      this.m_vertices[2] = Vec2.neo(-hx, hy);\n      this.m_vertices[3] = Vec2.neo(-hx, -hy);\n      this.m_normals[0] = Vec2.neo(1, 0);\n      this.m_normals[1] = Vec2.neo(0, 1);\n      this.m_normals[2] = Vec2.neo(-1, 0);\n      this.m_normals[3] = Vec2.neo(0, -1);\n      this.m_count = 4;\n      if (center2 && Vec2.isValid(center2)) {\n        angle = angle || 0;\n        copyVec2(this.m_centroid, center2);\n        var xf2 = Transform.identity();\n        xf2.p.setVec2(center2);\n        xf2.q.setAngle(angle);\n        for (var i = 0; i < this.m_count; ++i) {\n          this.m_vertices[i] = Transform.mulVec2(xf2, this.m_vertices[i]);\n          this.m_normals[i] = Rot.mulVec2(xf2.q, this.m_normals[i]);\n        }\n      }\n    };\n    PolygonShape2.prototype.testPoint = function(xf2, p) {\n      var pLocal = detransformVec2(temp$1, xf2, p);\n      for (var i = 0; i < this.m_count; ++i) {\n        var dot = dotVec2(this.m_normals[i], pLocal) - dotVec2(this.m_normals[i], this.m_vertices[i]);\n        if (dot > 0) {\n          return false;\n        }\n      }\n      return true;\n    };\n    PolygonShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n      var p1 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p1, xf2.p));\n      var p2 = Rot.mulTVec2(xf2.q, Vec2.sub(input2.p2, xf2.p));\n      var d2 = Vec2.sub(p2, p1);\n      var lower = 0;\n      var upper = input2.maxFraction;\n      var index = -1;\n      for (var i = 0; i < this.m_count; ++i) {\n        var numerator = Vec2.dot(this.m_normals[i], Vec2.sub(this.m_vertices[i], p1));\n        var denominator = Vec2.dot(this.m_normals[i], d2);\n        if (denominator == 0) {\n          if (numerator < 0) {\n            return false;\n          }\n        } else {\n          if (denominator < 0 && numerator < lower * denominator) {\n            lower = numerator / denominator;\n            index = i;\n          } else if (denominator > 0 && numerator < upper * denominator) {\n            upper = numerator / denominator;\n          }\n        }\n        if (upper < lower) {\n          return false;\n        }\n      }\n      if (index >= 0) {\n        output2.fraction = lower;\n        output2.normal = Rot.mulVec2(xf2.q, this.m_normals[index]);\n        return true;\n      }\n      return false;\n    };\n    PolygonShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n      var minX = Infinity;\n      var minY = Infinity;\n      var maxX = -Infinity;\n      var maxY = -Infinity;\n      for (var i = 0; i < this.m_count; ++i) {\n        var v3 = transformVec2(temp$1, xf2, this.m_vertices[i]);\n        minX = math_min$3(minX, v3.x);\n        maxX = math_max$1(maxX, v3.x);\n        minY = math_min$3(minY, v3.y);\n        maxY = math_max$1(maxY, v3.y);\n      }\n      setVec2(aabb.lowerBound, minX - this.m_radius, minY - this.m_radius);\n      setVec2(aabb.upperBound, maxX + this.m_radius, maxY + this.m_radius);\n    };\n    PolygonShape2.prototype.computeMass = function(massData, density) {\n      zeroVec2(center);\n      var area = 0;\n      var I = 0;\n      zeroVec2(s);\n      for (var i = 0; i < this.m_count; ++i) {\n        plusVec2(s, this.m_vertices[i]);\n      }\n      scaleVec2(s, 1 / this.m_count, s);\n      var k_inv3 = 1 / 3;\n      for (var i = 0; i < this.m_count; ++i) {\n        subVec2(e1$1, this.m_vertices[i], s);\n        if (i + 1 < this.m_count) {\n          subVec2(e2$1, this.m_vertices[i + 1], s);\n        } else {\n          subVec2(e2$1, this.m_vertices[0], s);\n        }\n        var D = crossVec2Vec2(e1$1, e2$1);\n        var triangleArea = 0.5 * D;\n        area += triangleArea;\n        combine2Vec2(temp$1, triangleArea * k_inv3, e1$1, triangleArea * k_inv3, e2$1);\n        plusVec2(center, temp$1);\n        var ex1 = e1$1.x;\n        var ey1 = e1$1.y;\n        var ex2 = e2$1.x;\n        var ey2 = e2$1.y;\n        var intx2 = ex1 * ex1 + ex2 * ex1 + ex2 * ex2;\n        var inty2 = ey1 * ey1 + ey2 * ey1 + ey2 * ey2;\n        I += 0.25 * k_inv3 * D * (intx2 + inty2);\n      }\n      massData.mass = density * area;\n      scaleVec2(center, 1 / area, center);\n      addVec2(massData.center, center, s);\n      massData.I = density * I;\n      massData.I += massData.mass * (dotVec2(massData.center, massData.center) - dotVec2(center, center));\n    };\n    PolygonShape2.prototype.validate = function() {\n      for (var i = 0; i < this.m_count; ++i) {\n        var i1 = i;\n        var i2 = i < this.m_count - 1 ? i1 + 1 : 0;\n        var p = this.m_vertices[i1];\n        subVec2(e$1, this.m_vertices[i2], p);\n        for (var j = 0; j < this.m_count; ++j) {\n          if (j == i1 || j == i2) {\n            continue;\n          }\n          var c2 = crossVec2Vec2(e$1, subVec2(temp$1, this.m_vertices[j], p));\n          if (c2 < 0) {\n            return false;\n          }\n        }\n      }\n      return true;\n    };\n    PolygonShape2.prototype.computeDistanceProxy = function(proxy) {\n      for (var i = 0; i < this.m_count; ++i) {\n        proxy.m_vertices[i] = this.m_vertices[i];\n      }\n      proxy.m_vertices.length = this.m_count;\n      proxy.m_count = this.m_count;\n      proxy.m_radius = this.m_radius;\n    };\n    PolygonShape2.TYPE = \"polygon\";\n    return PolygonShape2;\n  }(Shape)\n);\nfunction computeCentroid(vs, count) {\n  var c2 = Vec2.zero();\n  var area = 0;\n  var pRef = Vec2.zero();\n  var i;\n  var inv3 = 1 / 3;\n  for (var i = 0; i < count; ++i) {\n    var p1 = pRef;\n    var p2 = vs[i];\n    var p3 = i + 1 < count ? vs[i + 1] : vs[0];\n    var e1_1 = Vec2.sub(p2, p1);\n    var e2_1 = Vec2.sub(p3, p1);\n    var D = Vec2.crossVec2Vec2(e1_1, e2_1);\n    var triangleArea = 0.5 * D;\n    area += triangleArea;\n    combine3Vec2(temp$1, 1, p1, 1, p2, 1, p3);\n    plusScaleVec2(c2, triangleArea * inv3, temp$1);\n  }\n  c2.mul(1 / area);\n  return c2;\n}\nvar Polygon = PolygonShape;\nvar math_sqrt = Math.sqrt;\nvar math_PI$4 = Math.PI;\nvar temp = vec2(0, 0);\nvar CircleShape = (\n  /** @class */\n  function(_super) {\n    __extends(CircleShape2, _super);\n    function CircleShape2(a2, b2) {\n      var _this = this;\n      if (!(_this instanceof CircleShape2)) {\n        return new CircleShape2(a2, b2);\n      }\n      _this = _super.call(this) || this;\n      _this.m_type = CircleShape2.TYPE;\n      _this.m_p = Vec2.zero();\n      _this.m_radius = 1;\n      if (typeof a2 === \"object\" && Vec2.isValid(a2)) {\n        _this.m_p.setVec2(a2);\n        if (typeof b2 === \"number\") {\n          _this.m_radius = b2;\n        }\n      } else if (typeof a2 === \"number\") {\n        _this.m_radius = a2;\n      }\n      return _this;\n    }\n    CircleShape2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        p: this.m_p,\n        radius: this.m_radius\n      };\n    };\n    CircleShape2._deserialize = function(data) {\n      return new CircleShape2(data.p, data.radius);\n    };\n    CircleShape2.prototype._reset = function() {\n    };\n    CircleShape2.prototype.getType = function() {\n      return this.m_type;\n    };\n    CircleShape2.prototype.getRadius = function() {\n      return this.m_radius;\n    };\n    CircleShape2.prototype.getCenter = function() {\n      return this.m_p;\n    };\n    CircleShape2.prototype._clone = function() {\n      var clone = new CircleShape2();\n      clone.m_type = this.m_type;\n      clone.m_radius = this.m_radius;\n      clone.m_p = this.m_p.clone();\n      return clone;\n    };\n    CircleShape2.prototype.getChildCount = function() {\n      return 1;\n    };\n    CircleShape2.prototype.testPoint = function(xf2, p) {\n      var center2 = transformVec2(temp, xf2, this.m_p);\n      return distSqrVec2(p, center2) <= this.m_radius * this.m_radius;\n    };\n    CircleShape2.prototype.rayCast = function(output2, input2, xf2, childIndex) {\n      var position = Vec2.add(xf2.p, Rot.mulVec2(xf2.q, this.m_p));\n      var s2 = Vec2.sub(input2.p1, position);\n      var b2 = Vec2.dot(s2, s2) - this.m_radius * this.m_radius;\n      var r = Vec2.sub(input2.p2, input2.p1);\n      var c2 = Vec2.dot(s2, r);\n      var rr = Vec2.dot(r, r);\n      var sigma = c2 * c2 - rr * b2;\n      if (sigma < 0 || rr < EPSILON) {\n        return false;\n      }\n      var a2 = -(c2 + math_sqrt(sigma));\n      if (0 <= a2 && a2 <= input2.maxFraction * rr) {\n        a2 /= rr;\n        output2.fraction = a2;\n        output2.normal = Vec2.add(s2, Vec2.mulNumVec2(a2, r));\n        output2.normal.normalize();\n        return true;\n      }\n      return false;\n    };\n    CircleShape2.prototype.computeAABB = function(aabb, xf2, childIndex) {\n      var p = transformVec2(temp, xf2, this.m_p);\n      setVec2(aabb.lowerBound, p.x - this.m_radius, p.y - this.m_radius);\n      setVec2(aabb.upperBound, p.x + this.m_radius, p.y + this.m_radius);\n    };\n    CircleShape2.prototype.computeMass = function(massData, density) {\n      massData.mass = density * math_PI$4 * this.m_radius * this.m_radius;\n      copyVec2(massData.center, this.m_p);\n      massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + lengthSqrVec2(this.m_p));\n    };\n    CircleShape2.prototype.computeDistanceProxy = function(proxy) {\n      proxy.m_vertices[0] = this.m_p;\n      proxy.m_vertices.length = 1;\n      proxy.m_count = 1;\n      proxy.m_radius = this.m_radius;\n    };\n    CircleShape2.TYPE = \"circle\";\n    return CircleShape2;\n  }(Shape)\n);\nvar Circle = CircleShape;\nvar math_abs$5 = Math.abs;\nvar math_PI$3 = Math.PI;\nvar DEFAULTS$a = {\n  frequencyHz: 0,\n  dampingRatio: 0\n};\nvar DistanceJoint = (\n  /** @class */\n  function(_super) {\n    __extends(DistanceJoint2, _super);\n    function DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB) {\n      var _this = this;\n      if (!(_this instanceof DistanceJoint2)) {\n        return new DistanceJoint2(def, bodyA, bodyB, anchorA, anchorB);\n      }\n      if (bodyB && anchorA && \"m_type\" in anchorA && \"x\" in bodyB && \"y\" in bodyB) {\n        var temp3 = bodyB;\n        bodyB = anchorA;\n        anchorA = temp3;\n      }\n      def = options(def, DEFAULTS$a);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = DistanceJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.zero());\n      _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.zero());\n      _this.m_length = Number.isFinite(def.length) ? def.length : Vec2.distance(bodyA.getWorldPoint(_this.m_localAnchorA), bodyB.getWorldPoint(_this.m_localAnchorB));\n      _this.m_frequencyHz = def.frequencyHz;\n      _this.m_dampingRatio = def.dampingRatio;\n      _this.m_impulse = 0;\n      _this.m_gamma = 0;\n      _this.m_bias = 0;\n      return _this;\n    }\n    DistanceJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        frequencyHz: this.m_frequencyHz,\n        dampingRatio: this.m_dampingRatio,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        length: this.m_length,\n        impulse: this.m_impulse,\n        gamma: this.m_gamma,\n        bias: this.m_bias\n      };\n    };\n    DistanceJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new DistanceJoint2(data);\n      return joint;\n    };\n    DistanceJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (def.length > 0) {\n        this.m_length = +def.length;\n      } else if (def.length < 0) ;\n      else if (def.anchorA || def.anchorA || def.anchorA || def.anchorA) {\n        this.m_length = Vec2.distance(this.m_bodyA.getWorldPoint(this.m_localAnchorA), this.m_bodyB.getWorldPoint(this.m_localAnchorB));\n      }\n      if (Number.isFinite(def.frequencyHz)) {\n        this.m_frequencyHz = def.frequencyHz;\n      }\n      if (Number.isFinite(def.dampingRatio)) {\n        this.m_dampingRatio = def.dampingRatio;\n      }\n    };\n    DistanceJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    DistanceJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    DistanceJoint2.prototype.setLength = function(length) {\n      this.m_length = length;\n    };\n    DistanceJoint2.prototype.getLength = function() {\n      return this.m_length;\n    };\n    DistanceJoint2.prototype.setFrequency = function(hz) {\n      this.m_frequencyHz = hz;\n    };\n    DistanceJoint2.prototype.getFrequency = function() {\n      return this.m_frequencyHz;\n    };\n    DistanceJoint2.prototype.setDampingRatio = function(ratio) {\n      this.m_dampingRatio = ratio;\n    };\n    DistanceJoint2.prototype.getDampingRatio = function() {\n      return this.m_dampingRatio;\n    };\n    DistanceJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    DistanceJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    DistanceJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n    };\n    DistanceJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return 0;\n    };\n    DistanceJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      this.m_u = Vec2.sub(Vec2.add(cB2, this.m_rB), Vec2.add(cA2, this.m_rA));\n      var length = this.m_u.length();\n      if (length > SettingsInternal.linearSlop) {\n        this.m_u.mul(1 / length);\n      } else {\n        this.m_u.setNum(0, 0);\n      }\n      var crAu = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n      var crBu = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n      var invMass = this.m_invMassA + this.m_invIA * crAu * crAu + this.m_invMassB + this.m_invIB * crBu * crBu;\n      this.m_mass = invMass != 0 ? 1 / invMass : 0;\n      if (this.m_frequencyHz > 0) {\n        var C = length - this.m_length;\n        var omega = 2 * math_PI$3 * this.m_frequencyHz;\n        var d2 = 2 * this.m_mass * this.m_dampingRatio * omega;\n        var k = this.m_mass * omega * omega;\n        var h = step.dt;\n        this.m_gamma = h * (d2 + h * k);\n        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;\n        this.m_bias = C * h * k * this.m_gamma;\n        invMass += this.m_gamma;\n        this.m_mass = invMass != 0 ? 1 / invMass : 0;\n      } else {\n        this.m_gamma = 0;\n        this.m_bias = 0;\n      }\n      if (step.warmStarting) {\n        this.m_impulse *= step.dtRatio;\n        var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n        vA2.subMul(this.m_invMassA, P3);\n        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n        vB2.addMul(this.m_invMassB, P3);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n      } else {\n        this.m_impulse = 0;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    DistanceJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));\n      var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));\n      var Cdot = Vec2.dot(this.m_u, vpB) - Vec2.dot(this.m_u, vpA);\n      var impulse = -this.m_mass * (Cdot + this.m_bias + this.m_gamma * this.m_impulse);\n      this.m_impulse += impulse;\n      var P3 = Vec2.mulNumVec2(impulse, this.m_u);\n      vA2.subMul(this.m_invMassA, P3);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n      vB2.addMul(this.m_invMassB, P3);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    DistanceJoint2.prototype.solvePositionConstraints = function(step) {\n      if (this.m_frequencyHz > 0) {\n        return true;\n      }\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n      var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n      var u = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));\n      var length = u.normalize();\n      var C = clamp(length - this.m_length, -SettingsInternal.maxLinearCorrection, SettingsInternal.maxLinearCorrection);\n      var impulse = -this.m_mass * C;\n      var P3 = Vec2.mulNumVec2(impulse, u);\n      cA2.subMul(this.m_invMassA, P3);\n      aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);\n      cB2.addMul(this.m_invMassB, P3);\n      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);\n      this.m_bodyA.c_position.c.setVec2(cA2);\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c.setVec2(cB2);\n      this.m_bodyB.c_position.a = aB;\n      return math_abs$5(C) < SettingsInternal.linearSlop;\n    };\n    DistanceJoint2.TYPE = \"distance-joint\";\n    return DistanceJoint2;\n  }(Joint)\n);\nvar DEFAULTS$9 = {\n  maxForce: 0,\n  maxTorque: 0\n};\nvar FrictionJoint = (\n  /** @class */\n  function(_super) {\n    __extends(FrictionJoint2, _super);\n    function FrictionJoint2(def, bodyA, bodyB, anchor) {\n      var _this = this;\n      if (!(_this instanceof FrictionJoint2)) {\n        return new FrictionJoint2(def, bodyA, bodyB, anchor);\n      }\n      def = options(def, DEFAULTS$9);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = FrictionJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n      _this.m_linearImpulse = Vec2.zero();\n      _this.m_angularImpulse = 0;\n      _this.m_maxForce = def.maxForce;\n      _this.m_maxTorque = def.maxTorque;\n      return _this;\n    }\n    FrictionJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        maxForce: this.m_maxForce,\n        maxTorque: this.m_maxTorque,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB\n      };\n    };\n    FrictionJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new FrictionJoint2(data);\n      return joint;\n    };\n    FrictionJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (Number.isFinite(def.maxForce)) {\n        this.m_maxForce = def.maxForce;\n      }\n      if (Number.isFinite(def.maxTorque)) {\n        this.m_maxTorque = def.maxTorque;\n      }\n    };\n    FrictionJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    FrictionJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    FrictionJoint2.prototype.setMaxForce = function(force) {\n      this.m_maxForce = force;\n    };\n    FrictionJoint2.prototype.getMaxForce = function() {\n      return this.m_maxForce;\n    };\n    FrictionJoint2.prototype.setMaxTorque = function(torque) {\n      this.m_maxTorque = torque;\n    };\n    FrictionJoint2.prototype.getMaxTorque = function() {\n      return this.m_maxTorque;\n    };\n    FrictionJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    FrictionJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    FrictionJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n    };\n    FrictionJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_angularImpulse;\n    };\n    FrictionJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var K = new Mat22();\n      K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n      K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n      this.m_linearMass = K.getInverse();\n      this.m_angularMass = iA + iB;\n      if (this.m_angularMass > 0) {\n        this.m_angularMass = 1 / this.m_angularMass;\n      }\n      if (step.warmStarting) {\n        this.m_linearImpulse.mul(step.dtRatio);\n        this.m_angularImpulse *= step.dtRatio;\n        var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);\n      } else {\n        this.m_linearImpulse.setZero();\n        this.m_angularImpulse = 0;\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    FrictionJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var h = step.dt;\n      {\n        var Cdot = wB - wA;\n        var impulse = -this.m_angularMass * Cdot;\n        var oldImpulse = this.m_angularImpulse;\n        var maxImpulse = h * this.m_maxTorque;\n        this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n        impulse = this.m_angularImpulse - oldImpulse;\n        wA -= iA * impulse;\n        wB += iB * impulse;\n      }\n      {\n        var Cdot = Vec2.sub(Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB)), Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA)));\n        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n        var oldImpulse = this.m_linearImpulse;\n        this.m_linearImpulse.add(impulse);\n        var maxImpulse = h * this.m_maxForce;\n        if (this.m_linearImpulse.lengthSquared() > maxImpulse * maxImpulse) {\n          this.m_linearImpulse.normalize();\n          this.m_linearImpulse.mul(maxImpulse);\n        }\n        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n        vA2.subMul(mA, impulse);\n        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n        vB2.addMul(mB, impulse);\n        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    FrictionJoint2.prototype.solvePositionConstraints = function(step) {\n      return true;\n    };\n    FrictionJoint2.TYPE = \"friction-joint\";\n    return FrictionJoint2;\n  }(Joint)\n);\nvar Mat33 = (\n  /** @class */\n  function() {\n    function Mat332(a2, b2, c2) {\n      if (typeof a2 === \"object\" && a2 !== null) {\n        this.ex = Vec3.clone(a2);\n        this.ey = Vec3.clone(b2);\n        this.ez = Vec3.clone(c2);\n      } else {\n        this.ex = Vec3.zero();\n        this.ey = Vec3.zero();\n        this.ez = Vec3.zero();\n      }\n    }\n    Mat332.prototype.toString = function() {\n      return JSON.stringify(this);\n    };\n    Mat332.isValid = function(obj) {\n      if (obj === null || typeof obj === \"undefined\") {\n        return false;\n      }\n      return Vec3.isValid(obj.ex) && Vec3.isValid(obj.ey) && Vec3.isValid(obj.ez);\n    };\n    Mat332.assert = function(o) {\n    };\n    Mat332.prototype.setZero = function() {\n      this.ex.setZero();\n      this.ey.setZero();\n      this.ez.setZero();\n      return this;\n    };\n    Mat332.prototype.solve33 = function(v3) {\n      var cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n      var cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n      var cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n      var det = this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z;\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      var r = new Vec3();\n      cross_x = this.ey.y * this.ez.z - this.ey.z * this.ez.y;\n      cross_y = this.ey.z * this.ez.x - this.ey.x * this.ez.z;\n      cross_z = this.ey.x * this.ez.y - this.ey.y * this.ez.x;\n      r.x = det * (v3.x * cross_x + v3.y * cross_y + v3.z * cross_z);\n      cross_x = v3.y * this.ez.z - v3.z * this.ez.y;\n      cross_y = v3.z * this.ez.x - v3.x * this.ez.z;\n      cross_z = v3.x * this.ez.y - v3.y * this.ez.x;\n      r.y = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n      cross_x = this.ey.y * v3.z - this.ey.z * v3.y;\n      cross_y = this.ey.z * v3.x - this.ey.x * v3.z;\n      cross_z = this.ey.x * v3.y - this.ey.y * v3.x;\n      r.z = det * (this.ex.x * cross_x + this.ex.y * cross_y + this.ex.z * cross_z);\n      return r;\n    };\n    Mat332.prototype.solve22 = function(v3) {\n      var a11 = this.ex.x;\n      var a12 = this.ey.x;\n      var a21 = this.ex.y;\n      var a22 = this.ey.y;\n      var det = a11 * a22 - a12 * a21;\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      var r = Vec2.zero();\n      r.x = det * (a22 * v3.x - a12 * v3.y);\n      r.y = det * (a11 * v3.y - a21 * v3.x);\n      return r;\n    };\n    Mat332.prototype.getInverse22 = function(M) {\n      var a2 = this.ex.x;\n      var b2 = this.ey.x;\n      var c2 = this.ex.y;\n      var d2 = this.ey.y;\n      var det = a2 * d2 - b2 * c2;\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      M.ex.x = det * d2;\n      M.ey.x = -det * b2;\n      M.ex.z = 0;\n      M.ex.y = -det * c2;\n      M.ey.y = det * a2;\n      M.ey.z = 0;\n      M.ez.x = 0;\n      M.ez.y = 0;\n      M.ez.z = 0;\n    };\n    Mat332.prototype.getSymInverse33 = function(M) {\n      var det = Vec3.dot(this.ex, Vec3.cross(this.ey, this.ez));\n      if (det !== 0) {\n        det = 1 / det;\n      }\n      var a11 = this.ex.x;\n      var a12 = this.ey.x;\n      var a13 = this.ez.x;\n      var a22 = this.ey.y;\n      var a23 = this.ez.y;\n      var a33 = this.ez.z;\n      M.ex.x = det * (a22 * a33 - a23 * a23);\n      M.ex.y = det * (a13 * a23 - a12 * a33);\n      M.ex.z = det * (a12 * a23 - a13 * a22);\n      M.ey.x = M.ex.y;\n      M.ey.y = det * (a11 * a33 - a13 * a13);\n      M.ey.z = det * (a13 * a12 - a11 * a23);\n      M.ez.x = M.ex.z;\n      M.ez.y = M.ey.z;\n      M.ez.z = det * (a11 * a22 - a12 * a12);\n    };\n    Mat332.mul = function(a2, b2) {\n      if (b2 && \"z\" in b2 && \"y\" in b2 && \"x\" in b2) {\n        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;\n        var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;\n        var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;\n        return new Vec3(x2, y, z);\n      } else if (b2 && \"y\" in b2 && \"x\" in b2) {\n        var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;\n        var y = a2.ex.y * b2.x + a2.ey.y * b2.y;\n        return Vec2.neo(x2, y);\n      }\n    };\n    Mat332.mulVec3 = function(a2, b2) {\n      var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y + a2.ez.x * b2.z;\n      var y = a2.ex.y * b2.x + a2.ey.y * b2.y + a2.ez.y * b2.z;\n      var z = a2.ex.z * b2.x + a2.ey.z * b2.y + a2.ez.z * b2.z;\n      return new Vec3(x2, y, z);\n    };\n    Mat332.mulVec2 = function(a2, b2) {\n      var x2 = a2.ex.x * b2.x + a2.ey.x * b2.y;\n      var y = a2.ex.y * b2.x + a2.ey.y * b2.y;\n      return Vec2.neo(x2, y);\n    };\n    Mat332.add = function(a2, b2) {\n      return new Mat332(Vec3.add(a2.ex, b2.ex), Vec3.add(a2.ey, b2.ey), Vec3.add(a2.ez, b2.ez));\n    };\n    return Mat332;\n  }()\n);\nvar math_abs$4 = Math.abs;\nvar LimitState$2;\n(function(LimitState2) {\n  LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n  LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n  LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n  LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n})(LimitState$2 || (LimitState$2 = {}));\nvar DEFAULTS$8 = {\n  lowerAngle: 0,\n  upperAngle: 0,\n  maxMotorTorque: 0,\n  motorSpeed: 0,\n  enableLimit: false,\n  enableMotor: false\n};\nvar RevoluteJoint = (\n  /** @class */\n  function(_super) {\n    __extends(RevoluteJoint2, _super);\n    function RevoluteJoint2(def, bodyA, bodyB, anchor) {\n      var _this = this;\n      var _a2, _b, _c, _d, _e, _f;\n      if (!(_this instanceof RevoluteJoint2)) {\n        return new RevoluteJoint2(def, bodyA, bodyB, anchor);\n      }\n      def = def !== null && def !== void 0 ? def : {};\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_mass = new Mat33();\n      _this.m_limitState = LimitState$2.inactiveLimit;\n      _this.m_type = RevoluteJoint2.TYPE;\n      if (Vec2.isValid(anchor)) {\n        _this.m_localAnchorA = bodyA.getLocalPoint(anchor);\n      } else if (Vec2.isValid(def.localAnchorA)) {\n        _this.m_localAnchorA = Vec2.clone(def.localAnchorA);\n      } else {\n        _this.m_localAnchorA = Vec2.zero();\n      }\n      if (Vec2.isValid(anchor)) {\n        _this.m_localAnchorB = bodyB.getLocalPoint(anchor);\n      } else if (Vec2.isValid(def.localAnchorB)) {\n        _this.m_localAnchorB = Vec2.clone(def.localAnchorB);\n      } else {\n        _this.m_localAnchorB = Vec2.zero();\n      }\n      if (Number.isFinite(def.referenceAngle)) {\n        _this.m_referenceAngle = def.referenceAngle;\n      } else {\n        _this.m_referenceAngle = bodyB.getAngle() - bodyA.getAngle();\n      }\n      _this.m_impulse = new Vec3();\n      _this.m_motorImpulse = 0;\n      _this.m_lowerAngle = (_a2 = def.lowerAngle) !== null && _a2 !== void 0 ? _a2 : DEFAULTS$8.lowerAngle;\n      _this.m_upperAngle = (_b = def.upperAngle) !== null && _b !== void 0 ? _b : DEFAULTS$8.upperAngle;\n      _this.m_maxMotorTorque = (_c = def.maxMotorTorque) !== null && _c !== void 0 ? _c : DEFAULTS$8.maxMotorTorque;\n      _this.m_motorSpeed = (_d = def.motorSpeed) !== null && _d !== void 0 ? _d : DEFAULTS$8.motorSpeed;\n      _this.m_enableLimit = (_e = def.enableLimit) !== null && _e !== void 0 ? _e : DEFAULTS$8.enableLimit;\n      _this.m_enableMotor = (_f = def.enableMotor) !== null && _f !== void 0 ? _f : DEFAULTS$8.enableMotor;\n      return _this;\n    }\n    RevoluteJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        lowerAngle: this.m_lowerAngle,\n        upperAngle: this.m_upperAngle,\n        maxMotorTorque: this.m_maxMotorTorque,\n        motorSpeed: this.m_motorSpeed,\n        enableLimit: this.m_enableLimit,\n        enableMotor: this.m_enableMotor,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        referenceAngle: this.m_referenceAngle\n      };\n    };\n    RevoluteJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new RevoluteJoint2(data);\n      return joint;\n    };\n    RevoluteJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (Number.isFinite(def.referenceAngle)) {\n        this.m_referenceAngle = def.referenceAngle;\n      }\n      if (def.enableLimit !== void 0) {\n        this.m_enableLimit = def.enableLimit;\n      }\n      if (Number.isFinite(def.lowerAngle)) {\n        this.m_lowerAngle = def.lowerAngle;\n      }\n      if (Number.isFinite(def.upperAngle)) {\n        this.m_upperAngle = def.upperAngle;\n      }\n      if (Number.isFinite(def.maxMotorTorque)) {\n        this.m_maxMotorTorque = def.maxMotorTorque;\n      }\n      if (Number.isFinite(def.motorSpeed)) {\n        this.m_motorSpeed = def.motorSpeed;\n      }\n      if (def.enableMotor !== void 0) {\n        this.m_enableMotor = def.enableMotor;\n      }\n    };\n    RevoluteJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    RevoluteJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    RevoluteJoint2.prototype.getReferenceAngle = function() {\n      return this.m_referenceAngle;\n    };\n    RevoluteJoint2.prototype.getJointAngle = function() {\n      var bA = this.m_bodyA;\n      var bB = this.m_bodyB;\n      return bB.m_sweep.a - bA.m_sweep.a - this.m_referenceAngle;\n    };\n    RevoluteJoint2.prototype.getJointSpeed = function() {\n      var bA = this.m_bodyA;\n      var bB = this.m_bodyB;\n      return bB.m_angularVelocity - bA.m_angularVelocity;\n    };\n    RevoluteJoint2.prototype.isMotorEnabled = function() {\n      return this.m_enableMotor;\n    };\n    RevoluteJoint2.prototype.enableMotor = function(flag) {\n      if (flag == this.m_enableMotor)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableMotor = flag;\n    };\n    RevoluteJoint2.prototype.getMotorTorque = function(inv_dt) {\n      return inv_dt * this.m_motorImpulse;\n    };\n    RevoluteJoint2.prototype.setMotorSpeed = function(speed) {\n      if (speed == this.m_motorSpeed)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_motorSpeed = speed;\n    };\n    RevoluteJoint2.prototype.getMotorSpeed = function() {\n      return this.m_motorSpeed;\n    };\n    RevoluteJoint2.prototype.setMaxMotorTorque = function(torque) {\n      if (torque == this.m_maxMotorTorque)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_maxMotorTorque = torque;\n    };\n    RevoluteJoint2.prototype.getMaxMotorTorque = function() {\n      return this.m_maxMotorTorque;\n    };\n    RevoluteJoint2.prototype.isLimitEnabled = function() {\n      return this.m_enableLimit;\n    };\n    RevoluteJoint2.prototype.enableLimit = function(flag) {\n      if (flag != this.m_enableLimit) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_enableLimit = flag;\n        this.m_impulse.z = 0;\n      }\n    };\n    RevoluteJoint2.prototype.getLowerLimit = function() {\n      return this.m_lowerAngle;\n    };\n    RevoluteJoint2.prototype.getUpperLimit = function() {\n      return this.m_upperAngle;\n    };\n    RevoluteJoint2.prototype.setLimits = function(lower, upper) {\n      if (lower != this.m_lowerAngle || upper != this.m_upperAngle) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_impulse.z = 0;\n        this.m_lowerAngle = lower;\n        this.m_upperAngle = upper;\n      }\n    };\n    RevoluteJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    RevoluteJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    RevoluteJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n    };\n    RevoluteJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_impulse.z;\n    };\n    RevoluteJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var fixedRotation = iA + iB === 0;\n      this.m_mass.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n      this.m_mass.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n      this.m_mass.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n      this.m_mass.ex.y = this.m_mass.ey.x;\n      this.m_mass.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n      this.m_mass.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n      this.m_mass.ex.z = this.m_mass.ez.x;\n      this.m_mass.ey.z = this.m_mass.ez.y;\n      this.m_mass.ez.z = iA + iB;\n      this.m_motorMass = iA + iB;\n      if (this.m_motorMass > 0) {\n        this.m_motorMass = 1 / this.m_motorMass;\n      }\n      if (this.m_enableMotor == false || fixedRotation) {\n        this.m_motorImpulse = 0;\n      }\n      if (this.m_enableLimit && fixedRotation == false) {\n        var jointAngle = aB - aA - this.m_referenceAngle;\n        if (math_abs$4(this.m_upperAngle - this.m_lowerAngle) < 2 * SettingsInternal.angularSlop) {\n          this.m_limitState = LimitState$2.equalLimits;\n        } else if (jointAngle <= this.m_lowerAngle) {\n          if (this.m_limitState != LimitState$2.atLowerLimit) {\n            this.m_impulse.z = 0;\n          }\n          this.m_limitState = LimitState$2.atLowerLimit;\n        } else if (jointAngle >= this.m_upperAngle) {\n          if (this.m_limitState != LimitState$2.atUpperLimit) {\n            this.m_impulse.z = 0;\n          }\n          this.m_limitState = LimitState$2.atUpperLimit;\n        } else {\n          this.m_limitState = LimitState$2.inactiveLimit;\n          this.m_impulse.z = 0;\n        }\n      } else {\n        this.m_limitState = LimitState$2.inactiveLimit;\n      }\n      if (step.warmStarting) {\n        this.m_impulse.mul(step.dtRatio);\n        this.m_motorImpulse *= step.dtRatio;\n        var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_motorImpulse + this.m_impulse.z);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_motorImpulse + this.m_impulse.z);\n      } else {\n        this.m_impulse.setZero();\n        this.m_motorImpulse = 0;\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    RevoluteJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var fixedRotation = iA + iB === 0;\n      if (this.m_enableMotor && this.m_limitState != LimitState$2.equalLimits && fixedRotation == false) {\n        var Cdot = wB - wA - this.m_motorSpeed;\n        var impulse = -this.m_motorMass * Cdot;\n        var oldImpulse = this.m_motorImpulse;\n        var maxImpulse = step.dt * this.m_maxMotorTorque;\n        this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n        impulse = this.m_motorImpulse - oldImpulse;\n        wA -= iA * impulse;\n        wB += iB * impulse;\n      }\n      if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {\n        var Cdot1 = Vec2.zero();\n        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n        var Cdot2 = wB - wA;\n        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n        var impulse = Vec3.neg(this.m_mass.solve33(Cdot));\n        if (this.m_limitState == LimitState$2.equalLimits) {\n          this.m_impulse.add(impulse);\n        } else if (this.m_limitState == LimitState$2.atLowerLimit) {\n          var newImpulse = this.m_impulse.z + impulse.z;\n          if (newImpulse < 0) {\n            var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n            var reduced = this.m_mass.solve22(rhs);\n            impulse.x = reduced.x;\n            impulse.y = reduced.y;\n            impulse.z = -this.m_impulse.z;\n            this.m_impulse.x += reduced.x;\n            this.m_impulse.y += reduced.y;\n            this.m_impulse.z = 0;\n          } else {\n            this.m_impulse.add(impulse);\n          }\n        } else if (this.m_limitState == LimitState$2.atUpperLimit) {\n          var newImpulse = this.m_impulse.z + impulse.z;\n          if (newImpulse > 0) {\n            var rhs = Vec2.combine(-1, Cdot1, this.m_impulse.z, Vec2.neo(this.m_mass.ez.x, this.m_mass.ez.y));\n            var reduced = this.m_mass.solve22(rhs);\n            impulse.x = reduced.x;\n            impulse.y = reduced.y;\n            impulse.z = -this.m_impulse.z;\n            this.m_impulse.x += reduced.x;\n            this.m_impulse.y += reduced.y;\n            this.m_impulse.z = 0;\n          } else {\n            this.m_impulse.add(impulse);\n          }\n        }\n        var P3 = Vec2.neo(impulse.x, impulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);\n      } else {\n        var Cdot = Vec2.zero();\n        Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n        Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n        var impulse = this.m_mass.solve22(Vec2.neg(Cdot));\n        this.m_impulse.x += impulse.x;\n        this.m_impulse.y += impulse.y;\n        vA2.subMul(mA, impulse);\n        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n        vB2.addMul(mB, impulse);\n        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    RevoluteJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var angularError = 0;\n      var positionError = 0;\n      var fixedRotation = this.m_invIA + this.m_invIB == 0;\n      if (this.m_enableLimit && this.m_limitState != LimitState$2.inactiveLimit && fixedRotation == false) {\n        var angle = aB - aA - this.m_referenceAngle;\n        var limitImpulse = 0;\n        if (this.m_limitState == LimitState$2.equalLimits) {\n          var C = clamp(angle - this.m_lowerAngle, -SettingsInternal.maxAngularCorrection, SettingsInternal.maxAngularCorrection);\n          limitImpulse = -this.m_motorMass * C;\n          angularError = math_abs$4(C);\n        } else if (this.m_limitState == LimitState$2.atLowerLimit) {\n          var C = angle - this.m_lowerAngle;\n          angularError = -C;\n          C = clamp(C + SettingsInternal.angularSlop, -SettingsInternal.maxAngularCorrection, 0);\n          limitImpulse = -this.m_motorMass * C;\n        } else if (this.m_limitState == LimitState$2.atUpperLimit) {\n          var C = angle - this.m_upperAngle;\n          angularError = C;\n          C = clamp(C - SettingsInternal.angularSlop, 0, SettingsInternal.maxAngularCorrection);\n          limitImpulse = -this.m_motorMass * C;\n        }\n        aA -= this.m_invIA * limitImpulse;\n        aB += this.m_invIB * limitImpulse;\n      }\n      {\n        qA.setAngle(aA);\n        qB.setAngle(aB);\n        var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n        var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n        var C = Vec2.zero();\n        C.addCombine(1, cB2, 1, rB2);\n        C.subCombine(1, cA2, 1, rA2);\n        positionError = C.length();\n        var mA = this.m_invMassA;\n        var mB = this.m_invMassB;\n        var iA = this.m_invIA;\n        var iB = this.m_invIB;\n        var K = new Mat22();\n        K.ex.x = mA + mB + iA * rA2.y * rA2.y + iB * rB2.y * rB2.y;\n        K.ex.y = -iA * rA2.x * rA2.y - iB * rB2.x * rB2.y;\n        K.ey.x = K.ex.y;\n        K.ey.y = mA + mB + iA * rA2.x * rA2.x + iB * rB2.x * rB2.x;\n        var impulse = Vec2.neg(K.solve(C));\n        cA2.subMul(mA, impulse);\n        aA -= iA * Vec2.crossVec2Vec2(rA2, impulse);\n        cB2.addMul(mB, impulse);\n        aB += iB * Vec2.crossVec2Vec2(rB2, impulse);\n      }\n      this.m_bodyA.c_position.c.setVec2(cA2);\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c.setVec2(cB2);\n      this.m_bodyB.c_position.a = aB;\n      return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n    };\n    RevoluteJoint2.TYPE = \"revolute-joint\";\n    return RevoluteJoint2;\n  }(Joint)\n);\nvar math_abs$3 = Math.abs;\nvar math_max = Math.max;\nvar math_min$2 = Math.min;\nvar LimitState$1;\n(function(LimitState2) {\n  LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n  LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n  LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n  LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n})(LimitState$1 || (LimitState$1 = {}));\nvar DEFAULTS$7 = {\n  enableLimit: false,\n  lowerTranslation: 0,\n  upperTranslation: 0,\n  enableMotor: false,\n  maxMotorForce: 0,\n  motorSpeed: 0\n};\nvar PrismaticJoint = (\n  /** @class */\n  function(_super) {\n    __extends(PrismaticJoint2, _super);\n    function PrismaticJoint2(def, bodyA, bodyB, anchor, axis) {\n      var _this = this;\n      if (!(_this instanceof PrismaticJoint2)) {\n        return new PrismaticJoint2(def, bodyA, bodyB, anchor, axis);\n      }\n      def = options(def, DEFAULTS$7);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = PrismaticJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n      _this.m_localXAxisA = Vec2.clone(axis ? bodyA.getLocalVector(axis) : def.localAxisA || Vec2.neo(1, 0));\n      _this.m_localXAxisA.normalize();\n      _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);\n      _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n      _this.m_impulse = new Vec3();\n      _this.m_motorMass = 0;\n      _this.m_motorImpulse = 0;\n      _this.m_lowerTranslation = def.lowerTranslation;\n      _this.m_upperTranslation = def.upperTranslation;\n      _this.m_maxMotorForce = def.maxMotorForce;\n      _this.m_motorSpeed = def.motorSpeed;\n      _this.m_enableLimit = def.enableLimit;\n      _this.m_enableMotor = def.enableMotor;\n      _this.m_limitState = LimitState$1.inactiveLimit;\n      _this.m_axis = Vec2.zero();\n      _this.m_perp = Vec2.zero();\n      _this.m_K = new Mat33();\n      return _this;\n    }\n    PrismaticJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        lowerTranslation: this.m_lowerTranslation,\n        upperTranslation: this.m_upperTranslation,\n        maxMotorForce: this.m_maxMotorForce,\n        motorSpeed: this.m_motorSpeed,\n        enableLimit: this.m_enableLimit,\n        enableMotor: this.m_enableMotor,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        localAxisA: this.m_localXAxisA,\n        referenceAngle: this.m_referenceAngle\n      };\n    };\n    PrismaticJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      data.localAxisA = Vec2.clone(data.localAxisA);\n      var joint = new PrismaticJoint2(data);\n      return joint;\n    };\n    PrismaticJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (def.localAxisA) {\n        this.m_localXAxisA.setVec2(def.localAxisA);\n        this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));\n      }\n      if (Number.isFinite(def.referenceAngle)) {\n        this.m_referenceAngle = def.referenceAngle;\n      }\n      if (typeof def.enableLimit !== \"undefined\") {\n        this.m_enableLimit = !!def.enableLimit;\n      }\n      if (Number.isFinite(def.lowerTranslation)) {\n        this.m_lowerTranslation = def.lowerTranslation;\n      }\n      if (Number.isFinite(def.upperTranslation)) {\n        this.m_upperTranslation = def.upperTranslation;\n      }\n      if (typeof def.enableMotor !== \"undefined\") {\n        this.m_enableMotor = !!def.enableMotor;\n      }\n      if (Number.isFinite(def.maxMotorForce)) {\n        this.m_maxMotorForce = def.maxMotorForce;\n      }\n      if (Number.isFinite(def.motorSpeed)) {\n        this.m_motorSpeed = def.motorSpeed;\n      }\n    };\n    PrismaticJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    PrismaticJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    PrismaticJoint2.prototype.getLocalAxisA = function() {\n      return this.m_localXAxisA;\n    };\n    PrismaticJoint2.prototype.getReferenceAngle = function() {\n      return this.m_referenceAngle;\n    };\n    PrismaticJoint2.prototype.getJointTranslation = function() {\n      var pA2 = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      var pB2 = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      var d2 = Vec2.sub(pB2, pA2);\n      var axis = this.m_bodyA.getWorldVector(this.m_localXAxisA);\n      var translation2 = Vec2.dot(d2, axis);\n      return translation2;\n    };\n    PrismaticJoint2.prototype.getJointSpeed = function() {\n      var bA = this.m_bodyA;\n      var bB = this.m_bodyB;\n      var rA2 = Rot.mulVec2(bA.m_xf.q, Vec2.sub(this.m_localAnchorA, bA.m_sweep.localCenter));\n      var rB2 = Rot.mulVec2(bB.m_xf.q, Vec2.sub(this.m_localAnchorB, bB.m_sweep.localCenter));\n      var p1 = Vec2.add(bA.m_sweep.c, rA2);\n      var p2 = Vec2.add(bB.m_sweep.c, rB2);\n      var d2 = Vec2.sub(p2, p1);\n      var axis = Rot.mulVec2(bA.m_xf.q, this.m_localXAxisA);\n      var vA2 = bA.m_linearVelocity;\n      var vB2 = bB.m_linearVelocity;\n      var wA = bA.m_angularVelocity;\n      var wB = bB.m_angularVelocity;\n      var speed = Vec2.dot(d2, Vec2.crossNumVec2(wA, axis)) + Vec2.dot(axis, Vec2.sub(Vec2.addCrossNumVec2(vB2, wB, rB2), Vec2.addCrossNumVec2(vA2, wA, rA2)));\n      return speed;\n    };\n    PrismaticJoint2.prototype.isLimitEnabled = function() {\n      return this.m_enableLimit;\n    };\n    PrismaticJoint2.prototype.enableLimit = function(flag) {\n      if (flag != this.m_enableLimit) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_enableLimit = flag;\n        this.m_impulse.z = 0;\n      }\n    };\n    PrismaticJoint2.prototype.getLowerLimit = function() {\n      return this.m_lowerTranslation;\n    };\n    PrismaticJoint2.prototype.getUpperLimit = function() {\n      return this.m_upperTranslation;\n    };\n    PrismaticJoint2.prototype.setLimits = function(lower, upper) {\n      if (lower != this.m_lowerTranslation || upper != this.m_upperTranslation) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_lowerTranslation = lower;\n        this.m_upperTranslation = upper;\n        this.m_impulse.z = 0;\n      }\n    };\n    PrismaticJoint2.prototype.isMotorEnabled = function() {\n      return this.m_enableMotor;\n    };\n    PrismaticJoint2.prototype.enableMotor = function(flag) {\n      if (flag == this.m_enableMotor)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableMotor = flag;\n    };\n    PrismaticJoint2.prototype.setMotorSpeed = function(speed) {\n      if (speed == this.m_motorSpeed)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_motorSpeed = speed;\n    };\n    PrismaticJoint2.prototype.setMaxMotorForce = function(force) {\n      if (force == this.m_maxMotorForce)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_maxMotorForce = force;\n    };\n    PrismaticJoint2.prototype.getMaxMotorForce = function() {\n      return this.m_maxMotorForce;\n    };\n    PrismaticJoint2.prototype.getMotorSpeed = function() {\n      return this.m_motorSpeed;\n    };\n    PrismaticJoint2.prototype.getMotorForce = function(inv_dt) {\n      return inv_dt * this.m_motorImpulse;\n    };\n    PrismaticJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    PrismaticJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    PrismaticJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis).mul(inv_dt);\n    };\n    PrismaticJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_impulse.y;\n    };\n    PrismaticJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var d2 = Vec2.zero();\n      d2.addCombine(1, cB2, 1, rB2);\n      d2.subCombine(1, cA2, 1, rA2);\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      {\n        this.m_axis = Rot.mulVec2(qA, this.m_localXAxisA);\n        this.m_a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_axis);\n        this.m_a2 = Vec2.crossVec2Vec2(rB2, this.m_axis);\n        this.m_motorMass = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n        if (this.m_motorMass > 0) {\n          this.m_motorMass = 1 / this.m_motorMass;\n        }\n      }\n      {\n        this.m_perp = Rot.mulVec2(qA, this.m_localYAxisA);\n        this.m_s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_perp);\n        this.m_s2 = Vec2.crossVec2Vec2(rB2, this.m_perp);\n        Vec2.crossVec2Vec2(rA2, this.m_perp);\n        var k11 = mA + mB + iA * this.m_s1 * this.m_s1 + iB * this.m_s2 * this.m_s2;\n        var k12 = iA * this.m_s1 + iB * this.m_s2;\n        var k13 = iA * this.m_s1 * this.m_a1 + iB * this.m_s2 * this.m_a2;\n        var k22 = iA + iB;\n        if (k22 == 0) {\n          k22 = 1;\n        }\n        var k23 = iA * this.m_a1 + iB * this.m_a2;\n        var k33 = mA + mB + iA * this.m_a1 * this.m_a1 + iB * this.m_a2 * this.m_a2;\n        this.m_K.ex.set(k11, k12, k13);\n        this.m_K.ey.set(k12, k22, k23);\n        this.m_K.ez.set(k13, k23, k33);\n      }\n      if (this.m_enableLimit) {\n        var jointTranslation = Vec2.dot(this.m_axis, d2);\n        if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2 * SettingsInternal.linearSlop) {\n          this.m_limitState = LimitState$1.equalLimits;\n        } else if (jointTranslation <= this.m_lowerTranslation) {\n          if (this.m_limitState != LimitState$1.atLowerLimit) {\n            this.m_limitState = LimitState$1.atLowerLimit;\n            this.m_impulse.z = 0;\n          }\n        } else if (jointTranslation >= this.m_upperTranslation) {\n          if (this.m_limitState != LimitState$1.atUpperLimit) {\n            this.m_limitState = LimitState$1.atUpperLimit;\n            this.m_impulse.z = 0;\n          }\n        } else {\n          this.m_limitState = LimitState$1.inactiveLimit;\n          this.m_impulse.z = 0;\n        }\n      } else {\n        this.m_limitState = LimitState$1.inactiveLimit;\n        this.m_impulse.z = 0;\n      }\n      if (this.m_enableMotor == false) {\n        this.m_motorImpulse = 0;\n      }\n      if (step.warmStarting) {\n        this.m_impulse.mul(step.dtRatio);\n        this.m_motorImpulse *= step.dtRatio;\n        var P3 = Vec2.combine(this.m_impulse.x, this.m_perp, this.m_motorImpulse + this.m_impulse.z, this.m_axis);\n        var LA = this.m_impulse.x * this.m_s1 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a1;\n        var LB = this.m_impulse.x * this.m_s2 + this.m_impulse.y + (this.m_motorImpulse + this.m_impulse.z) * this.m_a2;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      } else {\n        this.m_impulse.setZero();\n        this.m_motorImpulse = 0;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    PrismaticJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      if (this.m_enableMotor && this.m_limitState != LimitState$1.equalLimits) {\n        var Cdot = Vec2.dot(this.m_axis, Vec2.sub(vB2, vA2)) + this.m_a2 * wB - this.m_a1 * wA;\n        var impulse = this.m_motorMass * (this.m_motorSpeed - Cdot);\n        var oldImpulse = this.m_motorImpulse;\n        var maxImpulse = step.dt * this.m_maxMotorForce;\n        this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n        impulse = this.m_motorImpulse - oldImpulse;\n        var P3 = Vec2.mulNumVec2(impulse, this.m_axis);\n        var LA = impulse * this.m_a1;\n        var LB = impulse * this.m_a2;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      }\n      var Cdot1 = Vec2.zero();\n      Cdot1.x += Vec2.dot(this.m_perp, vB2) + this.m_s2 * wB;\n      Cdot1.x -= Vec2.dot(this.m_perp, vA2) + this.m_s1 * wA;\n      Cdot1.y = wB - wA;\n      if (this.m_enableLimit && this.m_limitState != LimitState$1.inactiveLimit) {\n        var Cdot2 = 0;\n        Cdot2 += Vec2.dot(this.m_axis, vB2) + this.m_a2 * wB;\n        Cdot2 -= Vec2.dot(this.m_axis, vA2) + this.m_a1 * wA;\n        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n        var f1 = Vec3.clone(this.m_impulse);\n        var df = this.m_K.solve33(Vec3.neg(Cdot));\n        this.m_impulse.add(df);\n        if (this.m_limitState == LimitState$1.atLowerLimit) {\n          this.m_impulse.z = math_max(this.m_impulse.z, 0);\n        } else if (this.m_limitState == LimitState$1.atUpperLimit) {\n          this.m_impulse.z = math_min$2(this.m_impulse.z, 0);\n        }\n        var b2 = Vec2.combine(-1, Cdot1, -(this.m_impulse.z - f1.z), Vec2.neo(this.m_K.ez.x, this.m_K.ez.y));\n        var f2r = Vec2.add(this.m_K.solve22(b2), Vec2.neo(f1.x, f1.y));\n        this.m_impulse.x = f2r.x;\n        this.m_impulse.y = f2r.y;\n        df = Vec3.sub(this.m_impulse, f1);\n        var P3 = Vec2.combine(df.x, this.m_perp, df.z, this.m_axis);\n        var LA = df.x * this.m_s1 + df.y + df.z * this.m_a1;\n        var LB = df.x * this.m_s2 + df.y + df.z * this.m_a2;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      } else {\n        var df = this.m_K.solve22(Vec2.neg(Cdot1));\n        this.m_impulse.x += df.x;\n        this.m_impulse.y += df.y;\n        var P3 = Vec2.mulNumVec2(df.x, this.m_perp);\n        var LA = df.x * this.m_s1 + df.y;\n        var LB = df.x * this.m_s2 + df.y;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    PrismaticJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var d2 = Vec2.sub(Vec2.add(cB2, rB2), Vec2.add(cA2, rA2));\n      var axis = Rot.mulVec2(qA, this.m_localXAxisA);\n      var a1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), axis);\n      var a2 = Vec2.crossVec2Vec2(rB2, axis);\n      var perp2 = Rot.mulVec2(qA, this.m_localYAxisA);\n      var s1 = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), perp2);\n      var s2 = Vec2.crossVec2Vec2(rB2, perp2);\n      var impulse = new Vec3();\n      var C1 = Vec2.zero();\n      C1.x = Vec2.dot(perp2, d2);\n      C1.y = aB - aA - this.m_referenceAngle;\n      var linearError = math_abs$3(C1.x);\n      var angularError = math_abs$3(C1.y);\n      var linearSlop = SettingsInternal.linearSlop;\n      var maxLinearCorrection = SettingsInternal.maxLinearCorrection;\n      var active = false;\n      var C2 = 0;\n      if (this.m_enableLimit) {\n        var translation2 = Vec2.dot(axis, d2);\n        if (math_abs$3(this.m_upperTranslation - this.m_lowerTranslation) < 2 * linearSlop) {\n          C2 = clamp(translation2, -maxLinearCorrection, maxLinearCorrection);\n          linearError = math_max(linearError, math_abs$3(translation2));\n          active = true;\n        } else if (translation2 <= this.m_lowerTranslation) {\n          C2 = clamp(translation2 - this.m_lowerTranslation + linearSlop, -maxLinearCorrection, 0);\n          linearError = Math.max(linearError, this.m_lowerTranslation - translation2);\n          active = true;\n        } else if (translation2 >= this.m_upperTranslation) {\n          C2 = clamp(translation2 - this.m_upperTranslation - linearSlop, 0, maxLinearCorrection);\n          linearError = Math.max(linearError, translation2 - this.m_upperTranslation);\n          active = true;\n        }\n      }\n      if (active) {\n        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n        var k12 = iA * s1 + iB * s2;\n        var k13 = iA * s1 * a1 + iB * s2 * a2;\n        var k22 = iA + iB;\n        if (k22 == 0) {\n          k22 = 1;\n        }\n        var k23 = iA * a1 + iB * a2;\n        var k33 = mA + mB + iA * a1 * a1 + iB * a2 * a2;\n        var K = new Mat33();\n        K.ex.set(k11, k12, k13);\n        K.ey.set(k12, k22, k23);\n        K.ez.set(k13, k23, k33);\n        var C = new Vec3();\n        C.x = C1.x;\n        C.y = C1.y;\n        C.z = C2;\n        impulse = K.solve33(Vec3.neg(C));\n      } else {\n        var k11 = mA + mB + iA * s1 * s1 + iB * s2 * s2;\n        var k12 = iA * s1 + iB * s2;\n        var k22 = iA + iB;\n        if (k22 == 0) {\n          k22 = 1;\n        }\n        var K = new Mat22();\n        K.ex.setNum(k11, k12);\n        K.ey.setNum(k12, k22);\n        var impulse1 = K.solve(Vec2.neg(C1));\n        impulse.x = impulse1.x;\n        impulse.y = impulse1.y;\n        impulse.z = 0;\n      }\n      var P3 = Vec2.combine(impulse.x, perp2, impulse.z, axis);\n      var LA = impulse.x * s1 + impulse.y + impulse.z * a1;\n      var LB = impulse.x * s2 + impulse.y + impulse.z * a2;\n      cA2.subMul(mA, P3);\n      aA -= iA * LA;\n      cB2.addMul(mB, P3);\n      aB += iB * LB;\n      this.m_bodyA.c_position.c = cA2;\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c = cB2;\n      this.m_bodyB.c_position.a = aB;\n      return linearError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n    };\n    PrismaticJoint2.TYPE = \"prismatic-joint\";\n    return PrismaticJoint2;\n  }(Joint)\n);\nvar DEFAULTS$6 = {\n  ratio: 1\n};\nvar GearJoint = (\n  /** @class */\n  function(_super) {\n    __extends(GearJoint2, _super);\n    function GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio) {\n      var _this = this;\n      if (!(_this instanceof GearJoint2)) {\n        return new GearJoint2(def, bodyA, bodyB, joint1, joint2, ratio);\n      }\n      def = options(def, DEFAULTS$6);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = GearJoint2.TYPE;\n      _this.m_joint1 = joint1 ? joint1 : def.joint1;\n      _this.m_joint2 = joint2 ? joint2 : def.joint2;\n      _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n      _this.m_type1 = _this.m_joint1.getType();\n      _this.m_type2 = _this.m_joint2.getType();\n      var coordinateA;\n      var coordinateB;\n      _this.m_bodyC = _this.m_joint1.getBodyA();\n      _this.m_bodyA = _this.m_joint1.getBodyB();\n      var xfA2 = _this.m_bodyA.m_xf;\n      var aA = _this.m_bodyA.m_sweep.a;\n      var xfC = _this.m_bodyC.m_xf;\n      var aC = _this.m_bodyC.m_sweep.a;\n      if (_this.m_type1 === RevoluteJoint.TYPE) {\n        var revolute = _this.m_joint1;\n        _this.m_localAnchorC = revolute.m_localAnchorA;\n        _this.m_localAnchorA = revolute.m_localAnchorB;\n        _this.m_referenceAngleA = revolute.m_referenceAngle;\n        _this.m_localAxisC = Vec2.zero();\n        coordinateA = aA - aC - _this.m_referenceAngleA;\n      } else {\n        var prismatic = _this.m_joint1;\n        _this.m_localAnchorC = prismatic.m_localAnchorA;\n        _this.m_localAnchorA = prismatic.m_localAnchorB;\n        _this.m_referenceAngleA = prismatic.m_referenceAngle;\n        _this.m_localAxisC = prismatic.m_localXAxisA;\n        var pC = _this.m_localAnchorC;\n        var pA2 = Rot.mulTVec2(xfC.q, Vec2.add(Rot.mulVec2(xfA2.q, _this.m_localAnchorA), Vec2.sub(xfA2.p, xfC.p)));\n        coordinateA = Vec2.dot(pA2, _this.m_localAxisC) - Vec2.dot(pC, _this.m_localAxisC);\n      }\n      _this.m_bodyD = _this.m_joint2.getBodyA();\n      _this.m_bodyB = _this.m_joint2.getBodyB();\n      var xfB2 = _this.m_bodyB.m_xf;\n      var aB = _this.m_bodyB.m_sweep.a;\n      var xfD = _this.m_bodyD.m_xf;\n      var aD = _this.m_bodyD.m_sweep.a;\n      if (_this.m_type2 === RevoluteJoint.TYPE) {\n        var revolute = _this.m_joint2;\n        _this.m_localAnchorD = revolute.m_localAnchorA;\n        _this.m_localAnchorB = revolute.m_localAnchorB;\n        _this.m_referenceAngleB = revolute.m_referenceAngle;\n        _this.m_localAxisD = Vec2.zero();\n        coordinateB = aB - aD - _this.m_referenceAngleB;\n      } else {\n        var prismatic = _this.m_joint2;\n        _this.m_localAnchorD = prismatic.m_localAnchorA;\n        _this.m_localAnchorB = prismatic.m_localAnchorB;\n        _this.m_referenceAngleB = prismatic.m_referenceAngle;\n        _this.m_localAxisD = prismatic.m_localXAxisA;\n        var pD = _this.m_localAnchorD;\n        var pB2 = Rot.mulTVec2(xfD.q, Vec2.add(Rot.mulVec2(xfB2.q, _this.m_localAnchorB), Vec2.sub(xfB2.p, xfD.p)));\n        coordinateB = Vec2.dot(pB2, _this.m_localAxisD) - Vec2.dot(pD, _this.m_localAxisD);\n      }\n      _this.m_constant = coordinateA + _this.m_ratio * coordinateB;\n      _this.m_impulse = 0;\n      return _this;\n    }\n    GearJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        joint1: this.m_joint1,\n        joint2: this.m_joint2,\n        ratio: this.m_ratio\n        // _constant: this.m_constant,\n      };\n    };\n    GearJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      data.joint1 = restore(Joint, data.joint1, world);\n      data.joint2 = restore(Joint, data.joint2, world);\n      var joint = new GearJoint2(data);\n      return joint;\n    };\n    GearJoint2.prototype._reset = function(def) {\n      if (Number.isFinite(def.ratio)) {\n        this.m_ratio = def.ratio;\n      }\n    };\n    GearJoint2.prototype.getJoint1 = function() {\n      return this.m_joint1;\n    };\n    GearJoint2.prototype.getJoint2 = function() {\n      return this.m_joint2;\n    };\n    GearJoint2.prototype.setRatio = function(ratio) {\n      this.m_ratio = ratio;\n    };\n    GearJoint2.prototype.getRatio = function() {\n      return this.m_ratio;\n    };\n    GearJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    GearJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    GearJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(this.m_impulse, this.m_JvAC).mul(inv_dt);\n    };\n    GearJoint2.prototype.getReactionTorque = function(inv_dt) {\n      var L = this.m_impulse * this.m_JwA;\n      return inv_dt * L;\n    };\n    GearJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_lcA = this.m_bodyA.m_sweep.localCenter;\n      this.m_lcB = this.m_bodyB.m_sweep.localCenter;\n      this.m_lcC = this.m_bodyC.m_sweep.localCenter;\n      this.m_lcD = this.m_bodyD.m_sweep.localCenter;\n      this.m_mA = this.m_bodyA.m_invMass;\n      this.m_mB = this.m_bodyB.m_invMass;\n      this.m_mC = this.m_bodyC.m_invMass;\n      this.m_mD = this.m_bodyD.m_invMass;\n      this.m_iA = this.m_bodyA.m_invI;\n      this.m_iB = this.m_bodyB.m_invI;\n      this.m_iC = this.m_bodyC.m_invI;\n      this.m_iD = this.m_bodyD.m_invI;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var aC = this.m_bodyC.c_position.a;\n      var vC = this.m_bodyC.c_velocity.v;\n      var wC = this.m_bodyC.c_velocity.w;\n      var aD = this.m_bodyD.c_position.a;\n      var vD = this.m_bodyD.c_velocity.v;\n      var wD = this.m_bodyD.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var qC = Rot.neo(aC);\n      var qD = Rot.neo(aD);\n      this.m_mass = 0;\n      if (this.m_type1 == RevoluteJoint.TYPE) {\n        this.m_JvAC = Vec2.zero();\n        this.m_JwA = 1;\n        this.m_JwC = 1;\n        this.m_mass += this.m_iA + this.m_iC;\n      } else {\n        var u = Rot.mulVec2(qC, this.m_localAxisC);\n        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n        this.m_JvAC = u;\n        this.m_JwC = Vec2.crossVec2Vec2(rC, u);\n        this.m_JwA = Vec2.crossVec2Vec2(rA2, u);\n        this.m_mass += this.m_mC + this.m_mA + this.m_iC * this.m_JwC * this.m_JwC + this.m_iA * this.m_JwA * this.m_JwA;\n      }\n      if (this.m_type2 == RevoluteJoint.TYPE) {\n        this.m_JvBD = Vec2.zero();\n        this.m_JwB = this.m_ratio;\n        this.m_JwD = this.m_ratio;\n        this.m_mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n      } else {\n        var u = Rot.mulVec2(qD, this.m_localAxisD);\n        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n        this.m_JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n        this.m_JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n        this.m_JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);\n        this.m_mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * this.m_JwD * this.m_JwD + this.m_iB * this.m_JwB * this.m_JwB;\n      }\n      this.m_mass = this.m_mass > 0 ? 1 / this.m_mass : 0;\n      if (step.warmStarting) {\n        vA2.addMul(this.m_mA * this.m_impulse, this.m_JvAC);\n        wA += this.m_iA * this.m_impulse * this.m_JwA;\n        vB2.addMul(this.m_mB * this.m_impulse, this.m_JvBD);\n        wB += this.m_iB * this.m_impulse * this.m_JwB;\n        vC.subMul(this.m_mC * this.m_impulse, this.m_JvAC);\n        wC -= this.m_iC * this.m_impulse * this.m_JwC;\n        vD.subMul(this.m_mD * this.m_impulse, this.m_JvBD);\n        wD -= this.m_iD * this.m_impulse * this.m_JwD;\n      } else {\n        this.m_impulse = 0;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n      this.m_bodyC.c_velocity.v.setVec2(vC);\n      this.m_bodyC.c_velocity.w = wC;\n      this.m_bodyD.c_velocity.v.setVec2(vD);\n      this.m_bodyD.c_velocity.w = wD;\n    };\n    GearJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var vC = this.m_bodyC.c_velocity.v;\n      var wC = this.m_bodyC.c_velocity.w;\n      var vD = this.m_bodyD.c_velocity.v;\n      var wD = this.m_bodyD.c_velocity.w;\n      var Cdot = Vec2.dot(this.m_JvAC, vA2) - Vec2.dot(this.m_JvAC, vC) + Vec2.dot(this.m_JvBD, vB2) - Vec2.dot(this.m_JvBD, vD);\n      Cdot += this.m_JwA * wA - this.m_JwC * wC + (this.m_JwB * wB - this.m_JwD * wD);\n      var impulse = -this.m_mass * Cdot;\n      this.m_impulse += impulse;\n      vA2.addMul(this.m_mA * impulse, this.m_JvAC);\n      wA += this.m_iA * impulse * this.m_JwA;\n      vB2.addMul(this.m_mB * impulse, this.m_JvBD);\n      wB += this.m_iB * impulse * this.m_JwB;\n      vC.subMul(this.m_mC * impulse, this.m_JvAC);\n      wC -= this.m_iC * impulse * this.m_JwC;\n      vD.subMul(this.m_mD * impulse, this.m_JvBD);\n      wD -= this.m_iD * impulse * this.m_JwD;\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n      this.m_bodyC.c_velocity.v.setVec2(vC);\n      this.m_bodyC.c_velocity.w = wC;\n      this.m_bodyD.c_velocity.v.setVec2(vD);\n      this.m_bodyD.c_velocity.w = wD;\n    };\n    GearJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var cC = this.m_bodyC.c_position.c;\n      var aC = this.m_bodyC.c_position.a;\n      var cD = this.m_bodyD.c_position.c;\n      var aD = this.m_bodyD.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var qC = Rot.neo(aC);\n      var qD = Rot.neo(aD);\n      var linearError = 0;\n      var coordinateA;\n      var coordinateB;\n      var JvAC;\n      var JvBD;\n      var JwA;\n      var JwB;\n      var JwC;\n      var JwD;\n      var mass = 0;\n      if (this.m_type1 == RevoluteJoint.TYPE) {\n        JvAC = Vec2.zero();\n        JwA = 1;\n        JwC = 1;\n        mass += this.m_iA + this.m_iC;\n        coordinateA = aA - aC - this.m_referenceAngleA;\n      } else {\n        var u = Rot.mulVec2(qC, this.m_localAxisC);\n        var rC = Rot.mulSub(qC, this.m_localAnchorC, this.m_lcC);\n        var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_lcA);\n        JvAC = u;\n        JwC = Vec2.crossVec2Vec2(rC, u);\n        JwA = Vec2.crossVec2Vec2(rA2, u);\n        mass += this.m_mC + this.m_mA + this.m_iC * JwC * JwC + this.m_iA * JwA * JwA;\n        var pC = Vec2.sub(this.m_localAnchorC, this.m_lcC);\n        var pA2 = Rot.mulTVec2(qC, Vec2.add(rA2, Vec2.sub(cA2, cC)));\n        coordinateA = Vec2.dot(Vec2.sub(pA2, pC), this.m_localAxisC);\n      }\n      if (this.m_type2 == RevoluteJoint.TYPE) {\n        JvBD = Vec2.zero();\n        JwB = this.m_ratio;\n        JwD = this.m_ratio;\n        mass += this.m_ratio * this.m_ratio * (this.m_iB + this.m_iD);\n        coordinateB = aB - aD - this.m_referenceAngleB;\n      } else {\n        var u = Rot.mulVec2(qD, this.m_localAxisD);\n        var rD = Rot.mulSub(qD, this.m_localAnchorD, this.m_lcD);\n        var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_lcB);\n        JvBD = Vec2.mulNumVec2(this.m_ratio, u);\n        JwD = this.m_ratio * Vec2.crossVec2Vec2(rD, u);\n        JwB = this.m_ratio * Vec2.crossVec2Vec2(rB2, u);\n        mass += this.m_ratio * this.m_ratio * (this.m_mD + this.m_mB) + this.m_iD * JwD * JwD + this.m_iB * JwB * JwB;\n        var pD = Vec2.sub(this.m_localAnchorD, this.m_lcD);\n        var pB2 = Rot.mulTVec2(qD, Vec2.add(rB2, Vec2.sub(cB2, cD)));\n        coordinateB = Vec2.dot(pB2, this.m_localAxisD) - Vec2.dot(pD, this.m_localAxisD);\n      }\n      var C = coordinateA + this.m_ratio * coordinateB - this.m_constant;\n      var impulse = 0;\n      if (mass > 0) {\n        impulse = -C / mass;\n      }\n      cA2.addMul(this.m_mA * impulse, JvAC);\n      aA += this.m_iA * impulse * JwA;\n      cB2.addMul(this.m_mB * impulse, JvBD);\n      aB += this.m_iB * impulse * JwB;\n      cC.subMul(this.m_mC * impulse, JvAC);\n      aC -= this.m_iC * impulse * JwC;\n      cD.subMul(this.m_mD * impulse, JvBD);\n      aD -= this.m_iD * impulse * JwD;\n      this.m_bodyA.c_position.c.setVec2(cA2);\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c.setVec2(cB2);\n      this.m_bodyB.c_position.a = aB;\n      this.m_bodyC.c_position.c.setVec2(cC);\n      this.m_bodyC.c_position.a = aC;\n      this.m_bodyD.c_position.c.setVec2(cD);\n      this.m_bodyD.c_position.a = aD;\n      return linearError < SettingsInternal.linearSlop;\n    };\n    GearJoint2.TYPE = \"gear-joint\";\n    return GearJoint2;\n  }(Joint)\n);\nvar DEFAULTS$5 = {\n  maxForce: 1,\n  maxTorque: 1,\n  correctionFactor: 0.3\n};\nvar MotorJoint = (\n  /** @class */\n  function(_super) {\n    __extends(MotorJoint2, _super);\n    function MotorJoint2(def, bodyA, bodyB) {\n      var _this = this;\n      if (!(_this instanceof MotorJoint2)) {\n        return new MotorJoint2(def, bodyA, bodyB);\n      }\n      def = options(def, DEFAULTS$5);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = MotorJoint2.TYPE;\n      _this.m_linearOffset = Vec2.isValid(def.linearOffset) ? Vec2.clone(def.linearOffset) : bodyA.getLocalPoint(bodyB.getPosition());\n      _this.m_angularOffset = Number.isFinite(def.angularOffset) ? def.angularOffset : bodyB.getAngle() - bodyA.getAngle();\n      _this.m_linearImpulse = Vec2.zero();\n      _this.m_angularImpulse = 0;\n      _this.m_maxForce = def.maxForce;\n      _this.m_maxTorque = def.maxTorque;\n      _this.m_correctionFactor = def.correctionFactor;\n      return _this;\n    }\n    MotorJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        maxForce: this.m_maxForce,\n        maxTorque: this.m_maxTorque,\n        correctionFactor: this.m_correctionFactor,\n        linearOffset: this.m_linearOffset,\n        angularOffset: this.m_angularOffset\n      };\n    };\n    MotorJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new MotorJoint2(data);\n      return joint;\n    };\n    MotorJoint2.prototype._reset = function(def) {\n      if (Number.isFinite(def.angularOffset)) {\n        this.m_angularOffset = def.angularOffset;\n      }\n      if (Number.isFinite(def.maxForce)) {\n        this.m_maxForce = def.maxForce;\n      }\n      if (Number.isFinite(def.maxTorque)) {\n        this.m_maxTorque = def.maxTorque;\n      }\n      if (Number.isFinite(def.correctionFactor)) {\n        this.m_correctionFactor = def.correctionFactor;\n      }\n      if (Vec2.isValid(def.linearOffset)) {\n        this.m_linearOffset.set(def.linearOffset);\n      }\n    };\n    MotorJoint2.prototype.setMaxForce = function(force) {\n      this.m_maxForce = force;\n    };\n    MotorJoint2.prototype.getMaxForce = function() {\n      return this.m_maxForce;\n    };\n    MotorJoint2.prototype.setMaxTorque = function(torque) {\n      this.m_maxTorque = torque;\n    };\n    MotorJoint2.prototype.getMaxTorque = function() {\n      return this.m_maxTorque;\n    };\n    MotorJoint2.prototype.setCorrectionFactor = function(factor) {\n      this.m_correctionFactor = factor;\n    };\n    MotorJoint2.prototype.getCorrectionFactor = function() {\n      return this.m_correctionFactor;\n    };\n    MotorJoint2.prototype.setLinearOffset = function(linearOffset) {\n      if (linearOffset.x != this.m_linearOffset.x || linearOffset.y != this.m_linearOffset.y) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_linearOffset.set(linearOffset);\n      }\n    };\n    MotorJoint2.prototype.getLinearOffset = function() {\n      return this.m_linearOffset;\n    };\n    MotorJoint2.prototype.setAngularOffset = function(angularOffset) {\n      if (angularOffset != this.m_angularOffset) {\n        this.m_bodyA.setAwake(true);\n        this.m_bodyB.setAwake(true);\n        this.m_angularOffset = angularOffset;\n      }\n    };\n    MotorJoint2.prototype.getAngularOffset = function() {\n      return this.m_angularOffset;\n    };\n    MotorJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getPosition();\n    };\n    MotorJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getPosition();\n    };\n    MotorJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(inv_dt, this.m_linearImpulse);\n    };\n    MotorJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_angularImpulse;\n    };\n    MotorJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_linearOffset, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.neg(this.m_localCenterB));\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var K = new Mat22();\n      K.ex.x = mA + mB + iA * this.m_rA.y * this.m_rA.y + iB * this.m_rB.y * this.m_rB.y;\n      K.ex.y = -iA * this.m_rA.x * this.m_rA.y - iB * this.m_rB.x * this.m_rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = mA + mB + iA * this.m_rA.x * this.m_rA.x + iB * this.m_rB.x * this.m_rB.x;\n      this.m_linearMass = K.getInverse();\n      this.m_angularMass = iA + iB;\n      if (this.m_angularMass > 0) {\n        this.m_angularMass = 1 / this.m_angularMass;\n      }\n      this.m_linearError = Vec2.zero();\n      this.m_linearError.addCombine(1, cB2, 1, this.m_rB);\n      this.m_linearError.subCombine(1, cA2, 1, this.m_rA);\n      this.m_angularError = aB - aA - this.m_angularOffset;\n      if (step.warmStarting) {\n        this.m_linearImpulse.mul(step.dtRatio);\n        this.m_angularImpulse *= step.dtRatio;\n        var P3 = Vec2.neo(this.m_linearImpulse.x, this.m_linearImpulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_angularImpulse);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_angularImpulse);\n      } else {\n        this.m_linearImpulse.setZero();\n        this.m_angularImpulse = 0;\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    MotorJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var h = step.dt;\n      var inv_h = step.inv_dt;\n      {\n        var Cdot = wB - wA + inv_h * this.m_correctionFactor * this.m_angularError;\n        var impulse = -this.m_angularMass * Cdot;\n        var oldImpulse = this.m_angularImpulse;\n        var maxImpulse = h * this.m_maxTorque;\n        this.m_angularImpulse = clamp(this.m_angularImpulse + impulse, -maxImpulse, maxImpulse);\n        impulse = this.m_angularImpulse - oldImpulse;\n        wA -= iA * impulse;\n        wB += iB * impulse;\n      }\n      {\n        var Cdot = Vec2.zero();\n        Cdot.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n        Cdot.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n        Cdot.addMul(inv_h * this.m_correctionFactor, this.m_linearError);\n        var impulse = Vec2.neg(Mat22.mulVec2(this.m_linearMass, Cdot));\n        var oldImpulse = Vec2.clone(this.m_linearImpulse);\n        this.m_linearImpulse.add(impulse);\n        var maxImpulse = h * this.m_maxForce;\n        this.m_linearImpulse.clamp(maxImpulse);\n        impulse = Vec2.sub(this.m_linearImpulse, oldImpulse);\n        vA2.subMul(mA, impulse);\n        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, impulse);\n        vB2.addMul(mB, impulse);\n        wB += iB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    MotorJoint2.prototype.solvePositionConstraints = function(step) {\n      return true;\n    };\n    MotorJoint2.TYPE = \"motor-joint\";\n    return MotorJoint2;\n  }(Joint)\n);\nvar math_PI$2 = Math.PI;\nvar DEFAULTS$4 = {\n  maxForce: 0,\n  frequencyHz: 5,\n  dampingRatio: 0.7\n};\nvar MouseJoint = (\n  /** @class */\n  function(_super) {\n    __extends(MouseJoint2, _super);\n    function MouseJoint2(def, bodyA, bodyB, target) {\n      var _this = this;\n      if (!(_this instanceof MouseJoint2)) {\n        return new MouseJoint2(def, bodyA, bodyB, target);\n      }\n      def = options(def, DEFAULTS$4);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = MouseJoint2.TYPE;\n      if (Vec2.isValid(target)) {\n        _this.m_targetA = Vec2.clone(target);\n      } else if (Vec2.isValid(def.target)) {\n        _this.m_targetA = Vec2.clone(def.target);\n      } else {\n        _this.m_targetA = Vec2.zero();\n      }\n      _this.m_localAnchorB = Transform.mulTVec2(bodyB.getTransform(), _this.m_targetA);\n      _this.m_maxForce = def.maxForce;\n      _this.m_impulse = Vec2.zero();\n      _this.m_frequencyHz = def.frequencyHz;\n      _this.m_dampingRatio = def.dampingRatio;\n      _this.m_beta = 0;\n      _this.m_gamma = 0;\n      _this.m_rB = Vec2.zero();\n      _this.m_localCenterB = Vec2.zero();\n      _this.m_invMassB = 0;\n      _this.m_invIB = 0;\n      _this.m_mass = new Mat22();\n      _this.m_C = Vec2.zero();\n      return _this;\n    }\n    MouseJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        target: this.m_targetA,\n        maxForce: this.m_maxForce,\n        frequencyHz: this.m_frequencyHz,\n        dampingRatio: this.m_dampingRatio,\n        _localAnchorB: this.m_localAnchorB\n      };\n    };\n    MouseJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      data.target = Vec2.clone(data.target);\n      var joint = new MouseJoint2(data);\n      if (data._localAnchorB) {\n        joint.m_localAnchorB = data._localAnchorB;\n      }\n      return joint;\n    };\n    MouseJoint2.prototype._reset = function(def) {\n      if (Number.isFinite(def.maxForce)) {\n        this.m_maxForce = def.maxForce;\n      }\n      if (Number.isFinite(def.frequencyHz)) {\n        this.m_frequencyHz = def.frequencyHz;\n      }\n      if (Number.isFinite(def.dampingRatio)) {\n        this.m_dampingRatio = def.dampingRatio;\n      }\n    };\n    MouseJoint2.prototype.setTarget = function(target) {\n      if (Vec2.areEqual(target, this.m_targetA))\n        return;\n      this.m_bodyB.setAwake(true);\n      this.m_targetA.set(target);\n    };\n    MouseJoint2.prototype.getTarget = function() {\n      return this.m_targetA;\n    };\n    MouseJoint2.prototype.setMaxForce = function(force) {\n      this.m_maxForce = force;\n    };\n    MouseJoint2.prototype.getMaxForce = function() {\n      return this.m_maxForce;\n    };\n    MouseJoint2.prototype.setFrequency = function(hz) {\n      this.m_frequencyHz = hz;\n    };\n    MouseJoint2.prototype.getFrequency = function() {\n      return this.m_frequencyHz;\n    };\n    MouseJoint2.prototype.setDampingRatio = function(ratio) {\n      this.m_dampingRatio = ratio;\n    };\n    MouseJoint2.prototype.getDampingRatio = function() {\n      return this.m_dampingRatio;\n    };\n    MouseJoint2.prototype.getAnchorA = function() {\n      return Vec2.clone(this.m_targetA);\n    };\n    MouseJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    MouseJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(inv_dt, this.m_impulse);\n    };\n    MouseJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * 0;\n    };\n    MouseJoint2.prototype.shiftOrigin = function(newOrigin) {\n      this.m_targetA.sub(newOrigin);\n    };\n    MouseJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var position = this.m_bodyB.c_position;\n      var velocity = this.m_bodyB.c_velocity;\n      var cB2 = position.c;\n      var aB = position.a;\n      var vB2 = velocity.v;\n      var wB = velocity.w;\n      var qB = Rot.neo(aB);\n      var mass = this.m_bodyB.getMass();\n      var omega = 2 * math_PI$2 * this.m_frequencyHz;\n      var d2 = 2 * mass * this.m_dampingRatio * omega;\n      var k = mass * (omega * omega);\n      var h = step.dt;\n      this.m_gamma = h * (d2 + h * k);\n      if (this.m_gamma != 0) {\n        this.m_gamma = 1 / this.m_gamma;\n      }\n      this.m_beta = h * k * this.m_gamma;\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var K = new Mat22();\n      K.ex.x = this.m_invMassB + this.m_invIB * this.m_rB.y * this.m_rB.y + this.m_gamma;\n      K.ex.y = -this.m_invIB * this.m_rB.x * this.m_rB.y;\n      K.ey.x = K.ex.y;\n      K.ey.y = this.m_invMassB + this.m_invIB * this.m_rB.x * this.m_rB.x + this.m_gamma;\n      this.m_mass = K.getInverse();\n      this.m_C.setVec2(cB2);\n      this.m_C.addCombine(1, this.m_rB, -1, this.m_targetA);\n      this.m_C.mul(this.m_beta);\n      wB *= 0.98;\n      if (step.warmStarting) {\n        this.m_impulse.mul(step.dtRatio);\n        vB2.addMul(this.m_invMassB, this.m_impulse);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, this.m_impulse);\n      } else {\n        this.m_impulse.setZero();\n      }\n      velocity.v.setVec2(vB2);\n      velocity.w = wB;\n    };\n    MouseJoint2.prototype.solveVelocityConstraints = function(step) {\n      var velocity = this.m_bodyB.c_velocity;\n      var vB2 = Vec2.clone(velocity.v);\n      var wB = velocity.w;\n      var Cdot = Vec2.crossNumVec2(wB, this.m_rB);\n      Cdot.add(vB2);\n      Cdot.addCombine(1, this.m_C, this.m_gamma, this.m_impulse);\n      Cdot.neg();\n      var impulse = Mat22.mulVec2(this.m_mass, Cdot);\n      var oldImpulse = Vec2.clone(this.m_impulse);\n      this.m_impulse.add(impulse);\n      var maxImpulse = step.dt * this.m_maxForce;\n      this.m_impulse.clamp(maxImpulse);\n      impulse = Vec2.sub(this.m_impulse, oldImpulse);\n      vB2.addMul(this.m_invMassB, impulse);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, impulse);\n      velocity.v.setVec2(vB2);\n      velocity.w = wB;\n    };\n    MouseJoint2.prototype.solvePositionConstraints = function(step) {\n      return true;\n    };\n    MouseJoint2.TYPE = \"mouse-joint\";\n    return MouseJoint2;\n  }(Joint)\n);\nvar math_abs$2 = Math.abs;\nvar DEFAULTS$3 = {\n  collideConnected: true\n};\nvar PulleyJoint = (\n  /** @class */\n  function(_super) {\n    __extends(PulleyJoint2, _super);\n    function PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio) {\n      var _this = this;\n      if (!(_this instanceof PulleyJoint2)) {\n        return new PulleyJoint2(def, bodyA, bodyB, groundA, groundB, anchorA, anchorB, ratio);\n      }\n      def = options(def, DEFAULTS$3);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = PulleyJoint2.TYPE;\n      _this.m_groundAnchorA = Vec2.clone(groundA ? groundA : def.groundAnchorA || Vec2.neo(-1, 1));\n      _this.m_groundAnchorB = Vec2.clone(groundB ? groundB : def.groundAnchorB || Vec2.neo(1, 1));\n      _this.m_localAnchorA = Vec2.clone(anchorA ? bodyA.getLocalPoint(anchorA) : def.localAnchorA || Vec2.neo(-1, 0));\n      _this.m_localAnchorB = Vec2.clone(anchorB ? bodyB.getLocalPoint(anchorB) : def.localAnchorB || Vec2.neo(1, 0));\n      _this.m_lengthA = Number.isFinite(def.lengthA) ? def.lengthA : Vec2.distance(anchorA, groundA);\n      _this.m_lengthB = Number.isFinite(def.lengthB) ? def.lengthB : Vec2.distance(anchorB, groundB);\n      _this.m_ratio = Number.isFinite(ratio) ? ratio : def.ratio;\n      _this.m_constant = _this.m_lengthA + _this.m_ratio * _this.m_lengthB;\n      _this.m_impulse = 0;\n      return _this;\n    }\n    PulleyJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        groundAnchorA: this.m_groundAnchorA,\n        groundAnchorB: this.m_groundAnchorB,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        lengthA: this.m_lengthA,\n        lengthB: this.m_lengthB,\n        ratio: this.m_ratio\n      };\n    };\n    PulleyJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new PulleyJoint2(data);\n      return joint;\n    };\n    PulleyJoint2.prototype._reset = function(def) {\n      if (Vec2.isValid(def.groundAnchorA)) {\n        this.m_groundAnchorA.set(def.groundAnchorA);\n      }\n      if (Vec2.isValid(def.groundAnchorB)) {\n        this.m_groundAnchorB.set(def.groundAnchorB);\n      }\n      if (Vec2.isValid(def.localAnchorA)) {\n        this.m_localAnchorA.set(def.localAnchorA);\n      } else if (Vec2.isValid(def.anchorA)) {\n        this.m_localAnchorA.set(this.m_bodyA.getLocalPoint(def.anchorA));\n      }\n      if (Vec2.isValid(def.localAnchorB)) {\n        this.m_localAnchorB.set(def.localAnchorB);\n      } else if (Vec2.isValid(def.anchorB)) {\n        this.m_localAnchorB.set(this.m_bodyB.getLocalPoint(def.anchorB));\n      }\n      if (Number.isFinite(def.lengthA)) {\n        this.m_lengthA = def.lengthA;\n      }\n      if (Number.isFinite(def.lengthB)) {\n        this.m_lengthB = def.lengthB;\n      }\n      if (Number.isFinite(def.ratio)) {\n        this.m_ratio = def.ratio;\n      }\n    };\n    PulleyJoint2.prototype.getGroundAnchorA = function() {\n      return this.m_groundAnchorA;\n    };\n    PulleyJoint2.prototype.getGroundAnchorB = function() {\n      return this.m_groundAnchorB;\n    };\n    PulleyJoint2.prototype.getLengthA = function() {\n      return this.m_lengthA;\n    };\n    PulleyJoint2.prototype.getLengthB = function() {\n      return this.m_lengthB;\n    };\n    PulleyJoint2.prototype.getRatio = function() {\n      return this.m_ratio;\n    };\n    PulleyJoint2.prototype.getCurrentLengthA = function() {\n      var p = this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n      var s2 = this.m_groundAnchorA;\n      return Vec2.distance(p, s2);\n    };\n    PulleyJoint2.prototype.getCurrentLengthB = function() {\n      var p = this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n      var s2 = this.m_groundAnchorB;\n      return Vec2.distance(p, s2);\n    };\n    PulleyJoint2.prototype.shiftOrigin = function(newOrigin) {\n      this.m_groundAnchorA.sub(newOrigin);\n      this.m_groundAnchorB.sub(newOrigin);\n    };\n    PulleyJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    PulleyJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    PulleyJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(this.m_impulse, this.m_uB).mul(inv_dt);\n    };\n    PulleyJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return 0;\n    };\n    PulleyJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      this.m_uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);\n      this.m_uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);\n      var lengthA = this.m_uA.length();\n      var lengthB = this.m_uB.length();\n      if (lengthA > 10 * SettingsInternal.linearSlop) {\n        this.m_uA.mul(1 / lengthA);\n      } else {\n        this.m_uA.setZero();\n      }\n      if (lengthB > 10 * SettingsInternal.linearSlop) {\n        this.m_uB.mul(1 / lengthB);\n      } else {\n        this.m_uB.setZero();\n      }\n      var ruA = Vec2.crossVec2Vec2(this.m_rA, this.m_uA);\n      var ruB = Vec2.crossVec2Vec2(this.m_rB, this.m_uB);\n      var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n      var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n      this.m_mass = mA + this.m_ratio * this.m_ratio * mB;\n      if (this.m_mass > 0) {\n        this.m_mass = 1 / this.m_mass;\n      }\n      if (step.warmStarting) {\n        this.m_impulse *= step.dtRatio;\n        var PA = Vec2.mulNumVec2(-this.m_impulse, this.m_uA);\n        var PB = Vec2.mulNumVec2(-this.m_ratio * this.m_impulse, this.m_uB);\n        vA2.addMul(this.m_invMassA, PA);\n        wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n        vB2.addMul(this.m_invMassB, PB);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n      } else {\n        this.m_impulse = 0;\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    PulleyJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var vpA = Vec2.add(vA2, Vec2.crossNumVec2(wA, this.m_rA));\n      var vpB = Vec2.add(vB2, Vec2.crossNumVec2(wB, this.m_rB));\n      var Cdot = -Vec2.dot(this.m_uA, vpA) - this.m_ratio * Vec2.dot(this.m_uB, vpB);\n      var impulse = -this.m_mass * Cdot;\n      this.m_impulse += impulse;\n      var PA = Vec2.mulNumVec2(-impulse, this.m_uA);\n      var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, this.m_uB);\n      vA2.addMul(this.m_invMassA, PA);\n      wA += this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, PA);\n      vB2.addMul(this.m_invMassB, PB);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, PB);\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    PulleyJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var uA = Vec2.sub(Vec2.add(cA2, this.m_rA), this.m_groundAnchorA);\n      var uB = Vec2.sub(Vec2.add(cB2, this.m_rB), this.m_groundAnchorB);\n      var lengthA = uA.length();\n      var lengthB = uB.length();\n      if (lengthA > 10 * SettingsInternal.linearSlop) {\n        uA.mul(1 / lengthA);\n      } else {\n        uA.setZero();\n      }\n      if (lengthB > 10 * SettingsInternal.linearSlop) {\n        uB.mul(1 / lengthB);\n      } else {\n        uB.setZero();\n      }\n      var ruA = Vec2.crossVec2Vec2(rA2, uA);\n      var ruB = Vec2.crossVec2Vec2(rB2, uB);\n      var mA = this.m_invMassA + this.m_invIA * ruA * ruA;\n      var mB = this.m_invMassB + this.m_invIB * ruB * ruB;\n      var mass = mA + this.m_ratio * this.m_ratio * mB;\n      if (mass > 0) {\n        mass = 1 / mass;\n      }\n      var C = this.m_constant - lengthA - this.m_ratio * lengthB;\n      var linearError = math_abs$2(C);\n      var impulse = -mass * C;\n      var PA = Vec2.mulNumVec2(-impulse, uA);\n      var PB = Vec2.mulNumVec2(-this.m_ratio * impulse, uB);\n      cA2.addMul(this.m_invMassA, PA);\n      aA += this.m_invIA * Vec2.crossVec2Vec2(rA2, PA);\n      cB2.addMul(this.m_invMassB, PB);\n      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, PB);\n      this.m_bodyA.c_position.c = cA2;\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c = cB2;\n      this.m_bodyB.c_position.a = aB;\n      return linearError < SettingsInternal.linearSlop;\n    };\n    PulleyJoint2.TYPE = \"pulley-joint\";\n    return PulleyJoint2;\n  }(Joint)\n);\nvar math_min$1 = Math.min;\nvar LimitState;\n(function(LimitState2) {\n  LimitState2[LimitState2[\"inactiveLimit\"] = 0] = \"inactiveLimit\";\n  LimitState2[LimitState2[\"atLowerLimit\"] = 1] = \"atLowerLimit\";\n  LimitState2[LimitState2[\"atUpperLimit\"] = 2] = \"atUpperLimit\";\n  LimitState2[LimitState2[\"equalLimits\"] = 3] = \"equalLimits\";\n})(LimitState || (LimitState = {}));\nvar DEFAULTS$2 = {\n  maxLength: 0\n};\nvar RopeJoint = (\n  /** @class */\n  function(_super) {\n    __extends(RopeJoint2, _super);\n    function RopeJoint2(def, bodyA, bodyB, anchor) {\n      var _this = this;\n      if (!(_this instanceof RopeJoint2)) {\n        return new RopeJoint2(def, bodyA, bodyB, anchor);\n      }\n      def = options(def, DEFAULTS$2);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = RopeJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.neo(-1, 0));\n      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.neo(1, 0));\n      _this.m_maxLength = def.maxLength;\n      _this.m_mass = 0;\n      _this.m_impulse = 0;\n      _this.m_length = 0;\n      _this.m_state = LimitState.inactiveLimit;\n      return _this;\n    }\n    RopeJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        maxLength: this.m_maxLength\n      };\n    };\n    RopeJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new RopeJoint2(data);\n      return joint;\n    };\n    RopeJoint2.prototype._reset = function(def) {\n      if (Number.isFinite(def.maxLength)) {\n        this.m_maxLength = def.maxLength;\n      }\n    };\n    RopeJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    RopeJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    RopeJoint2.prototype.setMaxLength = function(length) {\n      this.m_maxLength = length;\n    };\n    RopeJoint2.prototype.getMaxLength = function() {\n      return this.m_maxLength;\n    };\n    RopeJoint2.prototype.getLimitState = function() {\n      return this.m_state;\n    };\n    RopeJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    RopeJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    RopeJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.mulNumVec2(this.m_impulse, this.m_u).mul(inv_dt);\n    };\n    RopeJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return 0;\n    };\n    RopeJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n      this.m_rB = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n      this.m_u = Vec2.zero();\n      this.m_u.addCombine(1, cB2, 1, this.m_rB);\n      this.m_u.subCombine(1, cA2, 1, this.m_rA);\n      this.m_length = this.m_u.length();\n      var C = this.m_length - this.m_maxLength;\n      if (C > 0) {\n        this.m_state = LimitState.atUpperLimit;\n      } else {\n        this.m_state = LimitState.inactiveLimit;\n      }\n      if (this.m_length > SettingsInternal.linearSlop) {\n        this.m_u.mul(1 / this.m_length);\n      } else {\n        this.m_u.setZero();\n        this.m_mass = 0;\n        this.m_impulse = 0;\n        return;\n      }\n      var crA = Vec2.crossVec2Vec2(this.m_rA, this.m_u);\n      var crB = Vec2.crossVec2Vec2(this.m_rB, this.m_u);\n      var invMass = this.m_invMassA + this.m_invIA * crA * crA + this.m_invMassB + this.m_invIB * crB * crB;\n      this.m_mass = invMass != 0 ? 1 / invMass : 0;\n      if (step.warmStarting) {\n        this.m_impulse *= step.dtRatio;\n        var P3 = Vec2.mulNumVec2(this.m_impulse, this.m_u);\n        vA2.subMul(this.m_invMassA, P3);\n        wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n        vB2.addMul(this.m_invMassB, P3);\n        wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n      } else {\n        this.m_impulse = 0;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    RopeJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var vpA = Vec2.addCrossNumVec2(vA2, wA, this.m_rA);\n      var vpB = Vec2.addCrossNumVec2(vB2, wB, this.m_rB);\n      var C = this.m_length - this.m_maxLength;\n      var Cdot = Vec2.dot(this.m_u, Vec2.sub(vpB, vpA));\n      if (C < 0) {\n        Cdot += step.inv_dt * C;\n      }\n      var impulse = -this.m_mass * Cdot;\n      var oldImpulse = this.m_impulse;\n      this.m_impulse = math_min$1(0, this.m_impulse + impulse);\n      impulse = this.m_impulse - oldImpulse;\n      var P3 = Vec2.mulNumVec2(impulse, this.m_u);\n      vA2.subMul(this.m_invMassA, P3);\n      wA -= this.m_invIA * Vec2.crossVec2Vec2(this.m_rA, P3);\n      vB2.addMul(this.m_invMassB, P3);\n      wB += this.m_invIB * Vec2.crossVec2Vec2(this.m_rB, P3);\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    RopeJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulSub(qA, this.m_localAnchorA, this.m_localCenterA);\n      var rB2 = Rot.mulSub(qB, this.m_localAnchorB, this.m_localCenterB);\n      var u = Vec2.zero();\n      u.addCombine(1, cB2, 1, rB2);\n      u.subCombine(1, cA2, 1, rA2);\n      var length = u.normalize();\n      var C = length - this.m_maxLength;\n      C = clamp(C, 0, SettingsInternal.maxLinearCorrection);\n      var impulse = -this.m_mass * C;\n      var P3 = Vec2.mulNumVec2(impulse, u);\n      cA2.subMul(this.m_invMassA, P3);\n      aA -= this.m_invIA * Vec2.crossVec2Vec2(rA2, P3);\n      cB2.addMul(this.m_invMassB, P3);\n      aB += this.m_invIB * Vec2.crossVec2Vec2(rB2, P3);\n      this.m_bodyA.c_position.c.setVec2(cA2);\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c.setVec2(cB2);\n      this.m_bodyB.c_position.a = aB;\n      return length - this.m_maxLength < SettingsInternal.linearSlop;\n    };\n    RopeJoint2.TYPE = \"rope-joint\";\n    return RopeJoint2;\n  }(Joint)\n);\nvar math_abs$1 = Math.abs;\nvar math_PI$1 = Math.PI;\nvar DEFAULTS$1 = {\n  frequencyHz: 0,\n  dampingRatio: 0\n};\nvar WeldJoint = (\n  /** @class */\n  function(_super) {\n    __extends(WeldJoint2, _super);\n    function WeldJoint2(def, bodyA, bodyB, anchor) {\n      var _this = this;\n      if (!(_this instanceof WeldJoint2)) {\n        return new WeldJoint2(def, bodyA, bodyB, anchor);\n      }\n      def = options(def, DEFAULTS$1);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_type = WeldJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n      _this.m_referenceAngle = Number.isFinite(def.referenceAngle) ? def.referenceAngle : bodyB.getAngle() - bodyA.getAngle();\n      _this.m_frequencyHz = def.frequencyHz;\n      _this.m_dampingRatio = def.dampingRatio;\n      _this.m_impulse = new Vec3();\n      _this.m_bias = 0;\n      _this.m_gamma = 0;\n      _this.m_mass = new Mat33();\n      return _this;\n    }\n    WeldJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        frequencyHz: this.m_frequencyHz,\n        dampingRatio: this.m_dampingRatio,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        referenceAngle: this.m_referenceAngle\n      };\n    };\n    WeldJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new WeldJoint2(data);\n      return joint;\n    };\n    WeldJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (Number.isFinite(def.frequencyHz)) {\n        this.m_frequencyHz = def.frequencyHz;\n      }\n      if (Number.isFinite(def.dampingRatio)) {\n        this.m_dampingRatio = def.dampingRatio;\n      }\n    };\n    WeldJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    WeldJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    WeldJoint2.prototype.getReferenceAngle = function() {\n      return this.m_referenceAngle;\n    };\n    WeldJoint2.prototype.setFrequency = function(hz) {\n      this.m_frequencyHz = hz;\n    };\n    WeldJoint2.prototype.getFrequency = function() {\n      return this.m_frequencyHz;\n    };\n    WeldJoint2.prototype.setDampingRatio = function(ratio) {\n      this.m_dampingRatio = ratio;\n    };\n    WeldJoint2.prototype.getDampingRatio = function() {\n      return this.m_dampingRatio;\n    };\n    WeldJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    WeldJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    WeldJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.neo(this.m_impulse.x, this.m_impulse.y).mul(inv_dt);\n    };\n    WeldJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_impulse.z;\n    };\n    WeldJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      this.m_rA = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      this.m_rB = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var K = new Mat33();\n      K.ex.x = mA + mB + this.m_rA.y * this.m_rA.y * iA + this.m_rB.y * this.m_rB.y * iB;\n      K.ey.x = -this.m_rA.y * this.m_rA.x * iA - this.m_rB.y * this.m_rB.x * iB;\n      K.ez.x = -this.m_rA.y * iA - this.m_rB.y * iB;\n      K.ex.y = K.ey.x;\n      K.ey.y = mA + mB + this.m_rA.x * this.m_rA.x * iA + this.m_rB.x * this.m_rB.x * iB;\n      K.ez.y = this.m_rA.x * iA + this.m_rB.x * iB;\n      K.ex.z = K.ez.x;\n      K.ey.z = K.ez.y;\n      K.ez.z = iA + iB;\n      if (this.m_frequencyHz > 0) {\n        K.getInverse22(this.m_mass);\n        var invM = iA + iB;\n        var m = invM > 0 ? 1 / invM : 0;\n        var C = aB - aA - this.m_referenceAngle;\n        var omega = 2 * math_PI$1 * this.m_frequencyHz;\n        var d2 = 2 * m * this.m_dampingRatio * omega;\n        var k = m * omega * omega;\n        var h = step.dt;\n        this.m_gamma = h * (d2 + h * k);\n        this.m_gamma = this.m_gamma != 0 ? 1 / this.m_gamma : 0;\n        this.m_bias = C * h * k * this.m_gamma;\n        invM += this.m_gamma;\n        this.m_mass.ez.z = invM != 0 ? 1 / invM : 0;\n      } else if (K.ez.z == 0) {\n        K.getInverse22(this.m_mass);\n        this.m_gamma = 0;\n        this.m_bias = 0;\n      } else {\n        K.getSymInverse33(this.m_mass);\n        this.m_gamma = 0;\n        this.m_bias = 0;\n      }\n      if (step.warmStarting) {\n        this.m_impulse.mul(step.dtRatio);\n        var P3 = Vec2.neo(this.m_impulse.x, this.m_impulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + this.m_impulse.z);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + this.m_impulse.z);\n      } else {\n        this.m_impulse.setZero();\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    WeldJoint2.prototype.solveVelocityConstraints = function(step) {\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      if (this.m_frequencyHz > 0) {\n        var Cdot2 = wB - wA;\n        var impulse2 = -this.m_mass.ez.z * (Cdot2 + this.m_bias + this.m_gamma * this.m_impulse.z);\n        this.m_impulse.z += impulse2;\n        wA -= iA * impulse2;\n        wB += iB * impulse2;\n        var Cdot1 = Vec2.zero();\n        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n        var impulse1 = Vec2.neg(Mat33.mulVec2(this.m_mass, Cdot1));\n        this.m_impulse.x += impulse1.x;\n        this.m_impulse.y += impulse1.y;\n        var P3 = Vec2.clone(impulse1);\n        vA2.subMul(mA, P3);\n        wA -= iA * Vec2.crossVec2Vec2(this.m_rA, P3);\n        vB2.addMul(mB, P3);\n        wB += iB * Vec2.crossVec2Vec2(this.m_rB, P3);\n      } else {\n        var Cdot1 = Vec2.zero();\n        Cdot1.addCombine(1, vB2, 1, Vec2.crossNumVec2(wB, this.m_rB));\n        Cdot1.subCombine(1, vA2, 1, Vec2.crossNumVec2(wA, this.m_rA));\n        var Cdot2 = wB - wA;\n        var Cdot = new Vec3(Cdot1.x, Cdot1.y, Cdot2);\n        var impulse = Vec3.neg(Mat33.mulVec3(this.m_mass, Cdot));\n        this.m_impulse.add(impulse);\n        var P3 = Vec2.neo(impulse.x, impulse.y);\n        vA2.subMul(mA, P3);\n        wA -= iA * (Vec2.crossVec2Vec2(this.m_rA, P3) + impulse.z);\n        vB2.addMul(mB, P3);\n        wB += iB * (Vec2.crossVec2Vec2(this.m_rB, P3) + impulse.z);\n      }\n      this.m_bodyA.c_velocity.v = vA2;\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v = vB2;\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    WeldJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var positionError;\n      var angularError;\n      var K = new Mat33();\n      K.ex.x = mA + mB + rA2.y * rA2.y * iA + rB2.y * rB2.y * iB;\n      K.ey.x = -rA2.y * rA2.x * iA - rB2.y * rB2.x * iB;\n      K.ez.x = -rA2.y * iA - rB2.y * iB;\n      K.ex.y = K.ey.x;\n      K.ey.y = mA + mB + rA2.x * rA2.x * iA + rB2.x * rB2.x * iB;\n      K.ez.y = rA2.x * iA + rB2.x * iB;\n      K.ex.z = K.ez.x;\n      K.ey.z = K.ez.y;\n      K.ez.z = iA + iB;\n      if (this.m_frequencyHz > 0) {\n        var C1 = Vec2.zero();\n        C1.addCombine(1, cB2, 1, rB2);\n        C1.subCombine(1, cA2, 1, rA2);\n        positionError = C1.length();\n        angularError = 0;\n        var P3 = Vec2.neg(K.solve22(C1));\n        cA2.subMul(mA, P3);\n        aA -= iA * Vec2.crossVec2Vec2(rA2, P3);\n        cB2.addMul(mB, P3);\n        aB += iB * Vec2.crossVec2Vec2(rB2, P3);\n      } else {\n        var C1 = Vec2.zero();\n        C1.addCombine(1, cB2, 1, rB2);\n        C1.subCombine(1, cA2, 1, rA2);\n        var C2 = aB - aA - this.m_referenceAngle;\n        positionError = C1.length();\n        angularError = math_abs$1(C2);\n        var C = new Vec3(C1.x, C1.y, C2);\n        var impulse = new Vec3();\n        if (K.ez.z > 0) {\n          impulse = Vec3.neg(K.solve33(C));\n        } else {\n          var impulse2 = Vec2.neg(K.solve22(C1));\n          impulse.set(impulse2.x, impulse2.y, 0);\n        }\n        var P3 = Vec2.neo(impulse.x, impulse.y);\n        cA2.subMul(mA, P3);\n        aA -= iA * (Vec2.crossVec2Vec2(rA2, P3) + impulse.z);\n        cB2.addMul(mB, P3);\n        aB += iB * (Vec2.crossVec2Vec2(rB2, P3) + impulse.z);\n      }\n      this.m_bodyA.c_position.c = cA2;\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c = cB2;\n      this.m_bodyB.c_position.a = aB;\n      return positionError <= SettingsInternal.linearSlop && angularError <= SettingsInternal.angularSlop;\n    };\n    WeldJoint2.TYPE = \"weld-joint\";\n    return WeldJoint2;\n  }(Joint)\n);\nvar math_abs = Math.abs;\nvar math_PI = Math.PI;\nvar DEFAULTS = {\n  enableMotor: false,\n  maxMotorTorque: 0,\n  motorSpeed: 0,\n  frequencyHz: 2,\n  dampingRatio: 0.7\n};\nvar WheelJoint = (\n  /** @class */\n  function(_super) {\n    __extends(WheelJoint2, _super);\n    function WheelJoint2(def, bodyA, bodyB, anchor, axis) {\n      var _this = this;\n      if (!(_this instanceof WheelJoint2)) {\n        return new WheelJoint2(def, bodyA, bodyB, anchor, axis);\n      }\n      def = options(def, DEFAULTS);\n      _this = _super.call(this, def, bodyA, bodyB) || this;\n      bodyA = _this.m_bodyA;\n      bodyB = _this.m_bodyB;\n      _this.m_ax = Vec2.zero();\n      _this.m_ay = Vec2.zero();\n      _this.m_type = WheelJoint2.TYPE;\n      _this.m_localAnchorA = Vec2.clone(anchor ? bodyA.getLocalPoint(anchor) : def.localAnchorA || Vec2.zero());\n      _this.m_localAnchorB = Vec2.clone(anchor ? bodyB.getLocalPoint(anchor) : def.localAnchorB || Vec2.zero());\n      if (Vec2.isValid(axis)) {\n        _this.m_localXAxisA = bodyA.getLocalVector(axis);\n      } else if (Vec2.isValid(def.localAxisA)) {\n        _this.m_localXAxisA = Vec2.clone(def.localAxisA);\n      } else if (Vec2.isValid(def.localAxis)) {\n        _this.m_localXAxisA = Vec2.clone(def.localAxis);\n      } else {\n        _this.m_localXAxisA = Vec2.neo(1, 0);\n      }\n      _this.m_localYAxisA = Vec2.crossNumVec2(1, _this.m_localXAxisA);\n      _this.m_mass = 0;\n      _this.m_impulse = 0;\n      _this.m_motorMass = 0;\n      _this.m_motorImpulse = 0;\n      _this.m_springMass = 0;\n      _this.m_springImpulse = 0;\n      _this.m_maxMotorTorque = def.maxMotorTorque;\n      _this.m_motorSpeed = def.motorSpeed;\n      _this.m_enableMotor = def.enableMotor;\n      _this.m_frequencyHz = def.frequencyHz;\n      _this.m_dampingRatio = def.dampingRatio;\n      _this.m_bias = 0;\n      _this.m_gamma = 0;\n      return _this;\n    }\n    WheelJoint2.prototype._serialize = function() {\n      return {\n        type: this.m_type,\n        bodyA: this.m_bodyA,\n        bodyB: this.m_bodyB,\n        collideConnected: this.m_collideConnected,\n        enableMotor: this.m_enableMotor,\n        maxMotorTorque: this.m_maxMotorTorque,\n        motorSpeed: this.m_motorSpeed,\n        frequencyHz: this.m_frequencyHz,\n        dampingRatio: this.m_dampingRatio,\n        localAnchorA: this.m_localAnchorA,\n        localAnchorB: this.m_localAnchorB,\n        localAxisA: this.m_localXAxisA\n      };\n    };\n    WheelJoint2._deserialize = function(data, world, restore) {\n      data = __assign({}, data);\n      data.bodyA = restore(Body, data.bodyA, world);\n      data.bodyB = restore(Body, data.bodyB, world);\n      var joint = new WheelJoint2(data);\n      return joint;\n    };\n    WheelJoint2.prototype._reset = function(def) {\n      if (def.anchorA) {\n        this.m_localAnchorA.setVec2(this.m_bodyA.getLocalPoint(def.anchorA));\n      } else if (def.localAnchorA) {\n        this.m_localAnchorA.setVec2(def.localAnchorA);\n      }\n      if (def.anchorB) {\n        this.m_localAnchorB.setVec2(this.m_bodyB.getLocalPoint(def.anchorB));\n      } else if (def.localAnchorB) {\n        this.m_localAnchorB.setVec2(def.localAnchorB);\n      }\n      if (def.localAxisA) {\n        this.m_localXAxisA.setVec2(def.localAxisA);\n        this.m_localYAxisA.setVec2(Vec2.crossNumVec2(1, def.localAxisA));\n      }\n      if (def.enableMotor !== void 0) {\n        this.m_enableMotor = def.enableMotor;\n      }\n      if (Number.isFinite(def.maxMotorTorque)) {\n        this.m_maxMotorTorque = def.maxMotorTorque;\n      }\n      if (Number.isFinite(def.motorSpeed)) {\n        this.m_motorSpeed = def.motorSpeed;\n      }\n      if (Number.isFinite(def.frequencyHz)) {\n        this.m_frequencyHz = def.frequencyHz;\n      }\n      if (Number.isFinite(def.dampingRatio)) {\n        this.m_dampingRatio = def.dampingRatio;\n      }\n    };\n    WheelJoint2.prototype.getLocalAnchorA = function() {\n      return this.m_localAnchorA;\n    };\n    WheelJoint2.prototype.getLocalAnchorB = function() {\n      return this.m_localAnchorB;\n    };\n    WheelJoint2.prototype.getLocalAxisA = function() {\n      return this.m_localXAxisA;\n    };\n    WheelJoint2.prototype.getJointTranslation = function() {\n      var bA = this.m_bodyA;\n      var bB = this.m_bodyB;\n      var pA2 = bA.getWorldPoint(this.m_localAnchorA);\n      var pB2 = bB.getWorldPoint(this.m_localAnchorB);\n      var d2 = Vec2.sub(pB2, pA2);\n      var axis = bA.getWorldVector(this.m_localXAxisA);\n      var translation2 = Vec2.dot(d2, axis);\n      return translation2;\n    };\n    WheelJoint2.prototype.getJointSpeed = function() {\n      var wA = this.m_bodyA.m_angularVelocity;\n      var wB = this.m_bodyB.m_angularVelocity;\n      return wB - wA;\n    };\n    WheelJoint2.prototype.isMotorEnabled = function() {\n      return this.m_enableMotor;\n    };\n    WheelJoint2.prototype.enableMotor = function(flag) {\n      if (flag == this.m_enableMotor)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_enableMotor = flag;\n    };\n    WheelJoint2.prototype.setMotorSpeed = function(speed) {\n      if (speed == this.m_motorSpeed)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_motorSpeed = speed;\n    };\n    WheelJoint2.prototype.getMotorSpeed = function() {\n      return this.m_motorSpeed;\n    };\n    WheelJoint2.prototype.setMaxMotorTorque = function(torque) {\n      if (torque == this.m_maxMotorTorque)\n        return;\n      this.m_bodyA.setAwake(true);\n      this.m_bodyB.setAwake(true);\n      this.m_maxMotorTorque = torque;\n    };\n    WheelJoint2.prototype.getMaxMotorTorque = function() {\n      return this.m_maxMotorTorque;\n    };\n    WheelJoint2.prototype.getMotorTorque = function(inv_dt) {\n      return inv_dt * this.m_motorImpulse;\n    };\n    WheelJoint2.prototype.setSpringFrequencyHz = function(hz) {\n      this.m_frequencyHz = hz;\n    };\n    WheelJoint2.prototype.getSpringFrequencyHz = function() {\n      return this.m_frequencyHz;\n    };\n    WheelJoint2.prototype.setSpringDampingRatio = function(ratio) {\n      this.m_dampingRatio = ratio;\n    };\n    WheelJoint2.prototype.getSpringDampingRatio = function() {\n      return this.m_dampingRatio;\n    };\n    WheelJoint2.prototype.getAnchorA = function() {\n      return this.m_bodyA.getWorldPoint(this.m_localAnchorA);\n    };\n    WheelJoint2.prototype.getAnchorB = function() {\n      return this.m_bodyB.getWorldPoint(this.m_localAnchorB);\n    };\n    WheelJoint2.prototype.getReactionForce = function(inv_dt) {\n      return Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax).mul(inv_dt);\n    };\n    WheelJoint2.prototype.getReactionTorque = function(inv_dt) {\n      return inv_dt * this.m_motorImpulse;\n    };\n    WheelJoint2.prototype.initVelocityConstraints = function(step) {\n      this.m_localCenterA = this.m_bodyA.m_sweep.localCenter;\n      this.m_localCenterB = this.m_bodyB.m_sweep.localCenter;\n      this.m_invMassA = this.m_bodyA.m_invMass;\n      this.m_invMassB = this.m_bodyB.m_invMass;\n      this.m_invIA = this.m_bodyA.m_invI;\n      this.m_invIB = this.m_bodyB.m_invI;\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var d2 = Vec2.zero();\n      d2.addCombine(1, cB2, 1, rB2);\n      d2.subCombine(1, cA2, 1, rA2);\n      {\n        this.m_ay = Rot.mulVec2(qA, this.m_localYAxisA);\n        this.m_sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ay);\n        this.m_sBy = Vec2.crossVec2Vec2(rB2, this.m_ay);\n        this.m_mass = mA + mB + iA * this.m_sAy * this.m_sAy + iB * this.m_sBy * this.m_sBy;\n        if (this.m_mass > 0) {\n          this.m_mass = 1 / this.m_mass;\n        }\n      }\n      this.m_springMass = 0;\n      this.m_bias = 0;\n      this.m_gamma = 0;\n      if (this.m_frequencyHz > 0) {\n        this.m_ax = Rot.mulVec2(qA, this.m_localXAxisA);\n        this.m_sAx = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), this.m_ax);\n        this.m_sBx = Vec2.crossVec2Vec2(rB2, this.m_ax);\n        var invMass = mA + mB + iA * this.m_sAx * this.m_sAx + iB * this.m_sBx * this.m_sBx;\n        if (invMass > 0) {\n          this.m_springMass = 1 / invMass;\n          var C = Vec2.dot(d2, this.m_ax);\n          var omega = 2 * math_PI * this.m_frequencyHz;\n          var damp = 2 * this.m_springMass * this.m_dampingRatio * omega;\n          var k = this.m_springMass * omega * omega;\n          var h = step.dt;\n          this.m_gamma = h * (damp + h * k);\n          if (this.m_gamma > 0) {\n            this.m_gamma = 1 / this.m_gamma;\n          }\n          this.m_bias = C * h * k * this.m_gamma;\n          this.m_springMass = invMass + this.m_gamma;\n          if (this.m_springMass > 0) {\n            this.m_springMass = 1 / this.m_springMass;\n          }\n        }\n      } else {\n        this.m_springImpulse = 0;\n      }\n      if (this.m_enableMotor) {\n        this.m_motorMass = iA + iB;\n        if (this.m_motorMass > 0) {\n          this.m_motorMass = 1 / this.m_motorMass;\n        }\n      } else {\n        this.m_motorMass = 0;\n        this.m_motorImpulse = 0;\n      }\n      if (step.warmStarting) {\n        this.m_impulse *= step.dtRatio;\n        this.m_springImpulse *= step.dtRatio;\n        this.m_motorImpulse *= step.dtRatio;\n        var P3 = Vec2.combine(this.m_impulse, this.m_ay, this.m_springImpulse, this.m_ax);\n        var LA = this.m_impulse * this.m_sAy + this.m_springImpulse * this.m_sAx + this.m_motorImpulse;\n        var LB = this.m_impulse * this.m_sBy + this.m_springImpulse * this.m_sBx + this.m_motorImpulse;\n        vA2.subMul(this.m_invMassA, P3);\n        wA -= this.m_invIA * LA;\n        vB2.addMul(this.m_invMassB, P3);\n        wB += this.m_invIB * LB;\n      } else {\n        this.m_impulse = 0;\n        this.m_springImpulse = 0;\n        this.m_motorImpulse = 0;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    WheelJoint2.prototype.solveVelocityConstraints = function(step) {\n      var mA = this.m_invMassA;\n      var mB = this.m_invMassB;\n      var iA = this.m_invIA;\n      var iB = this.m_invIB;\n      var vA2 = this.m_bodyA.c_velocity.v;\n      var wA = this.m_bodyA.c_velocity.w;\n      var vB2 = this.m_bodyB.c_velocity.v;\n      var wB = this.m_bodyB.c_velocity.w;\n      {\n        var Cdot = Vec2.dot(this.m_ax, vB2) - Vec2.dot(this.m_ax, vA2) + this.m_sBx * wB - this.m_sAx * wA;\n        var impulse = -this.m_springMass * (Cdot + this.m_bias + this.m_gamma * this.m_springImpulse);\n        this.m_springImpulse += impulse;\n        var P3 = Vec2.mulNumVec2(impulse, this.m_ax);\n        var LA = impulse * this.m_sAx;\n        var LB = impulse * this.m_sBx;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      }\n      {\n        var Cdot = wB - wA - this.m_motorSpeed;\n        var impulse = -this.m_motorMass * Cdot;\n        var oldImpulse = this.m_motorImpulse;\n        var maxImpulse = step.dt * this.m_maxMotorTorque;\n        this.m_motorImpulse = clamp(this.m_motorImpulse + impulse, -maxImpulse, maxImpulse);\n        impulse = this.m_motorImpulse - oldImpulse;\n        wA -= iA * impulse;\n        wB += iB * impulse;\n      }\n      {\n        var Cdot = Vec2.dot(this.m_ay, vB2) - Vec2.dot(this.m_ay, vA2) + this.m_sBy * wB - this.m_sAy * wA;\n        var impulse = -this.m_mass * Cdot;\n        this.m_impulse += impulse;\n        var P3 = Vec2.mulNumVec2(impulse, this.m_ay);\n        var LA = impulse * this.m_sAy;\n        var LB = impulse * this.m_sBy;\n        vA2.subMul(mA, P3);\n        wA -= iA * LA;\n        vB2.addMul(mB, P3);\n        wB += iB * LB;\n      }\n      this.m_bodyA.c_velocity.v.setVec2(vA2);\n      this.m_bodyA.c_velocity.w = wA;\n      this.m_bodyB.c_velocity.v.setVec2(vB2);\n      this.m_bodyB.c_velocity.w = wB;\n    };\n    WheelJoint2.prototype.solvePositionConstraints = function(step) {\n      var cA2 = this.m_bodyA.c_position.c;\n      var aA = this.m_bodyA.c_position.a;\n      var cB2 = this.m_bodyB.c_position.c;\n      var aB = this.m_bodyB.c_position.a;\n      var qA = Rot.neo(aA);\n      var qB = Rot.neo(aB);\n      var rA2 = Rot.mulVec2(qA, Vec2.sub(this.m_localAnchorA, this.m_localCenterA));\n      var rB2 = Rot.mulVec2(qB, Vec2.sub(this.m_localAnchorB, this.m_localCenterB));\n      var d2 = Vec2.zero();\n      d2.addCombine(1, cB2, 1, rB2);\n      d2.subCombine(1, cA2, 1, rA2);\n      var ay = Rot.mulVec2(qA, this.m_localYAxisA);\n      var sAy = Vec2.crossVec2Vec2(Vec2.add(d2, rA2), ay);\n      var sBy = Vec2.crossVec2Vec2(rB2, ay);\n      var C = Vec2.dot(d2, ay);\n      var k = this.m_invMassA + this.m_invMassB + this.m_invIA * this.m_sAy * this.m_sAy + this.m_invIB * this.m_sBy * this.m_sBy;\n      var impulse = k != 0 ? -C / k : 0;\n      var P3 = Vec2.mulNumVec2(impulse, ay);\n      var LA = impulse * sAy;\n      var LB = impulse * sBy;\n      cA2.subMul(this.m_invMassA, P3);\n      aA -= this.m_invIA * LA;\n      cB2.addMul(this.m_invMassB, P3);\n      aB += this.m_invIB * LB;\n      this.m_bodyA.c_position.c.setVec2(cA2);\n      this.m_bodyA.c_position.a = aA;\n      this.m_bodyB.c_position.c.setVec2(cB2);\n      this.m_bodyB.c_position.a = aB;\n      return math_abs(C) <= SettingsInternal.linearSlop;\n    };\n    WheelJoint2.TYPE = \"wheel-joint\";\n    return WheelJoint2;\n  }(Joint)\n);\nvar _a;\nvar SID = 0;\nvar SERIALIZE_REF_TYPES = {\n  \"World\": World,\n  \"Body\": Body,\n  \"Joint\": Joint,\n  \"Fixture\": Fixture,\n  \"Shape\": Shape\n};\nvar DESERIALIZE_BY_REF_TYPE = {\n  \"Vec2\": Vec2,\n  \"Vec3\": Vec3,\n  \"World\": World,\n  \"Body\": Body,\n  \"Joint\": Joint,\n  \"Fixture\": Fixture,\n  \"Shape\": Shape\n};\nvar DESERIALIZE_BY_TYPE_FIELD = (_a = {}, _a[Body.STATIC] = Body, _a[Body.DYNAMIC] = Body, _a[Body.KINEMATIC] = Body, _a[ChainShape.TYPE] = ChainShape, // [BoxShape.TYPE]: BoxShape,\n_a[PolygonShape.TYPE] = PolygonShape, _a[EdgeShape.TYPE] = EdgeShape, _a[CircleShape.TYPE] = CircleShape, _a[DistanceJoint.TYPE] = DistanceJoint, _a[FrictionJoint.TYPE] = FrictionJoint, _a[GearJoint.TYPE] = GearJoint, _a[MotorJoint.TYPE] = MotorJoint, _a[MouseJoint.TYPE] = MouseJoint, _a[PrismaticJoint.TYPE] = PrismaticJoint, _a[PulleyJoint.TYPE] = PulleyJoint, _a[RevoluteJoint.TYPE] = RevoluteJoint, _a[RopeJoint.TYPE] = RopeJoint, _a[WeldJoint.TYPE] = WeldJoint, _a[WheelJoint.TYPE] = WheelJoint, _a);\nvar DEFAULT_OPTIONS = {\n  rootClass: World,\n  preSerialize: function(obj) {\n    return obj;\n  },\n  postSerialize: function(data, obj) {\n    return data;\n  },\n  preDeserialize: function(data) {\n    return data;\n  },\n  postDeserialize: function(obj, data) {\n    return obj;\n  }\n};\nvar Serializer = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function Serializer2(options2) {\n      var _this = this;\n      this.toJson = function(root) {\n        var preSerialize = _this.options.preSerialize;\n        var postSerialize = _this.options.postSerialize;\n        var json = [];\n        var refQueue = [root];\n        var refMemoById = {};\n        function addToRefQueue(value, typeName) {\n          value.__sid = value.__sid || ++SID;\n          if (!refMemoById[value.__sid]) {\n            refQueue.push(value);\n            var index = json.length + refQueue.length;\n            var ref = {\n              refIndex: index,\n              refType: typeName\n            };\n            refMemoById[value.__sid] = ref;\n          }\n          return refMemoById[value.__sid];\n        }\n        function serializeWithHooks(obj2) {\n          obj2 = preSerialize(obj2);\n          var data = obj2._serialize();\n          data = postSerialize(data, obj2);\n          return data;\n        }\n        function traverse(value, noRefType) {\n          if (noRefType === void 0) {\n            noRefType = false;\n          }\n          if (typeof value !== \"object\" || value === null) {\n            return value;\n          }\n          if (typeof value._serialize === \"function\") {\n            if (!noRefType) {\n              for (var typeName in SERIALIZE_REF_TYPES) {\n                if (value instanceof SERIALIZE_REF_TYPES[typeName]) {\n                  return addToRefQueue(value, typeName);\n                }\n              }\n            }\n            value = serializeWithHooks(value);\n          }\n          if (Array.isArray(value)) {\n            var newValue = [];\n            for (var key = 0; key < value.length; key++) {\n              newValue[key] = traverse(value[key]);\n            }\n            value = newValue;\n          } else {\n            var newValue = {};\n            for (var key in value) {\n              if (value.hasOwnProperty(key)) {\n                newValue[key] = traverse(value[key]);\n              }\n            }\n            value = newValue;\n          }\n          return value;\n        }\n        while (refQueue.length) {\n          var obj = refQueue.shift();\n          var str = traverse(obj, true);\n          json.push(str);\n        }\n        return json;\n      };\n      this.fromJson = function(json) {\n        var preDeserialize = _this.options.preDeserialize;\n        var postDeserialize = _this.options.postDeserialize;\n        var rootClass = _this.options.rootClass;\n        var deserializedRefMemoByIndex = {};\n        function deserializeWithHooks(classHint, data, context) {\n          if (!classHint || !classHint._deserialize) {\n            classHint = DESERIALIZE_BY_TYPE_FIELD[data.type];\n          }\n          var deserializer = classHint && classHint._deserialize;\n          if (!deserializer) {\n            return;\n          }\n          data = preDeserialize(data);\n          var classDeserializeFn = classHint._deserialize;\n          var obj = classDeserializeFn(data, context, deserializeChild);\n          obj = postDeserialize(obj, data);\n          return obj;\n        }\n        function deserializeChild(classHint, dataOrRef, context) {\n          var isRefObject = dataOrRef.refIndex && dataOrRef.refType;\n          if (!isRefObject) {\n            return deserializeWithHooks(classHint, dataOrRef, context);\n          }\n          var ref = dataOrRef;\n          if (DESERIALIZE_BY_REF_TYPE[ref.refType]) {\n            classHint = DESERIALIZE_BY_REF_TYPE[ref.refType];\n          }\n          var refIndex = ref.refIndex;\n          if (!deserializedRefMemoByIndex[refIndex]) {\n            var data = json[refIndex];\n            var obj = deserializeWithHooks(classHint, data, context);\n            deserializedRefMemoByIndex[refIndex] = obj;\n          }\n          return deserializedRefMemoByIndex[refIndex];\n        }\n        var root = deserializeWithHooks(rootClass, json[0], null);\n        return root;\n      };\n      this.options = __assign(__assign({}, DEFAULT_OPTIONS), options2);\n    }\n    return Serializer2;\n  }()\n);\nvar worldSerializer = new Serializer({\n  rootClass: World\n});\nSerializer.fromJson = worldSerializer.fromJson;\nSerializer.toJson = worldSerializer.toJson;\nvar Testbed = (\n  /** @class */\n  function() {\n    function Testbed2() {\n      this.width = 80;\n      this.height = 60;\n      this.x = 0;\n      this.y = -10;\n      this.scaleY = -1;\n      this.hz = 60;\n      this.speed = 1;\n      this.background = \"#222222\";\n      this.activeKeys = {};\n      this.step = function(dt, t) {\n        return;\n      };\n      this.keydown = function(keyCode, label) {\n        return;\n      };\n      this.keyup = function(keyCode, label) {\n        return;\n      };\n    }\n    Testbed2.mount = function(options2) {\n      throw new Error(\"Not implemented\");\n    };\n    Testbed2.start = function(world) {\n      var testbed2 = Testbed2.mount();\n      testbed2.start(world);\n      return testbed2;\n    };\n    Testbed2.prototype.color = function(r, g, b2) {\n      r = r * 256 | 0;\n      g = g * 256 | 0;\n      b2 = b2 * 256 | 0;\n      return \"rgb(\" + r + \", \" + g + \", \" + b2 + \")\";\n    };\n    return Testbed2;\n  }()\n);\nfunction testbed(a2, b2) {\n  var callback;\n  var options2;\n  if (typeof a2 === \"function\") {\n    callback = a2;\n    options2 = b2;\n  } else if (typeof b2 === \"function\") {\n    callback = b2;\n    options2 = a2;\n  } else {\n    options2 = a2 !== null && a2 !== void 0 ? a2 : b2;\n  }\n  var testbed2 = Testbed.mount(options2);\n  if (callback) {\n    var world = callback(testbed2) || testbed2.world;\n    testbed2.start(world);\n  } else {\n    return testbed2;\n  }\n}\nvar BoxShape = (\n  /** @class */\n  function(_super) {\n    __extends(BoxShape2, _super);\n    function BoxShape2(halfWidth, halfHeight, center2, angle) {\n      var _this = this;\n      if (!(_this instanceof BoxShape2)) {\n        return new BoxShape2(halfWidth, halfHeight, center2, angle);\n      }\n      _this = _super.call(this) || this;\n      _this._setAsBox(halfWidth, halfHeight, center2, angle);\n      return _this;\n    }\n    BoxShape2.TYPE = \"polygon\";\n    return BoxShape2;\n  }(PolygonShape)\n);\nvar Box = BoxShape;\nContact.addType(CircleShape.TYPE, CircleShape.TYPE, CircleCircleContact);\nfunction CircleCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n  CollideCircles(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n}\nvar pA = vec2(0, 0);\nvar pB = vec2(0, 0);\nvar CollideCircles = function(manifold, circleA, xfA2, circleB, xfB2) {\n  manifold.pointCount = 0;\n  transformVec2(pA, xfA2, circleA.m_p);\n  transformVec2(pB, xfB2, circleB.m_p);\n  var distSqr = distSqrVec2(pB, pA);\n  var rA2 = circleA.m_radius;\n  var rB2 = circleB.m_radius;\n  var radius = rA2 + rB2;\n  if (distSqr > radius * radius) {\n    return;\n  }\n  manifold.type = ManifoldType.e_circles;\n  copyVec2(manifold.localPoint, circleA.m_p);\n  zeroVec2(manifold.localNormal);\n  manifold.pointCount = 1;\n  copyVec2(manifold.points[0].localPoint, circleB.m_p);\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n};\nContact.addType(EdgeShape.TYPE, CircleShape.TYPE, EdgeCircleContact);\nContact.addType(ChainShape.TYPE, CircleShape.TYPE, ChainCircleContact);\nfunction EdgeCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n  var shapeA = fixtureA.getShape();\n  var shapeB = fixtureB.getShape();\n  CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);\n}\nfunction ChainCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n  var chain = fixtureA.getShape();\n  var edge = new EdgeShape();\n  chain.getChildEdge(edge, indexA);\n  var shapeA = edge;\n  var shapeB = fixtureB.getShape();\n  CollideEdgeCircle(manifold, shapeA, xfA2, shapeB, xfB2);\n}\nvar e = vec2(0, 0);\nvar e1 = vec2(0, 0);\nvar e2 = vec2(0, 0);\nvar Q = vec2(0, 0);\nvar P = vec2(0, 0);\nvar n$2 = vec2(0, 0);\nvar CollideEdgeCircle = function(manifold, edgeA, xfA2, circleB, xfB2) {\n  manifold.pointCount = 0;\n  retransformVec2(Q, xfB2, xfA2, circleB.m_p);\n  var A = edgeA.m_vertex1;\n  var B = edgeA.m_vertex2;\n  subVec2(e, B, A);\n  var u = dotVec2(e, B) - dotVec2(e, Q);\n  var v3 = dotVec2(e, Q) - dotVec2(e, A);\n  var radius = edgeA.m_radius + circleB.m_radius;\n  if (v3 <= 0) {\n    copyVec2(P, A);\n    var dd_1 = distSqrVec2(Q, A);\n    if (dd_1 > radius * radius) {\n      return;\n    }\n    if (edgeA.m_hasVertex0) {\n      var A1 = edgeA.m_vertex0;\n      var B1 = A;\n      subVec2(e1, B1, A1);\n      var u1 = dotVec2(e1, B1) - dotVec2(e1, Q);\n      if (u1 > 0) {\n        return;\n      }\n    }\n    manifold.type = ManifoldType.e_circles;\n    zeroVec2(manifold.localNormal);\n    copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n  if (u <= 0) {\n    copyVec2(P, B);\n    var dd_2 = distSqrVec2(Q, P);\n    if (dd_2 > radius * radius) {\n      return;\n    }\n    if (edgeA.m_hasVertex3) {\n      var B2 = edgeA.m_vertex3;\n      var A2 = B;\n      subVec2(e2, B2, A2);\n      var v22 = dotVec2(e2, Q) - dotVec2(e2, A2);\n      if (v22 > 0) {\n        return;\n      }\n    }\n    manifold.type = ManifoldType.e_circles;\n    zeroVec2(manifold.localNormal);\n    copyVec2(manifold.localPoint, P);\n    manifold.pointCount = 1;\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(1, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n  var den = lengthSqrVec2(e);\n  combine2Vec2(P, u / den, A, v3 / den, B);\n  var dd = distSqrVec2(Q, P);\n  if (dd > radius * radius) {\n    return;\n  }\n  crossNumVec2(n$2, 1, e);\n  if (dotVec2(n$2, Q) - dotVec2(n$2, A) < 0) {\n    negVec2(n$2);\n  }\n  normalizeVec2(n$2);\n  manifold.type = ManifoldType.e_faceA;\n  copyVec2(manifold.localNormal, n$2);\n  copyVec2(manifold.localPoint, A);\n  manifold.pointCount = 1;\n  copyVec2(manifold.points[0].localPoint, circleB.m_p);\n  manifold.points[0].id.setFeatures(0, ContactFeatureType.e_face, 0, ContactFeatureType.e_vertex);\n};\nvar incidentEdge = [new ClipVertex(), new ClipVertex()];\nvar clipPoints1$1 = [new ClipVertex(), new ClipVertex()];\nvar clipPoints2$1 = [new ClipVertex(), new ClipVertex()];\nvar clipSegmentToLineNormal = vec2(0, 0);\nvar v1 = vec2(0, 0);\nvar n$1 = vec2(0, 0);\nvar xf$1 = transform(0, 0, 0);\nvar v11 = vec2(0, 0);\nvar v12 = vec2(0, 0);\nvar localTangent = vec2(0, 0);\nvar localNormal = vec2(0, 0);\nvar planePoint = vec2(0, 0);\nvar tangent = vec2(0, 0);\nvar normal$1 = vec2(0, 0);\nvar normal1$1 = vec2(0, 0);\nContact.addType(PolygonShape.TYPE, PolygonShape.TYPE, PolygonContact);\nfunction PolygonContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n  CollidePolygons(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n}\nfunction findMaxSeparation(poly1, xf1, poly2, xf2, output2) {\n  var count1 = poly1.m_count;\n  var count2 = poly2.m_count;\n  var n1s = poly1.m_normals;\n  var v1s = poly1.m_vertices;\n  var v2s = poly2.m_vertices;\n  detransformTransform(xf$1, xf2, xf1);\n  var bestIndex = 0;\n  var maxSeparation2 = -Infinity;\n  for (var i = 0; i < count1; ++i) {\n    rotVec2(n$1, xf$1.q, n1s[i]);\n    transformVec2(v1, xf$1, v1s[i]);\n    var si = Infinity;\n    for (var j = 0; j < count2; ++j) {\n      var sij = dotVec2(n$1, v2s[j]) - dotVec2(n$1, v1);\n      if (sij < si) {\n        si = sij;\n      }\n    }\n    if (si > maxSeparation2) {\n      maxSeparation2 = si;\n      bestIndex = i;\n    }\n  }\n  output2.maxSeparation = maxSeparation2;\n  output2.bestIndex = bestIndex;\n}\nfunction findIncidentEdge(clipVertex, poly1, xf1, edge12, poly2, xf2) {\n  var normals1 = poly1.m_normals;\n  var count2 = poly2.m_count;\n  var vertices2 = poly2.m_vertices;\n  var normals2 = poly2.m_normals;\n  rerotVec2(normal1$1, xf2.q, xf1.q, normals1[edge12]);\n  var index = 0;\n  var minDot = Infinity;\n  for (var i = 0; i < count2; ++i) {\n    var dot = dotVec2(normal1$1, normals2[i]);\n    if (dot < minDot) {\n      minDot = dot;\n      index = i;\n    }\n  }\n  var i1 = index;\n  var i2 = i1 + 1 < count2 ? i1 + 1 : 0;\n  transformVec2(clipVertex[0].v, xf2, vertices2[i1]);\n  clipVertex[0].id.setFeatures(edge12, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n  transformVec2(clipVertex[1].v, xf2, vertices2[i2]);\n  clipVertex[1].id.setFeatures(edge12, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n}\nvar maxSeparation = {\n  maxSeparation: 0,\n  bestIndex: 0\n};\nvar CollidePolygons = function(manifold, polyA, xfA2, polyB, xfB2) {\n  manifold.pointCount = 0;\n  var totalRadius = polyA.m_radius + polyB.m_radius;\n  findMaxSeparation(polyA, xfA2, polyB, xfB2, maxSeparation);\n  var edgeA = maxSeparation.bestIndex;\n  var separationA = maxSeparation.maxSeparation;\n  if (separationA > totalRadius)\n    return;\n  findMaxSeparation(polyB, xfB2, polyA, xfA2, maxSeparation);\n  var edgeB = maxSeparation.bestIndex;\n  var separationB = maxSeparation.maxSeparation;\n  if (separationB > totalRadius)\n    return;\n  var poly1;\n  var poly2;\n  var xf1;\n  var xf2;\n  var edge12;\n  var flip;\n  var k_tol = 0.1 * SettingsInternal.linearSlop;\n  if (separationB > separationA + k_tol) {\n    poly1 = polyB;\n    poly2 = polyA;\n    xf1 = xfB2;\n    xf2 = xfA2;\n    edge12 = edgeB;\n    manifold.type = ManifoldType.e_faceB;\n    flip = true;\n  } else {\n    poly1 = polyA;\n    poly2 = polyB;\n    xf1 = xfA2;\n    xf2 = xfB2;\n    edge12 = edgeA;\n    manifold.type = ManifoldType.e_faceA;\n    flip = false;\n  }\n  incidentEdge[0].recycle();\n  incidentEdge[1].recycle();\n  findIncidentEdge(incidentEdge, poly1, xf1, edge12, poly2, xf2);\n  var count1 = poly1.m_count;\n  var vertices1 = poly1.m_vertices;\n  var iv1 = edge12;\n  var iv2 = edge12 + 1 < count1 ? edge12 + 1 : 0;\n  copyVec2(v11, vertices1[iv1]);\n  copyVec2(v12, vertices1[iv2]);\n  subVec2(localTangent, v12, v11);\n  normalizeVec2(localTangent);\n  crossVec2Num(localNormal, localTangent, 1);\n  combine2Vec2(planePoint, 0.5, v11, 0.5, v12);\n  rotVec2(tangent, xf1.q, localTangent);\n  crossVec2Num(normal$1, tangent, 1);\n  transformVec2(v11, xf1, v11);\n  transformVec2(v12, xf1, v12);\n  var frontOffset = dotVec2(normal$1, v11);\n  var sideOffset1 = -dotVec2(tangent, v11) + totalRadius;\n  var sideOffset2 = dotVec2(tangent, v12) + totalRadius;\n  clipPoints1$1[0].recycle();\n  clipPoints1$1[1].recycle();\n  clipPoints2$1[0].recycle();\n  clipPoints2$1[1].recycle();\n  setVec2(clipSegmentToLineNormal, -tangent.x, -tangent.y);\n  var np1 = clipSegmentToLine(clipPoints1$1, incidentEdge, clipSegmentToLineNormal, sideOffset1, iv1);\n  if (np1 < 2) {\n    return;\n  }\n  setVec2(clipSegmentToLineNormal, tangent.x, tangent.y);\n  var np2 = clipSegmentToLine(clipPoints2$1, clipPoints1$1, clipSegmentToLineNormal, sideOffset2, iv2);\n  if (np2 < 2) {\n    return;\n  }\n  copyVec2(manifold.localNormal, localNormal);\n  copyVec2(manifold.localPoint, planePoint);\n  var pointCount = 0;\n  for (var i = 0; i < clipPoints2$1.length; ++i) {\n    var separation = dotVec2(normal$1, clipPoints2$1[i].v) - frontOffset;\n    if (separation <= totalRadius) {\n      var cp = manifold.points[pointCount];\n      detransformVec2(cp.localPoint, xf2, clipPoints2$1[i].v);\n      cp.id.set(clipPoints2$1[i].id);\n      if (flip) {\n        cp.id.swapFeatures();\n      }\n      ++pointCount;\n    }\n  }\n  manifold.pointCount = pointCount;\n};\nContact.addType(PolygonShape.TYPE, CircleShape.TYPE, PolygonCircleContact);\nfunction PolygonCircleContact(manifold, xfA2, fixtureA, indexA, xfB2, fixtureB, indexB) {\n  CollidePolygonCircle(manifold, fixtureA.getShape(), xfA2, fixtureB.getShape(), xfB2);\n}\nvar cLocal = vec2(0, 0);\nvar faceCenter = vec2(0, 0);\nvar CollidePolygonCircle = function(manifold, polygonA, xfA2, circleB, xfB2) {\n  manifold.pointCount = 0;\n  retransformVec2(cLocal, xfB2, xfA2, circleB.m_p);\n  var normalIndex = 0;\n  var separation = -Infinity;\n  var radius = polygonA.m_radius + circleB.m_radius;\n  var vertexCount = polygonA.m_count;\n  var vertices = polygonA.m_vertices;\n  var normals = polygonA.m_normals;\n  for (var i = 0; i < vertexCount; ++i) {\n    var s2 = dotVec2(normals[i], cLocal) - dotVec2(normals[i], vertices[i]);\n    if (s2 > radius) {\n      return;\n    }\n    if (s2 > separation) {\n      separation = s2;\n      normalIndex = i;\n    }\n  }\n  var vertIndex1 = normalIndex;\n  var vertIndex2 = vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0;\n  var v13 = vertices[vertIndex1];\n  var v22 = vertices[vertIndex2];\n  if (separation < EPSILON) {\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    copyVec2(manifold.localNormal, normals[normalIndex]);\n    combine2Vec2(manifold.localPoint, 0.5, v13, 0.5, v22);\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n    return;\n  }\n  var u1 = dotVec2(cLocal, v22) - dotVec2(cLocal, v13) - dotVec2(v13, v22) + dotVec2(v13, v13);\n  var u2 = dotVec2(cLocal, v13) - dotVec2(cLocal, v22) - dotVec2(v22, v13) + dotVec2(v22, v22);\n  if (u1 <= 0) {\n    if (distSqrVec2(cLocal, v13) > radius * radius) {\n      return;\n    }\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    subVec2(manifold.localNormal, cLocal, v13);\n    normalizeVec2(manifold.localNormal);\n    copyVec2(manifold.localPoint, v13);\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else if (u2 <= 0) {\n    if (distSqrVec2(cLocal, v22) > radius * radius) {\n      return;\n    }\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    subVec2(manifold.localNormal, cLocal, v22);\n    normalizeVec2(manifold.localNormal);\n    copyVec2(manifold.localPoint, v22);\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  } else {\n    combine2Vec2(faceCenter, 0.5, v13, 0.5, v22);\n    var separation_1 = dotVec2(cLocal, normals[vertIndex1]) - dotVec2(faceCenter, normals[vertIndex1]);\n    if (separation_1 > radius) {\n      return;\n    }\n    manifold.pointCount = 1;\n    manifold.type = ManifoldType.e_faceA;\n    copyVec2(manifold.localNormal, normals[vertIndex1]);\n    copyVec2(manifold.localPoint, faceCenter);\n    copyVec2(manifold.points[0].localPoint, circleB.m_p);\n    manifold.points[0].id.setFeatures(0, ContactFeatureType.e_vertex, 0, ContactFeatureType.e_vertex);\n  }\n};\nvar math_min = Math.min;\nContact.addType(EdgeShape.TYPE, PolygonShape.TYPE, EdgePolygonContact);\nContact.addType(ChainShape.TYPE, PolygonShape.TYPE, ChainPolygonContact);\nfunction EdgePolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {\n  CollideEdgePolygon(manifold, fA.getShape(), xfA2, fB.getShape(), xfB2);\n}\nvar edge_reuse = new EdgeShape();\nfunction ChainPolygonContact(manifold, xfA2, fA, indexA, xfB2, fB, indexB) {\n  var chain = fA.getShape();\n  chain.getChildEdge(edge_reuse, indexA);\n  CollideEdgePolygon(manifold, edge_reuse, xfA2, fB.getShape(), xfB2);\n}\nvar EPAxisType;\n(function(EPAxisType2) {\n  EPAxisType2[EPAxisType2[\"e_unknown\"] = -1] = \"e_unknown\";\n  EPAxisType2[EPAxisType2[\"e_edgeA\"] = 1] = \"e_edgeA\";\n  EPAxisType2[EPAxisType2[\"e_edgeB\"] = 2] = \"e_edgeB\";\n})(EPAxisType || (EPAxisType = {}));\nvar VertexType;\n(function(VertexType2) {\n  VertexType2[VertexType2[\"e_isolated\"] = 0] = \"e_isolated\";\n  VertexType2[VertexType2[\"e_concave\"] = 1] = \"e_concave\";\n  VertexType2[VertexType2[\"e_convex\"] = 2] = \"e_convex\";\n})(VertexType || (VertexType = {}));\nvar EPAxis = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function EPAxis2() {\n    }\n    return EPAxis2;\n  }()\n);\nvar TempPolygon = (\n  /** @class */\n  /* @__PURE__ */ function() {\n    function TempPolygon2() {\n      this.vertices = [];\n      this.normals = [];\n      this.count = 0;\n      for (var i = 0; i < SettingsInternal.maxPolygonVertices; i++) {\n        this.vertices.push(vec2(0, 0));\n        this.normals.push(vec2(0, 0));\n      }\n    }\n    return TempPolygon2;\n  }()\n);\nvar ReferenceFace = (\n  /** @class */\n  function() {\n    function ReferenceFace2() {\n      this.v1 = vec2(0, 0);\n      this.v2 = vec2(0, 0);\n      this.normal = vec2(0, 0);\n      this.sideNormal1 = vec2(0, 0);\n      this.sideNormal2 = vec2(0, 0);\n    }\n    ReferenceFace2.prototype.recycle = function() {\n      zeroVec2(this.v1);\n      zeroVec2(this.v2);\n      zeroVec2(this.normal);\n      zeroVec2(this.sideNormal1);\n      zeroVec2(this.sideNormal2);\n    };\n    return ReferenceFace2;\n  }()\n);\nvar clipPoints1 = [new ClipVertex(), new ClipVertex()];\nvar clipPoints2 = [new ClipVertex(), new ClipVertex()];\nvar ie = [new ClipVertex(), new ClipVertex()];\nvar edgeAxis = new EPAxis();\nvar polygonAxis = new EPAxis();\nvar polygonBA = new TempPolygon();\nvar rf = new ReferenceFace();\nvar centroidB = vec2(0, 0);\nvar edge0 = vec2(0, 0);\nvar edge1 = vec2(0, 0);\nvar edge2 = vec2(0, 0);\nvar xf = transform(0, 0, 0);\nvar normal = vec2(0, 0);\nvar normal0 = vec2(0, 0);\nvar normal1 = vec2(0, 0);\nvar normal2 = vec2(0, 0);\nvar lowerLimit = vec2(0, 0);\nvar upperLimit = vec2(0, 0);\nvar perp = vec2(0, 0);\nvar n = vec2(0, 0);\nvar CollideEdgePolygon = function(manifold, edgeA, xfA2, polygonB, xfB2) {\n  detransformTransform(xf, xfA2, xfB2);\n  transformVec2(centroidB, xf, polygonB.m_centroid);\n  var v0 = edgeA.m_vertex0;\n  var v13 = edgeA.m_vertex1;\n  var v22 = edgeA.m_vertex2;\n  var v3 = edgeA.m_vertex3;\n  var hasVertex0 = edgeA.m_hasVertex0;\n  var hasVertex3 = edgeA.m_hasVertex3;\n  subVec2(edge1, v22, v13);\n  normalizeVec2(edge1);\n  setVec2(normal1, edge1.y, -edge1.x);\n  var offset1 = dotVec2(normal1, centroidB) - dotVec2(normal1, v13);\n  var offset0 = 0;\n  var offset2 = 0;\n  var convex1 = false;\n  var convex2 = false;\n  zeroVec2(normal0);\n  zeroVec2(normal2);\n  if (hasVertex0) {\n    subVec2(edge0, v13, v0);\n    normalizeVec2(edge0);\n    setVec2(normal0, edge0.y, -edge0.x);\n    convex1 = crossVec2Vec2(edge0, edge1) >= 0;\n    offset0 = Vec2.dot(normal0, centroidB) - Vec2.dot(normal0, v0);\n  }\n  if (hasVertex3) {\n    subVec2(edge2, v3, v22);\n    normalizeVec2(edge2);\n    setVec2(normal2, edge2.y, -edge2.x);\n    convex2 = Vec2.crossVec2Vec2(edge1, edge2) > 0;\n    offset2 = Vec2.dot(normal2, centroidB) - Vec2.dot(normal2, v22);\n  }\n  var front;\n  zeroVec2(normal);\n  zeroVec2(lowerLimit);\n  zeroVec2(upperLimit);\n  if (hasVertex0 && hasVertex3) {\n    if (convex1 && convex2) {\n      front = offset0 >= 0 || offset1 >= 0 || offset2 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal0);\n        copyVec2(upperLimit, normal2);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        scaleVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex1) {\n      front = offset0 >= 0 || offset1 >= 0 && offset2 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal0);\n        copyVec2(upperLimit, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal2);\n        scaleVec2(upperLimit, -1, normal1);\n      }\n    } else if (convex2) {\n      front = offset2 >= 0 || offset0 >= 0 && offset1 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal1);\n        copyVec2(upperLimit, normal2);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        scaleVec2(upperLimit, -1, normal0);\n      }\n    } else {\n      front = offset0 >= 0 && offset1 >= 0 && offset2 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal1);\n        copyVec2(upperLimit, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal2);\n        scaleVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex0) {\n    if (convex1) {\n      front = offset0 >= 0 || offset1 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal0);\n        scaleVec2(upperLimit, -1, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        copyVec2(lowerLimit, normal1);\n        scaleVec2(upperLimit, -1, normal1);\n      }\n    } else {\n      front = offset0 >= 0 && offset1 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        copyVec2(lowerLimit, normal1);\n        scaleVec2(upperLimit, -1, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        copyVec2(lowerLimit, normal1);\n        scaleVec2(upperLimit, -1, normal0);\n      }\n    }\n  } else if (hasVertex3) {\n    if (convex2) {\n      front = offset1 >= 0 || offset2 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        copyVec2(upperLimit, normal2);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        copyVec2(upperLimit, normal1);\n      }\n    } else {\n      front = offset1 >= 0 && offset2 >= 0;\n      if (front) {\n        copyVec2(normal, normal1);\n        scaleVec2(lowerLimit, -1, normal1);\n        copyVec2(upperLimit, normal1);\n      } else {\n        scaleVec2(normal, -1, normal1);\n        scaleVec2(lowerLimit, -1, normal2);\n        copyVec2(upperLimit, normal1);\n      }\n    }\n  } else {\n    front = offset1 >= 0;\n    if (front) {\n      copyVec2(normal, normal1);\n      scaleVec2(lowerLimit, -1, normal1);\n      scaleVec2(upperLimit, -1, normal1);\n    } else {\n      scaleVec2(normal, -1, normal1);\n      copyVec2(lowerLimit, normal1);\n      copyVec2(upperLimit, normal1);\n    }\n  }\n  polygonBA.count = polygonB.m_count;\n  for (var i = 0; i < polygonB.m_count; ++i) {\n    transformVec2(polygonBA.vertices[i], xf, polygonB.m_vertices[i]);\n    rotVec2(polygonBA.normals[i], xf.q, polygonB.m_normals[i]);\n  }\n  var radius = polygonB.m_radius + edgeA.m_radius;\n  manifold.pointCount = 0;\n  {\n    edgeAxis.type = EPAxisType.e_edgeA;\n    edgeAxis.index = front ? 0 : 1;\n    edgeAxis.separation = Infinity;\n    for (var i = 0; i < polygonBA.count; ++i) {\n      var v4 = polygonBA.vertices[i];\n      var s2 = dotVec2(normal, v4) - dotVec2(normal, v13);\n      if (s2 < edgeAxis.separation) {\n        edgeAxis.separation = s2;\n      }\n    }\n  }\n  if (edgeAxis.type == EPAxisType.e_unknown) {\n    return;\n  }\n  if (edgeAxis.separation > radius) {\n    return;\n  }\n  {\n    polygonAxis.type = EPAxisType.e_unknown;\n    polygonAxis.index = -1;\n    polygonAxis.separation = -Infinity;\n    setVec2(perp, -normal.y, normal.x);\n    for (var i = 0; i < polygonBA.count; ++i) {\n      scaleVec2(n, -1, polygonBA.normals[i]);\n      var s1 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v13);\n      var s22 = dotVec2(n, polygonBA.vertices[i]) - dotVec2(n, v22);\n      var s2 = math_min(s1, s22);\n      if (s2 > radius) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s2;\n        break;\n      }\n      if (dotVec2(n, perp) >= 0) {\n        if (dotVec2(n, normal) - dotVec2(upperLimit, normal) < -SettingsInternal.angularSlop) {\n          continue;\n        }\n      } else {\n        if (dotVec2(n, normal) - dotVec2(lowerLimit, normal) < -SettingsInternal.angularSlop) {\n          continue;\n        }\n      }\n      if (s2 > polygonAxis.separation) {\n        polygonAxis.type = EPAxisType.e_edgeB;\n        polygonAxis.index = i;\n        polygonAxis.separation = s2;\n      }\n    }\n  }\n  if (polygonAxis.type != EPAxisType.e_unknown && polygonAxis.separation > radius) {\n    return;\n  }\n  var k_relativeTol = 0.98;\n  var k_absoluteTol = 1e-3;\n  var primaryAxis;\n  if (polygonAxis.type == EPAxisType.e_unknown) {\n    primaryAxis = edgeAxis;\n  } else if (polygonAxis.separation > k_relativeTol * edgeAxis.separation + k_absoluteTol) {\n    primaryAxis = polygonAxis;\n  } else {\n    primaryAxis = edgeAxis;\n  }\n  ie[0].recycle();\n  ie[1].recycle();\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    manifold.type = ManifoldType.e_faceA;\n    var bestIndex = 0;\n    var bestValue = dotVec2(normal, polygonBA.normals[0]);\n    for (var i = 1; i < polygonBA.count; ++i) {\n      var value = dotVec2(normal, polygonBA.normals[i]);\n      if (value < bestValue) {\n        bestValue = value;\n        bestIndex = i;\n      }\n    }\n    var i1 = bestIndex;\n    var i2 = i1 + 1 < polygonBA.count ? i1 + 1 : 0;\n    copyVec2(ie[0].v, polygonBA.vertices[i1]);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_face, i1, ContactFeatureType.e_vertex);\n    copyVec2(ie[1].v, polygonBA.vertices[i2]);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_face, i2, ContactFeatureType.e_vertex);\n    if (front) {\n      rf.i1 = 0;\n      rf.i2 = 1;\n      copyVec2(rf.v1, v13);\n      copyVec2(rf.v2, v22);\n      copyVec2(rf.normal, normal1);\n    } else {\n      rf.i1 = 1;\n      rf.i2 = 0;\n      copyVec2(rf.v1, v22);\n      copyVec2(rf.v2, v13);\n      scaleVec2(rf.normal, -1, normal1);\n    }\n  } else {\n    manifold.type = ManifoldType.e_faceB;\n    copyVec2(ie[0].v, v13);\n    ie[0].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n    copyVec2(ie[1].v, v22);\n    ie[1].id.setFeatures(0, ContactFeatureType.e_vertex, primaryAxis.index, ContactFeatureType.e_face);\n    rf.i1 = primaryAxis.index;\n    rf.i2 = rf.i1 + 1 < polygonBA.count ? rf.i1 + 1 : 0;\n    copyVec2(rf.v1, polygonBA.vertices[rf.i1]);\n    copyVec2(rf.v2, polygonBA.vertices[rf.i2]);\n    copyVec2(rf.normal, polygonBA.normals[rf.i1]);\n  }\n  setVec2(rf.sideNormal1, rf.normal.y, -rf.normal.x);\n  setVec2(rf.sideNormal2, -rf.sideNormal1.x, -rf.sideNormal1.y);\n  rf.sideOffset1 = dotVec2(rf.sideNormal1, rf.v1);\n  rf.sideOffset2 = dotVec2(rf.sideNormal2, rf.v2);\n  clipPoints1[0].recycle();\n  clipPoints1[1].recycle();\n  clipPoints2[0].recycle();\n  clipPoints2[1].recycle();\n  var np1 = clipSegmentToLine(clipPoints1, ie, rf.sideNormal1, rf.sideOffset1, rf.i1);\n  if (np1 < SettingsInternal.maxManifoldPoints) {\n    return;\n  }\n  var np2 = clipSegmentToLine(clipPoints2, clipPoints1, rf.sideNormal2, rf.sideOffset2, rf.i2);\n  if (np2 < SettingsInternal.maxManifoldPoints) {\n    return;\n  }\n  if (primaryAxis.type == EPAxisType.e_edgeA) {\n    copyVec2(manifold.localNormal, rf.normal);\n    copyVec2(manifold.localPoint, rf.v1);\n  } else {\n    copyVec2(manifold.localNormal, polygonB.m_normals[rf.i1]);\n    copyVec2(manifold.localPoint, polygonB.m_vertices[rf.i1]);\n  }\n  var pointCount = 0;\n  for (var i = 0; i < SettingsInternal.maxManifoldPoints; ++i) {\n    var separation = dotVec2(rf.normal, clipPoints2[i].v) - dotVec2(rf.normal, rf.v1);\n    if (separation <= radius) {\n      var cp = manifold.points[pointCount];\n      if (primaryAxis.type == EPAxisType.e_edgeA) {\n        detransformVec2(cp.localPoint, xf, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n      } else {\n        copyVec2(cp.localPoint, clipPoints2[i].v);\n        cp.id.set(clipPoints2[i].id);\n        cp.id.swapFeatures();\n      }\n      ++pointCount;\n    }\n  }\n  manifold.pointCount = pointCount;\n};\nvar internal = {\n  CollidePolygons,\n  Settings,\n  Sweep,\n  Manifold,\n  Distance,\n  TimeOfImpact,\n  DynamicTree,\n  stats\n};\nvar DataDriver = (\n  /** @class */\n  function() {\n    function DataDriver2(key, listener) {\n      this._refMap = {};\n      this._map = {};\n      this._xmap = {};\n      this._data = [];\n      this._entered = [];\n      this._exited = [];\n      this._key = key;\n      this._listener = listener;\n    }\n    DataDriver2.prototype.update = function(data) {\n      if (!Array.isArray(data))\n        throw \"Invalid data: \" + data;\n      this._entered.length = 0;\n      this._exited.length = 0;\n      this._data.length = data.length;\n      for (var i = 0; i < data.length; i++) {\n        if (typeof data[i] !== \"object\" || data[i] === null)\n          continue;\n        var d2 = data[i];\n        var id = this._key(d2);\n        if (!this._map[id]) {\n          this._entered.push(d2);\n        } else {\n          delete this._map[id];\n        }\n        this._data[i] = d2;\n        this._xmap[id] = d2;\n      }\n      for (var id in this._map) {\n        this._exited.push(this._map[id]);\n        delete this._map[id];\n      }\n      var temp3 = this._map;\n      this._map = this._xmap;\n      this._xmap = temp3;\n      for (var i = 0; i < this._exited.length; i++) {\n        var d2 = this._exited[i];\n        var key = this._key(d2);\n        var ref = this._refMap[key];\n        this._listener.exit(d2, ref);\n        delete this._refMap[key];\n      }\n      for (var i = 0; i < this._entered.length; i++) {\n        var d2 = this._entered[i];\n        var key = this._key(d2);\n        var ref = this._listener.enter(d2);\n        if (ref) {\n          this._refMap[key] = ref;\n        }\n      }\n      for (var i = 0; i < this._data.length; i++) {\n        if (typeof data[i] !== \"object\" || data[i] === null)\n          continue;\n        var d2 = this._data[i];\n        var key = this._key(d2);\n        var ref = this._refMap[key];\n        this._listener.update(d2, ref);\n      }\n      this._entered.length = 0;\n      this._exited.length = 0;\n      this._data.length = 0;\n    };\n    DataDriver2.prototype.ref = function(d2) {\n      return this._refMap[this._key(d2)];\n    };\n    return DataDriver2;\n  }()\n);\nconst planck = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  AABB,\n  Body,\n  Box,\n  BoxShape,\n  BroadPhase,\n  Chain,\n  ChainShape,\n  Circle,\n  CircleShape,\n  ClipVertex,\n  CollideCircles,\n  CollideEdgeCircle,\n  CollideEdgePolygon,\n  CollidePolygonCircle,\n  CollidePolygons,\n  Contact,\n  ContactEdge,\n  get ContactFeatureType() {\n    return ContactFeatureType;\n  },\n  ContactID,\n  ContactImpulse,\n  DataDriver,\n  Distance,\n  DistanceInput,\n  DistanceJoint,\n  DistanceOutput,\n  DistanceProxy,\n  DynamicTree,\n  Edge,\n  EdgeShape,\n  Fixture,\n  FixtureProxy,\n  FrictionJoint,\n  GearJoint,\n  Joint,\n  JointEdge,\n  Manifold,\n  ManifoldPoint,\n  get ManifoldType() {\n    return ManifoldType;\n  },\n  Mat22,\n  Mat33,\n  Math: math,\n  MotorJoint,\n  MouseJoint,\n  get PointState() {\n    return PointState;\n  },\n  Polygon,\n  PolygonShape,\n  PrismaticJoint,\n  PulleyJoint,\n  RevoluteJoint,\n  RopeJoint,\n  Rot,\n  Serializer,\n  Settings,\n  SettingsInternal,\n  Shape,\n  ShapeCast,\n  ShapeCastInput,\n  ShapeCastOutput,\n  SimplexCache,\n  Solver,\n  Sweep,\n  TOIInput,\n  TOIOutput,\n  get TOIOutputState() {\n    return TOIOutputState;\n  },\n  Testbed,\n  TimeOfImpact,\n  TimeStep,\n  Transform,\n  TreeNode,\n  Vec2,\n  Vec3,\n  VelocityConstraintPoint,\n  WeldJoint,\n  WheelJoint,\n  World,\n  WorldManifold,\n  clipSegmentToLine,\n  getPointStates,\n  internal,\n  mixFriction,\n  mixRestitution,\n  stats,\n  testOverlap,\n  testbed\n}, Symbol.toStringTag, { value: \"Module\" }));\n\n//# sourceMappingURL=planck.mjs.map\n\n\n//# sourceURL=webpack://gameengine/./node_modules/planck-js/dist/planck.mjs?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({ randomUUID });\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/native.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/regex.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rng)\n/* harmony export */ });\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/rng.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   unsafeStringify: () => (/* binding */ unsafeStringify)\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nfunction unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringify);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/stringify.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n    if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n        return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? (0,_rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (v4);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/v4.js?");

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\nfunction validate(uuid) {\n    return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (validate);\n\n\n//# sourceURL=webpack://gameengine/./node_modules/uuid/dist/esm-browser/validate.js?");

/***/ }),

/***/ "./src/Components/Body.ts":
/*!********************************!*\
  !*** ./src/Components/Body.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BodyC: () => (/* binding */ BodyC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! planck-js */ \"./node_modules/planck-js/dist/planck.mjs\");\n/* harmony import */ var _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Plugins/Physics */ \"./src/Plugins/Physics.ts\");\n\n\n\n\nclass BodyC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    body;\n    bodyDef = {\n        type: 'dynamic',\n        position: new planck_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(0, 0),\n        linearVelocity: new planck_js__WEBPACK_IMPORTED_MODULE_3__.Vec2(0, 0),\n        linearDamping: 0,\n        angle: 0,\n        angularVelocity: 0,\n        angularDamping: 0.2,\n        fixedRotation: false,\n        bullet: false,\n        allowSleep: true,\n    };\n    force = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    // public readonly type: pl.BodyType = pl.Body.Dynamic;\n    constructor(dampingFactor = 0.45) {\n        super();\n        this.setDamping(dampingFactor);\n    }\n    spawn() {\n        console.log(\"BodyC spawned\");\n        this.body = this.getPlugin(_Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsPlugin).getWorld().createBody(this.bodyDef);\n    }\n    destroy() {\n        console.log(\"BodyC destroyed\");\n        this.getPlugin(_Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsPlugin)?.getWorld().destroyBody(this.body);\n    }\n    update(delta) {\n        this.body.applyForceToCenter(this.force); // = this.body;\n    }\n    getPlBody() {\n        if (this.body)\n            return this.body;\n        else\n            throw new Error(\"BodyC: Body is not created yet. Use spawn() method to create it.\");\n    }\n    //set parameters\n    setPosition(position) {\n        if (this.body)\n            this.body.setPosition(position);\n        else\n            this.bodyDef.position = position;\n    }\n    getPosition() {\n        return _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.fromVec2(this.body.getPosition()) ?? this.bodyDef.position ?? new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    }\n    setRotation(rotation) {\n        if (this.body)\n            this.body.setAngle(rotation);\n        else\n            this.bodyDef.angle = rotation;\n    }\n    getRotation() {\n        return this.body.getAngle() ?? this.bodyDef.angle ?? 0;\n    }\n    setVelocity(velocity) {\n        if (this.body)\n            this.body.setLinearVelocity(velocity);\n        else\n            this.bodyDef.linearVelocity = velocity;\n    }\n    getVelocity() {\n        return _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.fromVec2(this.body.getLinearVelocity()) ?? this.bodyDef.linearVelocity ?? new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 0);\n    }\n    setAngularVelocity(angularVelocity) {\n        if (this.body)\n            this.body.setAngularVelocity(angularVelocity);\n        else\n            this.bodyDef.angularVelocity = angularVelocity;\n    }\n    getAngularVelocity() {\n        return this.body.getAngularVelocity() ?? this.bodyDef.angularVelocity ?? 0;\n    }\n    setAngularDamping(angularDamping) {\n        if (this.body)\n            this.body.setAngularDamping(angularDamping);\n        else\n            this.bodyDef.angularDamping = angularDamping;\n    }\n    getAngularDamping() {\n        return this.body.getAngularDamping() ?? this.bodyDef.angularDamping ?? 0;\n    }\n    setDamping(linearDamping) {\n        if (this.body)\n            this.body.setLinearDamping(linearDamping);\n        else\n            this.bodyDef.linearDamping = linearDamping;\n    }\n    getDamping() {\n        return this.body.getLinearDamping() ?? this.bodyDef.linearDamping ?? 0;\n    }\n    setFixedRotation(fixedRotation) {\n        if (this.body)\n            this.body.setFixedRotation(fixedRotation);\n        else\n            this.bodyDef.fixedRotation = fixedRotation;\n    }\n    getFixedRotation() {\n        return this.body.isFixedRotation() ?? this.bodyDef.fixedRotation ?? false;\n    }\n    setBullet(bullet) {\n        if (this.body)\n            this.body.setBullet(bullet);\n        else\n            this.bodyDef.bullet = bullet;\n    }\n    getBullet() {\n        return this.body.isBullet() ?? this.bodyDef.bullet ?? false;\n    }\n    setAllowSleep(allowSleep) {\n        if (this.body)\n            this.body.setSleepingAllowed(allowSleep);\n        else\n            this.bodyDef.allowSleep = allowSleep;\n    }\n    getAllowSleep() {\n        return this.body.isSleepingAllowed() ?? this.bodyDef.allowSleep ?? false;\n    }\n    //forces\n    setForce(force) {\n        this.force = force;\n    }\n    getForce() {\n        return this.force;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Body.ts?");

/***/ }),

/***/ "./src/Components/Collider.ts":
/*!************************************!*\
  !*** ./src/Components/Collider.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderC: () => (/* binding */ ColliderC),\n/* harmony export */   CollisionEventArgs: () => (/* binding */ CollisionEventArgs)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Body */ \"./src/Components/Body.ts\");\n/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! planck-js */ \"./node_modules/planck-js/dist/planck.mjs\");\n\n\n\n\n\nclass CollisionEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.EventArgs {\n    collider;\n    constructor(collider) {\n        super();\n        this.collider = collider;\n    }\n}\nclass ColliderC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    offset = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.zero();\n    radius;\n    isActive = false;\n    isStatic;\n    // public layer: number;\n    avoidObjectes;\n    collisions = new Set();\n    onCollisionEnterEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.GameEvent();\n    onCollisionExitEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.GameEvent();\n    constructor(radius = 1, isStatic = true, ...avoidObjectes) {\n        super();\n        this.radius = radius;\n        this.isStatic = isStatic;\n        this.avoidObjectes = new Set();\n        avoidObjectes.forEach(ao => this.avoidObjectes.add(ao));\n    }\n    start() {\n        this.onCollisionEnterEvent.register(this.getGameWorld());\n        this.onCollisionExitEvent.register(this.getGameWorld());\n        this.getComponent(_Body__WEBPACK_IMPORTED_MODULE_3__.BodyC).getPlBody().createFixture(new planck_js__WEBPACK_IMPORTED_MODULE_4__.Circle(this.radius), { density: 1.0 });\n    }\n    getCenter() {\n        return this.getComponent(_Body__WEBPACK_IMPORTED_MODULE_3__.BodyC).getPosition().add(this.offset);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Collider.ts?");

/***/ }),

/***/ "./src/Components/Health.ts":
/*!**********************************!*\
  !*** ./src/Components/Health.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DamageEventArgs: () => (/* binding */ DamageEventArgs),\n/* harmony export */   HealthC: () => (/* binding */ HealthC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n\n\nclass DamageEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.EventArgs {\n    damage;\n    participant;\n    constructor(damage, participant) {\n        super();\n        this.damage = damage;\n        this.participant = participant;\n    }\n}\nclass HealthC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    health;\n    maxHealth;\n    damageEvent;\n    constructor(maxHealth, health = maxHealth) {\n        super();\n        this.health = health;\n        this.maxHealth = maxHealth;\n        this.damageEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_1__.GameEvent();\n    }\n    start() {\n        this.damageEvent.register(this.gameObject?.manager?.gameWorld);\n        // this.getComponent(ColliderC).onCollisionEnterEvent.subscribe(this, \"onCollisionEnter\");\n    }\n    event(args) {\n        // let cargs = args as CollisionEventArgs;\n        // this.onCollisionEnter(cargs.collider);\n    }\n    // onCollisionEnter(other: ColliderC): void { \n    //     let otherGO = other.getGameObject();       \n    //     let otherRigidbody = otherGO.getComponent(RigidBodyC);\n    //     let thisRigidbody = this.getComponent(RigidBodyC);\n    //     let op = thisRigidbody.mass/(otherRigidbody.mass+thisRigidbody.mass);\n    //     if(thisRigidbody.mass<otherRigidbody.mass){\n    //         otherRigidbody.velocity = otherRigidbody.velocity.add(thisRigidbody.velocity.times(op)).times(0.5); //toUnit().times(v2);\n    //         thisRigidbody.velocity = thisRigidbody.velocity.add(otherRigidbody.velocity.times(1-op).times(0.5)); //toUnit().times(v2);\n    //     }\n    //     otherRigidbody.angularVelocity += this.getTransform().position.sub(otherGO.getTransform().position).vectorProduct(thisRigidbody.velocity)*(op/15);\n    //     try{\n    //         const other = otherGO.getComponent(HealthC);\n    //         const damageValue = Math.min(other.health, this.health);\n    //         if (damageValue==0)\n    //             return;\n    //         this.onDamage(damageValue, other);\n    //         other.onDamage(damageValue, this);            \n    //     }\n    //     catch {}\n    // }\n    getHealth() {\n        return this.health / this.maxHealth;\n    }\n    heal(value) {\n        this.health = Math.min(this.maxHealth, this.health + value);\n    }\n    onDamage(value, participant) {\n        this.health -= value;\n        this.damageEvent.emit(new DamageEventArgs(value, participant));\n        // if(this.health==0){\n        //     this.getComponent(ColliderC)?.enable(false);\n        //     this.getComponent(RigidBodyC).dampingFactor=0.6;\n        //     this.getComponent(AnimationC)?.startShrink();\n        //     if(participant.hasComponent(PolygonRendererC)){\n        //         let myColor = this.getComponent(PolygonRendererC).color;\n        //         let newColor = myColor.blend(\n        //             participant.getComponent(PolygonRendererC).color.toRgb(),\n        //             0.5\n        //         ).toRgb();\n        //         this.getComponent(PolygonRendererC).color = newColor;\n        //         participant.getComponent(PolygonRendererC).color = newColor;\n        //     }\n        // }\n        // else\n        //     this.getComponent(AnimationC)?.startZoom();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Health.ts?");

/***/ }),

/***/ "./src/Components/Renderers/BarRenderer.ts":
/*!*************************************************!*\
  !*** ./src/Components/Renderers/BarRenderer.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BarRendererC: () => (/* binding */ BarRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n/* harmony import */ var _Health__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Health */ \"./src/Components/Health.ts\");\n\n\n\n\n\nclass BarRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    offset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(0, 4);\n    fill = 0.5;\n    width = 5;\n    height = 0.5;\n    constructor(zindex = 0) {\n        super(zindex);\n    }\n    //  const offset = this.getPlugin(CameraPlugin)!.cameraScreenOffset;\n    //         const x = ;\n    //         const y = this.gameObject!.getBody()!.getPosition().y;\n    //         const r = this.gameObject!.getBody()!.getPosition().x;\n    //         const transformScale = Vector.one();//this.getTransform().scale;\n    //         const scale = this.getPlugin(CameraPlugin)!.scaleV;\n    //         const cmx = this.getPlugin(CameraPlugin)!.cameraPositon.x;\n    //         const cmy = this.getPlugin(CameraPlugin)!.cameraPositon.y;\n    //         const color = this.color.toString();\n    //         const cx: number = (x-cmx);\n    //         const cy: number = (y-cmy);\n    render(context) {\n        let width = this.width;\n        let fill = this.fill;\n        try {\n            fill = this.getComponent(_Health__WEBPACK_IMPORTED_MODULE_4__.HealthC).getHealth();\n            width = 2 + this.getComponent(_Health__WEBPACK_IMPORTED_MODULE_4__.HealthC).maxHealth / 250.0;\n        }\n        catch { }\n        if (fill >= 1 || fill <= 0)\n            return;\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //this.getTransform().scale;\n        const scale = camera.scaleV;\n        const offset = camera.cameraScreenOffset;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.getHeatmapColor(fill).toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        const radius = 0.25;\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        // context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.translate(this.offset.x, this.offset.y);\n        context.fillStyle = color;\n        context.shadowBlur = 0;\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width, this.height, radius);\n        context.closePath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.fill();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width * fill, this.height, radius);\n        context.closePath();\n        context.fillStyle = color;\n        context.fill();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width, this.height, radius);\n        context.closePath();\n        context.shadowBlur = 30;\n        context.stroke();\n        context.beginPath();\n        context.roundRect(-width / 2, -this.height / 2, width * fill, this.height, radius);\n        context.closePath();\n        context.shadowBlur = 0;\n        context.stroke();\n        context.setTransform(1, 0, 0, 1, 0, 0);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/BarRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/ChasisRenderer.ts":
/*!****************************************************!*\
  !*** ./src/Components/Renderers/ChasisRenderer.ts ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ChasisRendererC: () => (/* binding */ ChasisRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n\n\n\n\n\nclass ChasisRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_4__.RendererC {\n    color;\n    constructor(zindex = 0, color = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(22, 24, 25)) {\n        super();\n        this.zindex = zindex;\n        this.color = color;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //body.getScale();\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = x - cmx;\n        const cy = y - cmy;\n        // context.save();\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.beginPath();\n        context.fillStyle = this.getComponent(_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__.PolygonRendererC).color.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-4, -2, 8, 4, 1);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-4.5, -3.25, 10, 2, 0.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.shadowBlur = 0;\n        context.roundRect(-4.5, 1.25, 10, 2, 0.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.beginPath();\n        context.fillStyle = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.background.toString();\n        context.shadowBlur = 0;\n        context.roundRect(-3, -2, 6, 4, 1.5);\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.closePath();\n        context.shadowBlur = 0;\n        ;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/ChasisRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/ColliderRenderer.ts":
/*!******************************************************!*\
  !*** ./src/Components/Renderers/ColliderRenderer.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ColliderRendererC: () => (/* binding */ ColliderRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Plugins_Config__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Body__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Body */ \"./src/Components/Body.ts\");\n/* harmony import */ var _Collider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Collider */ \"./src/Components/Collider.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n\n\n\n\n\n\nclass ColliderRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_5__.RendererC {\n    activeColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(172, 42, 55, 0.125);\n    staticColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(95, 64, 36, 0.125);\n    dynamicColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(57, 127, 31, 0.125);\n    disabledColor = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(36, 24, 36, 0.125);\n    constructor(zindex = -1) {\n        super();\n        this.zindex = zindex;\n    }\n    getColor() {\n        let color = this.dynamicColor;\n        let collider = this.getComponent(_Collider__WEBPACK_IMPORTED_MODULE_4__.ColliderC);\n        if (!collider.enabled)\n            color = this.disabledColor;\n        else if (collider.isActive)\n            color = this.activeColor;\n        else if (collider.isStatic)\n            color = this.staticColor;\n        return color;\n    }\n    render(context) {\n        let display = this.getPlugin(_Plugins_Config__WEBPACK_IMPORTED_MODULE_2__.ConfigPlugin)?.get(\"displayColliders\") ?? false;\n        if (!display)\n            return;\n        const collider = this.getComponent(_Collider__WEBPACK_IMPORTED_MODULE_4__.ColliderC);\n        const colliderOffset = collider.offset;\n        const radius = collider.radius;\n        const radius2 = collider.radius + 0.25;\n        const color = this.getColor();\n        const offset = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__.CameraPlugin).cameraScreenOffset;\n        const x = this.getComponent(_Body__WEBPACK_IMPORTED_MODULE_3__.BodyC).getPosition().x + colliderOffset.x;\n        const y = this.getComponent(_Body__WEBPACK_IMPORTED_MODULE_3__.BodyC).getPosition().y + colliderOffset.y;\n        const r = this.getComponent(_Body__WEBPACK_IMPORTED_MODULE_3__.BodyC).getRotation();\n        const scale = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__.CameraPlugin).scaleV;\n        const cmx = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__.CameraPlugin).cameraPosition.x;\n        const cmy = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_1__.CameraPlugin).cameraPosition.y;\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        context.save();\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.strokeStyle = color.toRgb().toString();\n        context.fillStyle = color.toString();\n        context.shadowBlur = 30;\n        context.beginPath();\n        context.arc(0, 0, radius2, 0, 2 * Math.PI);\n        context.closePath();\n        context.fill();\n        context.stroke();\n        context.beginPath();\n        context.arc(0, 0, radius, 0, 2 * Math.PI);\n        context.closePath();\n        context.lineWidth = 0.1;\n        context.stroke();\n        // context.setTransform(1, 0, 0, 1, 0, 0);\n        context.restore();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/ColliderRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/PolygonRenderer.ts":
/*!*****************************************************!*\
  !*** ./src/Components/Renderers/PolygonRenderer.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PolygonRendererC: () => (/* binding */ PolygonRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n\n\n\n\nclass PolygonRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    color;\n    radius;\n    n;\n    constructor(side, n = 4, zindex = 0, color = _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.randomColor2()) {\n        super();\n        this.radius = side;\n        this.n = n;\n        this.zindex = zindex;\n        this.color = color;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector.one(); //this.getTransform().scale;\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        // context.save();\n        // const sin = Math.sin(r);\n        // const cos = Math.cos(r);\n        // const sx = scale.x * transformScale.x;\n        // const sy = scale.y * transformScale.y;\n        // const a2 = cos * sx;\n        // const b = sin * sx;\n        // const c = -sin * sy;\n        // const d = cos * sy;\n        // const e = offset.x + scale.x * (cx * cos - cy * sin);\n        // const f = offset.y + scale.y * (cx * sin + cy * cos);\n        // // Ustaw bezpośrednio macierz transformacji\n        // context.setTransform(a2, b, c, d, e, f);\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        const a = this.radius;\n        if (this.n < 10) {\n            context.beginPath();\n            context.moveTo(0, a);\n            const angle = (2 * Math.PI) / this.n;\n            for (let i = 1; i < this.n; i++) {\n                context.lineTo(Math.sin(i * angle) * a, Math.cos(i * angle) * a);\n            }\n            context.closePath();\n        }\n        else {\n            context.beginPath();\n            context.arc(0, 0, a, 0, 2 * Math.PI);\n            context.closePath();\n        }\n        context.fillStyle = color;\n        context.shadowBlur = 0;\n        context.fill();\n        context.shadowBlur = 50;\n        context.stroke();\n        context.shadowBlur = 0;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/PolygonRenderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/Renderer.ts":
/*!**********************************************!*\
  !*** ./src/Components/Renderers/Renderer.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RendererC: () => (/* binding */ RendererC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Component */ \"./src/Core/Component.ts\");\n\nclass RendererC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    zindex;\n    constructor(zindex = 0) {\n        super();\n        this.zindex = zindex;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/Renderer.ts?");

/***/ }),

/***/ "./src/Components/Renderers/TextRenderer.ts":
/*!**************************************************!*\
  !*** ./src/Components/Renderers/TextRenderer.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextRendererC: () => (/* binding */ TextRendererC)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Renderer */ \"./src/Components/Renderers/Renderer.ts\");\n\n\n\n\nclass TextRendererC extends _Renderer__WEBPACK_IMPORTED_MODULE_3__.RendererC {\n    color = new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(42, 42, 55);\n    text;\n    displayName;\n    constructor(text, displayName = false, zindex = 1) {\n        super();\n        this.text = text;\n        this.zindex = zindex;\n        this.displayName = displayName;\n    }\n    render(context) {\n        const camera = this.getPlugin(_Plugins_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin);\n        const body = this.gameObject.getBody();\n        const offset = camera.cameraScreenOffset;\n        const x = body.getPosition().x;\n        const y = body.getPosition().y;\n        const r = body.getRotation();\n        const transformScale = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_1__.Vector(1, 1); //body.getScale();\n        const scale = camera.scaleV;\n        const cmx = camera.cameraPosition.x;\n        const cmy = camera.cameraPosition.y;\n        const color = this.color.toString();\n        const cx = (x - cmx);\n        const cy = (y - cmy);\n        // context.save();\n        context.fillStyle = color;\n        context.translate(offset.x, offset.y);\n        context.scale(scale.x, scale.y);\n        context.translate(cx, cy);\n        // context.rotate(r);\n        context.scale(transformScale.x, transformScale.y);\n        context.scale(1, -1);\n        // context.fillRect(-a, -a, 2*a, 2*a);\n        // context.shadowBlur = 30;\n        // context.strokeRect(-a, -a, 2*a, 2*a);\n        const text = this.displayName ? this.gameObject.name : this.text;\n        const textHeight = 1.0;\n        context.font = \"bold \" + textHeight + \"px Arial\";\n        context.fillStyle = \"azure\";\n        context.shadowBlur = 10;\n        const textOffset = context.measureText(text).width / 2;\n        context.strokeText(text, -textOffset, textHeight / 4);\n        context.fillText(text, -textOffset, textHeight / 4);\n        context.shadowBlur = 0;\n        context.setTransform(1, 0, 0, 1, 0, 0);\n        // context.restore();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Renderers/TextRenderer.ts?");

/***/ }),

/***/ "./src/Components/Tags.ts":
/*!********************************!*\
  !*** ./src/Components/Tags.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TagsC: () => (/* binding */ TagsC)\n/* harmony export */ });\n/* harmony import */ var _Core_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Component */ \"./src/Core/Component.ts\");\n\nclass TagsC extends _Core_Component__WEBPACK_IMPORTED_MODULE_0__.Component {\n    tags = new Set();\n    constructor(...tags) {\n        super();\n        tags.forEach(tag => this.addTag(tag));\n    }\n    addTag(tag) {\n        this.tags.add(tag);\n    }\n    removeTag(tag) {\n        this.tags.delete(tag);\n    }\n    hasTag(tag) {\n        return this.tags.has(tag);\n    }\n    getTags() {\n        return Array.from(this.tags);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Components/Tags.ts?");

/***/ }),

/***/ "./src/Core/Component.ts":
/*!*******************************!*\
  !*** ./src/Core/Component.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Component: () => (/* binding */ Component)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n\n// import { BodyC } from \"../Components/Body\";\nclass Component {\n    enabled = true;\n    id = (0,uuid__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n    gameObject;\n    //overideable methods\n    spawn() { }\n    start() { }\n    event(args, alias) { }\n    destroy() { }\n    getComponent(classC) {\n        return this.gameObject?.getComponent(classC);\n    }\n    getAllComponents() {\n        return this.gameObject?.getAllComponents() ?? [];\n    }\n    getPlugin(plugin) {\n        return this.gameObject?.manager?.getPlugin(plugin);\n    }\n    getGameWorld() {\n        return this.gameObject?.manager?.gameWorld;\n    }\n    getManager() {\n        return this.gameObject?.manager;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/Component.ts?");

/***/ }),

/***/ "./src/Core/GameEvent.ts":
/*!*******************************!*\
  !*** ./src/Core/GameEvent.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventArgs: () => (/* binding */ EventArgs),\n/* harmony export */   GameEvent: () => (/* binding */ GameEvent)\n/* harmony export */ });\nclass EventArgs {\n    constructor() { }\n}\nclass GameEvent {\n    subs = new Map();\n    args = [];\n    subscribe(sub, alias) {\n        this.subs.set(new WeakRef(sub), alias);\n    }\n    unsubscribe(sub) {\n        this.subs.delete(new WeakRef(sub));\n    }\n    emit(args) {\n        this.args.push(args);\n    }\n    register(gameWorld) {\n        gameWorld?.registerEvent(this);\n    }\n    invoke() {\n        if (this.args.length == 0)\n            return;\n        for (const [sub, alias] of this.subs) {\n            const derefSub = sub.deref();\n            if (!derefSub) {\n                this.subs.delete(sub);\n                continue;\n            }\n            for (const args of this.args)\n                derefSub.event(args, alias);\n        }\n        this.args = [];\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/GameEvent.ts?");

/***/ }),

/***/ "./src/Core/GameObject.ts":
/*!********************************!*\
  !*** ./src/Core/GameObject.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObject: () => (/* binding */ GameObject)\n/* harmony export */ });\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _Components_Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/Body */ \"./src/Components/Body.ts\");\n\n\nclass GameObject {\n    enabled = true;\n    name = \"GameObject\";\n    id = (0,uuid__WEBPACK_IMPORTED_MODULE_1__[\"default\"])();\n    manager = undefined;\n    components = new Map();\n    constructor(...components) {\n        for (let component of components) {\n            const id = component.id;\n            if (this.components.has(id))\n                throw new Error(`Component with id: ${id} already exists in the game object`);\n            component.gameObject = this;\n            this.components.set(id, component);\n        }\n    }\n    getComponent(classC) {\n        return this.components.values().find(c => c instanceof classC);\n    }\n    getComponents(classC) {\n        return Array.from(this.components.values()).filter(c => c instanceof classC);\n    }\n    getAllComponents() {\n        return Array.from(this.components.values());\n    }\n    getBody() {\n        return this.getComponent(_Components_Body__WEBPACK_IMPORTED_MODULE_0__.BodyC);\n    }\n    spawn() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.spawn();\n    }\n    start() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.start();\n    }\n    update() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.update();\n    }\n    destroy() {\n        for (let component of this.components.values())\n            if (component.enabled)\n                component.destroy();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/GameObject.ts?");

/***/ }),

/***/ "./src/Core/GameWorld.ts":
/*!*******************************!*\
  !*** ./src/Core/GameWorld.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameWorld: () => (/* binding */ GameWorld)\n/* harmony export */ });\n/* harmony import */ var _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Plugins/Hud/Profiler */ \"./src/Plugins/Hud/Profiler.ts\");\n\nclass GameWorld {\n    startTime = 0;\n    prevWorldTime = 0;\n    worldTime = 0;\n    tickCount = 0;\n    plugins = new Map();\n    events = new Set();\n    constructor(...plugins) {\n        for (let plugin of plugins) {\n            let name = plugin.constructor.name;\n            if (this.plugins.has(name))\n                throw new Error(`Plugin ${name} already exists in the game object`);\n            plugin.gameWorld = this;\n            this.plugins.set(name, plugin);\n        }\n    }\n    //plugins\n    getPlugin(plugin) {\n        const name = plugin.name;\n        return this.getPluginByName(name);\n    }\n    getPluginByName(name) {\n        if (!this.plugins.has(name))\n            throw new Error(`Plugin ${name} does not exist in the game world`);\n        return this.plugins.get(name);\n    }\n    getAllPlugins() {\n        return Array.from(this.plugins.values());\n    }\n    hasPlugin(plugin) {\n        const name = plugin.name;\n        return this.plugins.has(name);\n    }\n    registerEvent(event) {\n        this.events.add(new WeakRef(event));\n    }\n    //time\n    getWorldTime() {\n        return this.worldTime / 1e3;\n    }\n    //flow control of components\n    // 1. start / update\n    // 2. event\n    tick() {\n        this.tickCount++;\n        if (this.tickCount == 1)\n            this.startWorld();\n        else\n            this.updateWorld();\n        this.invokeEvents();\n    }\n    startWorld() {\n        this.startTime = performance.now();\n        this.Start();\n        this.plugins.forEach(plugin => plugin.start());\n    }\n    updateWorld() {\n        this.worldTime = performance.now() - this.startTime;\n        const delta = this.worldTime - this.prevWorldTime;\n        this.prevWorldTime = this.worldTime;\n        this.Update(delta / 1e3);\n        this.plugins.forEach(plugin => {\n            if (!plugin.enabled)\n                return;\n            let start = performance.now();\n            plugin.update(delta / 1e3);\n            this.getPlugin(_Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__.ProfilerPlugin).addRecord(plugin.name, performance.now() - start);\n        });\n    }\n    invokeEvents() {\n        let start = performance.now();\n        for (const eventRef of this.events) {\n            const event = eventRef.deref();\n            if (event)\n                event.invoke();\n            else\n                this.events.delete(eventRef);\n        }\n        this.getPlugin(_Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_0__.ProfilerPlugin).addRecord(\"Events\", performance.now() - start);\n    }\n    //overridable methods\n    Start() { }\n    Update(delta) { }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Core/GameWorld.ts?");

/***/ }),

/***/ "./src/Core/Plugin.ts":
/*!****************************!*\
  !*** ./src/Core/Plugin.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Plugin: () => (/* binding */ Plugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n//WorldComponent = Plugin\nclass Plugin {\n    enabled = true;\n    name = \"Plugin\";\n    gameWorld;\n    //overideable methods\n    event(args, alias) { }\n    start() { }\n    update(delta) { }\n    getPlugin(plugin) {\n        return this.gameWorld.getPlugin(plugin);\n    }\n    hasPlugin(plugin) {\n        return this.gameWorld.hasPlugin(plugin) ?? false;\n    }\n    cliGetName() {\n        return this.name;\n    }\n    help() {\n        const BLUE = \"\\x1b[36m\";\n        const RESET = \"\\x1b[0m\";\n        let message = `${BLUE}${this.cliGetName()}${RESET} commands:\\n`;\n        for (const element of Object.values(this.constructor[\"syntaxes\"])) {\n            message += `  /${this.cliGetName()}:${element}\\n`;\n        }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, message, undefined);\n    }\n    cliEnable() {\n        const GREEN = \"\\x1b[32m\";\n        const RESET = \"\\x1b[0m\";\n        this.enabled = true;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, `${this.name} ${GREEN}enabled${RESET}`, undefined);\n    }\n    cliDisable() {\n        const RED = \"\\x1b[31m\";\n        const RESET = \"\\x1b[0m\";\n        this.enabled = false;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult(true, `${this.name} ${RED}disabled${RESET}`, undefined);\n    }\n}\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"help\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"help\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"enable\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"cliEnable\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.cli)(\"disable\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_0__.CommandResult)\n], Plugin.prototype, \"cliDisable\", null);\n\n\n//# sourceURL=webpack://gameengine/./src/Core/Plugin.ts?");

/***/ }),

/***/ "./src/GameObjectFactory.ts":
/*!**********************************!*\
  !*** ./src/GameObjectFactory.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GameObjectFactory: () => (/* binding */ GameObjectFactory)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Components_Collider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Components/Collider */ \"./src/Components/Collider.ts\");\n/* harmony import */ var _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Components/Renderers/ColliderRenderer */ \"./src/Components/Renderers/ColliderRenderer.ts\");\n/* harmony import */ var _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Helpers/Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Components/Renderers/ChasisRenderer */ \"./src/Components/Renderers/ChasisRenderer.ts\");\n/* harmony import */ var _Core_GameObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Core/GameObject */ \"./src/Core/GameObject.ts\");\n/* harmony import */ var _Components_Body__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Components/Body */ \"./src/Components/Body.ts\");\n/* harmony import */ var _Components_Tags__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Components/Tags */ \"./src/Components/Tags.ts\");\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Components/Renderers/BarRenderer */ \"./src/Components/Renderers/BarRenderer.ts\");\n/* harmony import */ var _Components_Health__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Components/Health */ \"./src/Components/Health.ts\");\n/* harmony import */ var _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Components/Renderers/TextRenderer */ \"./src/Components/Renderers/TextRenderer.ts\");\n\n// import { RigidBodyC } from \"./Components/RigidBody\";\n// import { GameObject } from \"./Core/GameObject\";\n// import { TextRendererC } from \"./Components/Renderers/TextRenderer\";\n\n\n// import { BarRendererC } from \"./Components/Renderers/BarRenderer\";\n// import { HealthC } from \"./Components/Health\";\n// import { Component } from \"./Core/Component\";\n// import { AnimationC } from \"./Components/Animation\";\n// import { CanonC } from \"./Components/Canon\";\n// import { PolygonRendererC } from \"./Components/Renderers/PolygonRenderer\";\n// import { DestroyerC } from \"./Components/Destroyer\";\n\n// import { CanonRendererC } from \"./Components/Renderers/CanonRenderer\";\n// import { BulletC } from \"./Components/Bullet\";\n// import { Vector } from \"./Helpers/Vector\";\n\n\n\n\n\n\n\n\nclass GameObjectFactory {\n    static polygonGO(radius = 2, n = 3, ...components) {\n        let polygonGO = new _Core_GameObject__WEBPACK_IMPORTED_MODULE_5__.GameObject(\n        // new RigidBodyC(0.1),\n        new _Components_Body__WEBPACK_IMPORTED_MODULE_6__.BodyC(0.1), new _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_8__.PolygonRendererC(radius, n, 0, _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.randomColor2().toArgb(0.75)), new _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_9__.BarRendererC(0.1), new _Components_Collider__WEBPACK_IMPORTED_MODULE_1__.ColliderC(_Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.getColliderRadius(n, radius)), new _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_2__.ColliderRendererC(), new _Components_Health__WEBPACK_IMPORTED_MODULE_10__.HealthC(25 * n), \n        // new AnimationC(),\n        new _Components_Tags__WEBPACK_IMPORTED_MODULE_7__.TagsC(\"Dragable\"), ...components);\n        polygonGO.getBody().setRotation(Math.random() * 2 * Math.PI);\n        // polygonGO.name = \"Polygon\";\n        return polygonGO;\n    }\n    // public static enemyGO(radius: number = 2.5, text: string=\"\", zindex = 4, ...components: Component[]): GameObject {\n    //     let circleGO: GameObject = new GameObject(\n    //         new TextRendererC(text, undefined, zindex+0.1),\n    //         new PolygonRendererC(radius, 8, zindex),\n    //         new BarRendererC(zindex+0.1),\n    //         new ChasisRendererC(zindex-0.2),\n    //         new RigidBodyC(30),\n    //         new ColliderC(radius, false),\n    //         new ColliderRendererC(zindex-0.15),\n    //         new HealthC(1500),\n    //         new AnimationC(),\n    //         new TracesRendererC(-21.37),\n    //         ...components\n    //     );\n    //     circleGO.getTransform().rotation = GMath.symRand(Math.PI);\n    //     circleGO.getComponent(CanonC).targetDirection = Vector.fromRad(GMath.symRand(Math.PI));\n    //     circleGO.name = \"Enemy\";\n    //     return circleGO;\n    // }\n    // public static bulletGO(owner: GameObject, hp=30, radius: number = 0.65, lifeTime: number=1, zindex=-1, ...components: Component[]): GameObject {\n    //     let bulletGO: GameObject = new GameObject(\n    //         new RigidBodyC(0.05, 1.0),\n    //         new PolygonRendererC(radius, 10, zindex, new rgb(173, 87, 87)),\n    //         new ColliderC(radius, false),\n    //         new ColliderRendererC(),\n    //         new HealthC(hp),\n    //         new AnimationC(),\n    //         new DestroyerC(lifeTime),\n    //         new BulletC(owner),\n    //         ...components\n    //     );\n    //     bulletGO.getTransform().rotation = 0;\n    //     bulletGO.name = \"Bullet\";\n    //     return bulletGO;\n    // }\n    static playerGO(radius = 2.5, zindex = 5, ...components) {\n        let playerGO = new _Core_GameObject__WEBPACK_IMPORTED_MODULE_5__.GameObject(\n        // new ImageRendererC(undefined, new Vector(1.3, 0.3), \"GameEngine/src/Assets/vectorpaint2.svg\" , zindex-0.2),\n        new _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_4__.ChasisRendererC(zindex - 0.2), new _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_8__.PolygonRendererC(radius, 10, zindex, new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(50, 99, 52)), new _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_11__.TextRendererC(\"Player\", true, zindex + 0.1), new _Components_Renderers_ColliderRenderer__WEBPACK_IMPORTED_MODULE_2__.ColliderRendererC(zindex - 0.15), new _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_9__.BarRendererC(zindex + 0.1), \n        // new CanonRendererC(zindex-0.1),\n        new _Components_Body__WEBPACK_IMPORTED_MODULE_6__.BodyC(25), new _Components_Collider__WEBPACK_IMPORTED_MODULE_1__.ColliderC(radius, false), new _Components_Health__WEBPACK_IMPORTED_MODULE_10__.HealthC(1000), \n        // new AnimationC(),\n        // new CanonC(6, 1.55, 44),\n        // new TracesRendererC(-21.37),\n        ...components);\n        playerGO.getBody().setRotation(Math.random() * 2 * Math.PI);\n        playerGO.name = \"Player\";\n        return playerGO;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/GameObjectFactory.ts?");

/***/ }),

/***/ "./src/Helpers/Color.ts":
/*!******************************!*\
  !*** ./src/Helpers/Color.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   rgb: () => (/* binding */ rgb)\n/* harmony export */ });\nclass rgb {\n    r = 0;\n    g = 0;\n    b = 0;\n    a = 1;\n    static stroke = new rgb(43, 43, 44);\n    // public static readonly background: rgb = new rgb(91, 93, 98);\n    static background = new rgb(93, 97, 95);\n    constructor(r, g, b, a = 1) {\n        this.r = Math.min(255, Math.max(0, r));\n        this.g = Math.min(255, Math.max(0, g));\n        this.b = Math.min(255, Math.max(0, b));\n        this.a = Math.min(1, Math.max(0, a));\n    }\n    toString() {\n        return `rgba(${this.r},${this.g},${this.b},${Math.max(0, Math.min(this.a, 1))})`;\n    }\n    toRgb() {\n        return new rgb(this.r, this.g, this.b);\n    }\n    toArgb(alpha) {\n        return new rgb(this.r, this.g, this.b, alpha);\n    }\n    blend(color, alpha) {\n        return new rgb(this.r * (1 - alpha) + color.r * alpha, this.g * (1 - alpha) + color.g * alpha, this.b * (1 - alpha) + color.b * alpha, this.a * (1 - alpha) + color.a * alpha);\n    }\n    static randomColor() {\n        return new rgb(Math.random() * 255, Math.random() * 255, Math.random() * 255);\n    }\n    static hslToRgb(h, s, l) {\n        s /= 100;\n        l /= 100;\n        const k = (n) => (n + h / 30) % 12;\n        const a = s * Math.min(l, 1 - l);\n        const f = (n) => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));\n        const r = Math.round(f(0) * 255);\n        const g = Math.round(f(8) * 255);\n        const b = Math.round(f(4) * 255);\n        return new rgb(r, g, b);\n    }\n    static randomColor2() {\n        const hue = Math.floor(Math.random() * 360);\n        const saturation = Math.floor(Math.random() * 30) + 15;\n        const lightness = Math.floor(Math.random() * 20) + 30;\n        return rgb.hslToRgb(hue, saturation, lightness);\n    }\n    static getHeatmapColor(value) {\n        value = Math.max(0, Math.min(1, value));\n        let g = Math.min(255, Math.max(0, Math.floor(255 * value * 2)));\n        let r = Math.min(255, Math.max(0, Math.floor(255 * (2 - value * 2))));\n        return new rgb(r / 1.5, g / 1.5, 0, 255);\n    }\n    static tryParseCssColor(color) {\n        let tempElem = document.body;\n        let lastColor = tempElem.style.color;\n        tempElem.style.color = color;\n        let computedColor = getComputedStyle(tempElem).color;\n        tempElem.style.color = lastColor;\n        return this.getRgbFromComputedStyle(computedColor);\n    }\n    static getRgbFromComputedStyle(style) {\n        let match = style.match(/^rgb(a?)\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*([\\d.]+))?\\)$/);\n        if (!match)\n            return undefined;\n        return new rgb(parseInt(match[2]), parseInt(match[3]), parseInt(match[4]), parseFloat(match[5] ?? 1));\n    }\n    clone() {\n        return new rgb(this.r, this.g, this.b, this.a);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Color.ts?");

/***/ }),

/***/ "./src/Helpers/Commands.ts":
/*!*********************************!*\
  !*** ./src/Helpers/Commands.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandResult: () => (/* binding */ CommandResult),\n/* harmony export */   cli: () => (/* binding */ cli),\n/* harmony export */   cliPlugin: () => (/* binding */ cliPlugin)\n/* harmony export */ });\nclass CommandResult {\n    status;\n    message;\n    data;\n    constructor(status, message, data) {\n        this.status = status;\n        this.message = message;\n        this.data = data;\n    }\n}\nfunction cli(name, argsSyntax, returnType) {\n    return function (target, propertyKey, descriptor) {\n        const originalMethod = descriptor.value;\n        if (originalMethod) {\n            name = name ?? propertyKey;\n            returnType = returnType ?? \"void\";\n            argsSyntax = argsSyntax ?? \"\";\n            if (argsSyntax)\n                argsSyntax = \" \" + argsSyntax;\n            if (returnType)\n                returnType = \": \" + returnType;\n            argsSyntax = name + argsSyntax + returnType;\n            const ctor = target.constructor;\n            if (!Object.prototype.hasOwnProperty.call(ctor, \"commands\")) {\n                ctor.commands = Object.assign({}, ctor.commands || {});\n            }\n            ctor.commands[name] = originalMethod;\n            if (!Object.prototype.hasOwnProperty.call(ctor, \"syntaxes\")) {\n                ctor.syntaxes = Object.assign({}, ctor.syntaxes || {});\n            }\n            console.log(\"Adding syntax:\", argsSyntax);\n            ctor.syntaxes[name] = argsSyntax;\n        }\n    };\n}\n// export function gameCommand(\n//     target: any, \n//     propertyKey: string, \n//     descriptor: TypedPropertyDescriptor<(...args: any[]) => CommandResult>,\n// ): void {\n//     // console.log(target);\n//     const originalMethod = descriptor.value;\n//     if (originalMethod) {\n//         const ctor = target.constructor;\n//         if (!Object.prototype.hasOwnProperty.call(ctor, \"commands\")) {\n//             ctor.commands = Object.assign({}, ctor.commands || {});\n//         }\n//         ctor.commands[propertyKey] = descriptor.value;\n//     }\n// }\nfunction cliPlugin(name) {\n    return function (target) {\n        target.prototype.cliGetName = function () { return name; };\n    };\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Commands.ts?");

/***/ }),

/***/ "./src/Helpers/Math.ts":
/*!*****************************!*\
  !*** ./src/Helpers/Math.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GMath: () => (/* binding */ GMath)\n/* harmony export */ });\nclass GMath {\n    static symRand(value) {\n        return (2 * Math.random() - 1) * value;\n    }\n    static getColliderRadius(n, radius) {\n        if (n >= 10)\n            return radius;\n        const angle = Math.PI / n;\n        const h = Math.cos(angle) * radius;\n        return (2 * h + radius) / 3;\n    }\n    static deltaAngle(a, b) {\n        a = a % (2 * Math.PI) + 2 * Math.PI;\n        a = a % (2 * Math.PI);\n        b = b % (2 * Math.PI) + 2 * Math.PI;\n        b = b % (2 * Math.PI) + 2 * Math.PI;\n        return (b - a + Math.PI) % (2 * Math.PI) - Math.PI;\n    }\n    static elasticCollision1D(m1, v1, m2, v2) {\n        const v1Final = ((v1 * (m1 - m2)) + (2 * m2 * v2)) / (m1 + m2);\n        const v2Final = ((v2 * (m2 - m1)) + (2 * m1 * v1)) / (m1 + m2);\n        return [v1Final, v2Final];\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Math.ts?");

/***/ }),

/***/ "./src/Helpers/Vector.ts":
/*!*******************************!*\
  !*** ./src/Helpers/Vector.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Vector: () => (/* binding */ Vector)\n/* harmony export */ });\n/* harmony import */ var _Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! planck-js */ \"./node_modules/planck-js/dist/planck.mjs\");\n\n\nclass Vector extends planck_js__WEBPACK_IMPORTED_MODULE_1__.Vec2 {\n    constructor(x, y) {\n        super(x, y);\n    }\n    //standard operators\n    add(a) {\n        return new Vector(this.x + a.x, this.y + a.y);\n    }\n    sub(a) {\n        return new Vector(this.x - a.x, this.y - a.y);\n    }\n    mul(a) {\n        return new Vector(this.x * a, this.y * a);\n    }\n    timesV(other) {\n        return new Vector(this.x * other.x, this.y * other.y);\n    }\n    //other operators \n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    distance(other) {\n        return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2));\n    }\n    static distance(a, b) {\n        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n    }\n    cross() {\n        return new Vector(this.y, -this.x).toUnit();\n    }\n    scalarProduct(v) {\n        return this.x * v.x + this.y * v.y;\n    }\n    vectorProduct(v) {\n        return this.x * v.y - this.y * v.x;\n    }\n    perpendicular(n) {\n        return this.sub(n.cross().mul((n.scalarProduct(this)) / (n.length() * n.length())));\n    }\n    toUnit() {\n        if (this.length() != 0)\n            return new Vector(this.x, this.y).mul(1 / this.length());\n        else\n            return new Vector(1, 0);\n    }\n    setLength(length) {\n        return this.toUnit().mul(length);\n    }\n    toString() {\n        return \"{\" + this.x + \":\" + this.y + \"}\";\n    }\n    toRad() {\n        return Math.atan2(this.y, this.x); // Kąt w radianach\n    }\n    reverse() {\n        let sx = 1e32;\n        let sy = 1e32;\n        if (this.x != 0)\n            sx = 1 / this.x;\n        if (this.y != 0)\n            sy = 1 / this.y;\n        return new Vector(sx, sy);\n    }\n    interpolate(target, k) {\n        const mx = target.sub(this);\n        const mv = mx.sub(mx.mul(Math.min(1, Math.max(0, k))));\n        return this.add(mv);\n    }\n    static fromRad(rad) {\n        return new Vector(Math.cos(rad), Math.sin(rad));\n    }\n    static fromVec2(vec) {\n        return new Vector(vec.x, vec.y);\n    }\n    static randomPos(range) {\n        return new Vector(_Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(range), _Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(range));\n    }\n    static randomPos2(range) {\n        let angle = _Math__WEBPACK_IMPORTED_MODULE_0__.GMath.symRand(Math.PI);\n        let distance = Math.random() * range;\n        return Vector.fromRad(angle).mul(distance);\n    }\n    clone() {\n        return new Vector(this.x, this.y);\n    }\n    //consts\n    static zero() { return new Vector(0, 0); }\n    static one() { return new Vector(1, 1); }\n    static up() { return new Vector(0, 1); }\n    static down() { return new Vector(0, -1); }\n    static left() { return new Vector(-1, 0); }\n    static right() { return new Vector(1, 0); }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Helpers/Vector.ts?");

/***/ }),

/***/ "./src/Plugins/Camera.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Camera.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CameraPlugin: () => (/* binding */ CameraPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n/* harmony import */ var _Components_Body__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Components/Body */ \"./src/Components/Body.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar CameraPlugin_1;\n\n\n\n\n\n\nlet CameraPlugin = CameraPlugin_1 = class CameraPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    cameraPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(4, 0);\n    targetCameraPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(4, 0);\n    cameraScreenOffset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(100, 100);\n    followingSpeed = 0.02;\n    isFollowing = true;\n    scaleV = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(20, -20);\n    scale = 20;\n    targetId = \"None\"; //todo: delete this\n    targetScale = 40;\n    name = \"CameraPlugin\";\n    start() {\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseScrollYEvent.subscribe(this, \"scroll\");\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseDownEvent.subscribe(this, \"down\");\n        this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).mouseUpEvent.subscribe(this, \"up\");\n    }\n    event(args, alias) {\n        if (alias == \"scroll\") {\n            const mouseArgs = args;\n            this.zoom(mouseArgs.delta);\n        }\n        //todo: delete this\n        else if (alias == \"down\") {\n            const mouseArgs = args;\n            if (mouseArgs.button != 1)\n                return;\n            const target = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).getGameObject(this.targetId);\n            if (target) {\n                this.targetId = \"None\";\n                return;\n            }\n            const mousePositonScreen = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).getMouseScreenPosition();\n            const mousePositon = this.getWorldPosition(mousePositonScreen);\n            // let gameObject = this.getPlugin(CollisionDetectionPlugin).overlapPoint(mousePositon)[0]?.getGameObject();\n            // if (gameObject)\n            //     this.targetId = gameObject.getId();\n        }\n        // else if (alias == \"up\") {\n        //     const mouseArgs = args as MouseClickEventArgs;\n        //     if (mouseArgs.button != 1) \n        //         return;\n        //     this.target = undefined;\n        // }\n    }\n    zoom(delta) {\n        delta = Math.sign(delta);\n        if (delta > 0 && this.targetScale * 0.9 > 10)\n            this.targetScale = 0.9 * this.targetScale;\n        if (delta < 0 && this.targetScale * 1.1 < 100)\n            this.targetScale = 1.1 * this.targetScale;\n    }\n    getWorldPosition(screenPositon) {\n        let scale = this.getPlugin(CameraPlugin_1).scaleV;\n        let cameraPosition = this.getPlugin(CameraPlugin_1).cameraPosition;\n        let worldPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector((screenPositon.x - this.cameraScreenOffset.x) / scale.x, (screenPositon.y - this.cameraScreenOffset.y) / scale.y).add(cameraPosition);\n        return worldPosition;\n    }\n    update(delta) {\n        if (this.isFollowing)\n            this.cameraPosition = this.cameraPosition.interpolate(this.targetCameraPosition, Math.pow(this.followingSpeed, delta));\n        // this.scale += (this.targetScale-this.scale)*(2.5*delta);\n        this.scale += (this.targetScale - this.scale) * (1 - Math.pow(0.002, delta)); // (this.targetScale-this.scale)*(2.5*delta);\n        this.scaleV = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(this.scale, -this.scale);\n        //todo: delete this\n        const target = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).getGameObject(this.targetId);\n        if (target) {\n            const mousePositonScreen = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_2__.MousePlugin).getMouseScreenPosition();\n            const mousePositon = this.getWorldPosition(mousePositonScreen);\n            target.getComponent(_Components_Body__WEBPACK_IMPORTED_MODULE_5__.BodyC)?.setPosition(target.getComponent(_Components_Body__WEBPACK_IMPORTED_MODULE_5__.BodyC).getPosition().interpolate(mousePositon, Math.pow(0.001, delta)));\n            // if (this.getPlugin(KeyboardPlugin).isPressed(\"2\")){\n            //     target.getTransform().rotation += 0.5*3.14*delta;\n            // }\n            // if (this.getPlugin(KeyboardPlugin).isPressed(\"1\")){ \n            //     target.getTransform().rotation -= 0.5*3.14*delta;\n            // }\n        }\n    }\n    getscale() {\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, this.scaleV.toString(), this.scaleV);\n    }\n    follow(following) {\n        this.isFollowing = following;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, `Camera is ${following ? \"following\" : \"not following\"}`, undefined);\n    }\n    setzoom(zoom) {\n        this.targetScale = zoom;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult(true, `Camera zoom set to ${zoom}`, undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"getscale\", undefined, \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"getscale\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"follow\", \"<following: boolean>\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Boolean]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"follow\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cli)(\"zoom\", \"<zoom: number>\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.CommandResult)\n], CameraPlugin.prototype, \"setzoom\", null);\nCameraPlugin = CameraPlugin_1 = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_3__.cliPlugin)(\"camera\")\n], CameraPlugin);\n\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Camera.ts?");

/***/ }),

/***/ "./src/Plugins/Cli.ts":
/*!****************************!*\
  !*** ./src/Plugins/Cli.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CliPlugin: () => (/* binding */ CliPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\nlet CliPlugin = class CliPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"CliPlugin\";\n    globalCommands = new Map();\n    echo(message) {\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, message);\n    }\n    loop(iters, command) {\n        let ret = [];\n        let message = \"\";\n        for (let i = 0; i < iters; i++) {\n            const result = this.parseAndExecuteCommands(command);\n            if (!result.status) {\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Error executing command: ${result.message}`, undefined);\n            }\n            ret.push(result.data);\n            message += `${result.message}\\n`;\n        }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, ret);\n    }\n    true() {\n        const message = \"This is a true command\";\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, true);\n    }\n    false() {\n        const message = \"This is a false command\";\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, false);\n    }\n    int(value) {\n        const message = `This is an int command with value ${value}`;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, parseInt(value));\n    }\n    float(value) {\n        const message = `This is a float command with value ${value}`;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, parseFloat(value));\n    }\n    refresh() {\n        const message = \"This is a refresh command\";\n        location.reload();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, undefined);\n    }\n    getrandomcolor() {\n        const randomColor = _Helpers_Color__WEBPACK_IMPORTED_MODULE_1__.rgb.randomColor2();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, `Random color is ${randomColor}`, randomColor);\n    }\n    help() {\n        let superResult = super.help();\n        let message = `plugins:\\n`;\n        for (const plugin of this.gameWorld?.getAllPlugins() ?? []) {\n            message += `/${plugin.cliGetName()}\\n`;\n        }\n        message = superResult.message + \"\\n\" + message;\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, message, undefined);\n    }\n    art() {\n        const asciiArt = `\r\n        \\x1b[31m██████╗░░█████╗░██████╗░███████╗\r\n        \\x1b[32m██╔══██╗██╔══██╗██╔══██╗╚════██║\r\n        \\x1b[33m██║░░██║██║░░██║██████╔╝░░░░██╔╝\r\n        \\x1b[34m██║░░██║██║░░██║██╔═══╝░░░░██╔╝░\r\n        \\x1b[35m██████╔╝╚█████╔╝██║░░░░░░░██║░░░\r\n        \\x1b[36m╚═════╝░░╚════╝░╚═╝░░░░░░░╚═╝░░░\\x1b[0m\r\n        `;\n        const ansiArt = `\r\n\\x1b[38;5;160m         ██████         \\x1b[0m\r\n\\x1b[38;5;160m       ██████████       \\x1b[0m\r\n\\x1b[38;5;160m      ████    ████      \\x1b[0m\r\n\\x1b[38;5;82m    ████        ████    \\x1b[0m\r\n\\x1b[38;5;82m   ████          ████   \\x1b[0m\r\n\\x1b[38;5;82m  ████            ████  \\x1b[0m\r\n\\x1b[38;5;82m  ████    ████    ████  \\x1b[0m\r\n\\x1b[38;5;82m  ████████████████████  \\x1b[0m\r\n\\x1b[38;5;226m   ██████████████████   \\x1b[0m\r\n\\x1b[38;5;226m     ████████████████     \\x1b[0m\r\n\\x1b[38;5;226m      ████    ██████      \\x1b[0m\r\n\\x1b[38;5;196m      ████    ██████      \\x1b[0m\r\n\\x1b[38;5;196m     ██████████████████     \\x1b[0m\r\n\\x1b[38;5;196m    ████████████████████    \\x1b[0m\r\n\\x1b[38;5;196m   ██████████████████████   \\x1b[0m\r\n\\x1b[38;5;196m  ████████████████████████  \\x1b[0m\r\n\\x1b[38;5;160m      ██████████████      \\x1b[0m\r\n\\x1b[38;5;160m       ████████████       \\x1b[0m\r\n        `;\n        console.log(ansiArt);\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(true, ansiArt, undefined);\n    }\n    execute(command) {\n        try {\n            return this.parseAndExecuteCommands(command);\n        }\n        catch {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"Command execution failed\", undefined);\n        }\n    }\n    start() {\n        this.gameWorld?.getAllPlugins().forEach(plugin => {\n            const pluginName = plugin.constructor.name;\n            try {\n                for (let command of Object.keys(plugin.constructor[\"commands\"])) {\n                    if (this.globalCommands.has(command))\n                        this.globalCommands.set(command, undefined);\n                    else\n                        this.globalCommands.set(command, pluginName);\n                }\n            }\n            catch { }\n        });\n    }\n    ;\n    parseAndExecuteCommands(input, depth = 0) {\n        console.log((\"---\".repeat(depth)) + \"Parsing: \" + input);\n        const args = [];\n        let current = '';\n        let inSingleQuote = false;\n        let inDoubleQuote = false;\n        let parenDepth = 0;\n        input = input.trim();\n        for (let i = 0; i < input.length; i++) {\n            const char = input[i];\n            if (parenDepth > 0) {\n                if (char === \"{\") {\n                    parenDepth++;\n                    current += char;\n                    continue;\n                }\n                if (char === \"}\") {\n                    parenDepth--;\n                    if (parenDepth === 0) {\n                        const result = this.parseAndExecuteCommands(current, depth + 1);\n                        // console.log(\"   \".repeat(depth)+result.message);\n                        args.push(result.data);\n                        current = '';\n                    }\n                    else\n                        current += char;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (inDoubleQuote) {\n                if (char === \"\\\"\") {\n                    args.push(current);\n                    current = '';\n                    inDoubleQuote = false;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (inSingleQuote) {\n                if (char === \"'\") {\n                    args.push(current);\n                    current = '';\n                    inSingleQuote = false;\n                    continue;\n                }\n                current += char;\n                continue;\n            }\n            if (char === \"\\\"\") {\n                inDoubleQuote = true;\n                continue;\n            }\n            if (char === \"'\") {\n                inSingleQuote = true;\n                continue;\n            }\n            if (char === \"{\") {\n                parenDepth++;\n                continue;\n            }\n            if (char === \" \") {\n                if (current.trim() !== \"\") {\n                    args.push(current);\n                    current = '';\n                }\n                continue;\n            }\n            current += char;\n        }\n        if (current.trim() !== \"\") {\n            args.push(current);\n        }\n        console.log(\"---\".repeat(depth) + \"Parsing result: \", args);\n        const fullCommand = args[0].split(':');\n        if (fullCommand.length === 2) {\n            const pluginName = fullCommand[0];\n            const plugin = this.gameWorld?.getAllPlugins().find(p => p.cliGetName() === pluginName);\n            if (!plugin)\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Plugin ${pluginName} not found`, undefined);\n            return this.executeParsedCommand(plugin, fullCommand[1], ...args.slice(1));\n        }\n        else if (fullCommand.length === 1) {\n            try {\n                if (!this.globalCommands.has(fullCommand[0]))\n                    return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Command ${fullCommand[0]} not found`, undefined);\n                const pluginName = this.globalCommands.get(fullCommand[0]);\n                if (!pluginName)\n                    return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `More than one command found, use \"/<plugin>:<command>\" (fe /cli:help) instead.`, undefined);\n                const plugin = this.gameWorld?.getPluginByName(pluginName);\n                return this.executeParsedCommand(plugin, fullCommand[0], ...args.slice(1));\n            }\n            catch {\n                return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"Command not found or wrong syntax\", undefined);\n            }\n        }\n        else {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, \"No command found\", undefined);\n        }\n    }\n    executeParsedCommand(plugin, command, ...args) {\n        if (plugin.constructor[\"commands\"][command] === undefined) {\n            return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Command ${command} not found`, undefined);\n        }\n        try {\n            let commandToApply = plugin.constructor[\"commands\"][command];\n            let result = commandToApply.apply(plugin, args);\n            return result;\n        }\n        catch { }\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult(false, `Failed to execute command ${command} on ${plugin.cliGetName()}`, undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"echo\", \"<message: string>\", \"string\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"echo\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"loop\", \"<iterations: int> <command: string>\", \"string\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [Number, String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"loop\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"true\", undefined, \"bool\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"true\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"false\", undefined, \"bool\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"false\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"int\", \"<value: string>\", \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"int\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"float\", \"<value: string>\", \"number\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", [String]),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"float\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"refresh\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"refresh\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"randomcolor\", undefined, \"rgb\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"getrandomcolor\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"help\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"help\", null);\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cli)(\"art\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.CommandResult)\n], CliPlugin.prototype, \"art\", null);\nCliPlugin = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_2__.cliPlugin)(\"cli\")\n], CliPlugin);\n\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Cli.ts?");

/***/ }),

/***/ "./src/Plugins/Client.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Client.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientPlugin: () => (/* binding */ ClientPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass ClientPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ClientPlugin\";\n    socket;\n    start() {\n        // this.getPlugin(ChatPlugin)?.chatMessageEvent.subscribe(this, \"chatMessageEvent\");\n        // this.socket = io('http://localhost:3000', {});\n        // this.socket.on('connect', () => this.onConnection());\n        // this.socket.on('disconnect', (reason: string) => this.onDisconnection(reason));\n        // this.socket.on('chat_message', (message: string) => this.onChatMessage(message));\n    }\n    event(args, alias) {\n        let chatArgs = args;\n        this.sendChatMessage(chatArgs.message);\n    }\n    onConnection() {\n        console.log('Connected to server');\n    }\n    onDisconnection(reason) {\n        console.log(`Disconnected from server: ${reason}`);\n    }\n    onChatMessage(message) {\n        console.log(`Received chat message: ${message}`);\n        // this.getPlugin(ChatPlugin)?.sendChatMessage(message, false);\n    }\n    sendChatMessage(message) {\n        // this.socket.emit('chat_message', message);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Client.ts?");

/***/ }),

/***/ "./src/Plugins/CollisionDetection.ts":
/*!*******************************************!*\
  !*** ./src/Plugins/CollisionDetection.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CollisionDetectionPlugin: () => (/* binding */ CollisionDetectionPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass CollisionDetectionPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"CollisionDetectionPlugin\";\n    cellSize = 5;\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/CollisionDetection.ts?");

/***/ }),

/***/ "./src/Plugins/Config.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Config.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConfigPlugin: () => (/* binding */ ConfigPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\n\nclass ConfigPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"ConfigPlugin\";\n    config = new Map([\n        [\"bulletSize\", 0.75],\n        // [\"displayColliders\", true as any],\n        [\"playerSize\", 2.5],\n        [\"bulletColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(56, 57, 60)],\n        // [\"playerColor\", new Color(145, 125, 39) as any],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(122, 111, 62)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(80, 37, 36)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(59, 94, 76)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(129, 49, 54)],\n        [\"playerColor\", new _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb(130, 111, 51)],\n    ]);\n    get(key) {\n        if (!this.config.has(key))\n            return undefined;\n        return this.config.get(key);\n    }\n    set(key, value) {\n        this.config.set(key, value);\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Config.ts?");

/***/ }),

/***/ "./src/Plugins/GOManager.ts":
/*!**********************************!*\
  !*** ./src/Plugins/GOManager.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GOManagerPlugin: () => (/* binding */ GOManagerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass GOManagerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"GameObjects\";\n    gameObjects = new Map();\n    getGameObject(id) {\n        return this.gameObjects.get(id);\n    }\n    start() {\n        for (let gameObject of this.gameObjects.values())\n            gameObject.start();\n    }\n    //spawning\n    isSpawned(gameObject) {\n        return this.gameObjects.has(gameObject.id);\n    }\n    spawn(gameObject) {\n        this.gameObjects.set(gameObject.id, gameObject);\n        gameObject.manager = this;\n        gameObject.spawn();\n    }\n    destroy(gameObject) {\n        gameObject.destroy();\n        gameObject.manager = undefined;\n        this.gameObjects.delete(gameObject.id);\n    }\n    getComponents(classC) {\n        return Array.from(this.gameObjects.values().flatMap(go => go.getComponents(classC)));\n    }\n    getAllComponents() {\n        return Array.from(this.gameObjects.values().flatMap(go => go.getAllComponents()));\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/GOManager.ts?");

/***/ }),

/***/ "./src/Plugins/Hud/Console.ts":
/*!************************************!*\
  !*** ./src/Plugins/Hud/Console.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConsoleEventArgs: () => (/* binding */ ConsoleEventArgs),\n/* harmony export */   ConsolePlugin: () => (/* binding */ ConsolePlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Cli__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Cli */ \"./src/Plugins/Cli.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var ansi_up__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ansi-up */ \"./node_modules/ansi-up/dist/ansi-up.js\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\n\n\n\n\n\nclass ConsoleEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    message;\n    constructor(message) {\n        super();\n        this.message = message;\n    }\n}\nlet ConsolePlugin = class ConsolePlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ConsolePlugin\";\n    isVisible = true;\n    consoleWrapper = document.createElement(\"div\");\n    buffer = \"\";\n    history = [\"\"];\n    historyIndex = 0;\n    constructor() {\n        super();\n        document.body.appendChild(this.consoleWrapper);\n        this.consoleWrapper.innerHTML = this.getInnerHtml();\n    }\n    start() {\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).KeyDownEvent.subscribe(this, \"keydown\");\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).BlockedKeyDownEvent.subscribe(this, \"keydown\");\n    }\n    event(args, alias) {\n        const key = args.key;\n        let input;\n        try {\n            input = this.consoleWrapper.querySelector(\".console-input\");\n        }\n        catch { }\n        if (!input)\n            return;\n        if (this.isFocused()) {\n            if (key == \"arrowup\") {\n                if (this.historyIndex < this.history.length - 1) {\n                    this.historyIndex++;\n                    input.value = this.history[this.historyIndex];\n                }\n            }\n            if (key == \"arrowdown\") {\n                if (this.historyIndex > 0) {\n                    this.historyIndex--;\n                    console.log(this.historyIndex);\n                    console.log(this.history);\n                    input.value = this.history[this.historyIndex];\n                }\n            }\n            if (key == \"escape\") {\n                input.blur();\n                input.value = \"\";\n            }\n            if (key == \"enter\") {\n                const value = input.value.trim();\n                if (value !== \"\") {\n                    input.value = \"\";\n                    console.log(\"Sending:\", value);\n                    this.messageEntered(value);\n                }\n                input.blur();\n            }\n        }\n        else {\n            if (key == \"enter\" && this.isVisible) {\n                input.focus();\n            }\n            if (key == \"t\") {\n                try {\n                    if (this.isVisible) {\n                        document.body.removeChild(this.consoleWrapper);\n                        input.blur();\n                    }\n                    else\n                        document.body.appendChild(this.consoleWrapper);\n                    this.isVisible = !this.isVisible;\n                }\n                catch (error) {\n                    console.log(\"Error: \", error);\n                }\n            }\n        }\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).block = this.isFocused();\n    }\n    isFocused() {\n        try {\n            const input = this.consoleWrapper.querySelector(\".console-input\");\n            if (input == null)\n                return false;\n            return document.activeElement === input;\n        }\n        catch {\n            return false;\n        }\n    }\n    writeLine(message) {\n        this.buffer += message + \"\\r\\n\";\n        this.setStatus(\"white\");\n        this.updateConsole();\n    }\n    messageEntered(message) {\n        // this.chatMessageEvent.emit(new ChatEventArgs(message));\n        if (message.startsWith(\"/\")) {\n            this.buffer += message + \"\\n\";\n            const result = this.getPlugin(_Cli__WEBPACK_IMPORTED_MODULE_3__.CliPlugin).execute(message.slice(1));\n            if (result.message != \"\")\n                this.buffer += result.message + \"\\r\\n\";\n            if (result.status)\n                this.setStatus(\"#485b49\");\n            else\n                this.setStatus(\"#813136\");\n        }\n        else {\n            this.buffer += message + \"\\r\\n\";\n            this.setStatus(\"white\");\n        }\n        this.history[0] = message;\n        this.history.unshift(\"\");\n        this.historyIndex = 0;\n        // this.buffer += \"<hr class='console-item-separator'/>\";\n        this.updateConsole();\n    }\n    setStatus(status) {\n        try {\n            const statusBar = this.consoleWrapper.querySelector(\".console-status\");\n            if (statusBar == null)\n                return;\n            statusBar.style.backgroundColor = status.toString();\n        }\n        catch { }\n    }\n    updateConsole() {\n        this.setElementsHtml(this.buffer);\n    }\n    setElementsHtml(buffer) {\n        try {\n            const content = this.consoleWrapper.querySelector(\".console-content\");\n            if (content == null)\n                return;\n            content.innerHTML = \"\";\n            const lines = buffer.split(\"\\n\");\n            for (let i = 0; i < lines.length - 1; i++) {\n                const line = lines[i];\n                const convert = new ansi_up__WEBPACK_IMPORTED_MODULE_5__.AnsiUp();\n                const html = convert.ansi_to_html(line);\n                let span = document.createElement(\"span\");\n                // span.textContent = line;\n                span.innerHTML = html;\n                content.appendChild(span);\n                const separator = document.createElement(\"hr\");\n                separator.className = \"console-item-separator\";\n                if (line.endsWith(\"\\r\"))\n                    content.appendChild(separator);\n                else\n                    content.appendChild(document.createElement(\"br\"));\n            }\n        }\n        catch { }\n    }\n    getInnerHtml() {\n        const profiler = `\r\n            <style>\r\n                .console{\r\n                    ${this.isVisible ? \"\" : \"display: none;\"}\r\n                    position: fixed;\r\n                    top: 20px;\r\n                    right: 20px;\r\n                    \r\n                    width: 400px;\r\n                    padding: 20px;\r\n                    border-radius: 20px;\r\n                    background-color: rgba(42, 43, 46, 0.382);\r\n                    color: white;\r\n                    font-family: \"IBM Plex Mono\", monospace;\r\n                    pointer-events: none;\r\n                    overflow: hidden;\r\n                }\r\n                .console-status{\r\n                    margin: 7px 0;\r\n                    height: 6px;\r\n                    background-color: white;\r\n                    opacity: 1;\r\n                    border-radius: 999px;\r\n                }\r\n                .console-header{\r\n                    font-size: 20px;\r\n                    font-weight: bold;\r\n                    height: 40px;\r\n                    color: white;\r\n                    margin-bottom: 10px;\r\n                    user-select: none;\r\n                }\r\n                .console-input{\r\n                    width: 100%; \r\n                    padding: 5px 0;\r\n                    margin: 0;\r\n                    border-radius: 0; \r\n                    border: none; \r\n                    border-bottom: 1px solid rgba(240, 240, 240, 0.5);\r\n                    background-color: transparent; \r\n                    color: white;\r\n                    font-size: 20px;   \r\n                }\r\n                .console *::selection {\r\n                    background-color: #546855;\r\n                    color: white;\r\n                }\r\n                .console-input:focus{\r\n                    outline: none; \r\n                    border-bottom: 1px solid rgba(240, 240, 240, 0.85);\r\n                }\r\n                .console-content-wrapper{\r\n                    position: relative;\r\n                    height: 600px;\r\n                    width: 100%;\r\n                    overflow: hidden;\r\n                }\r\n                .console-content{\r\n                    white-space: pre-wrap;\r\n                    word-wrap: break-word;\r\n                    position: absolute;\r\n                    width: 100%;\r\n                    line-height: 20px;\r\n                    font-size: 20px;\r\n                    margin: 0;\r\n                    bottom: 0;\r\n                }\r\n                .console-item-separator{\r\n                    border: none;\r\n                    border-top: 1px dashed gray;\r\n                    opacity: 0.75;\r\n                    margin: 9.5px 0;\r\n                }t\r\n            </style>\r\n\r\n            <div class=\"console\">\r\n                <div class=\"console-header\">\r\n                    <h2 style=\"margin: 0\">Console <span style=\"opacity: 0.5\">[T]</span></h2>\r\n                </div>\r\n                <div class=\"console-status\"></div>\r\n                <div class=\"console-content-wrapper\">\r\n                    <pre class=\"console-content\"></pre>\r\n                </div>\r\n                    <input class=\"console-input\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" type=\"text\" tabindex=\"-1\" placeholder=\"Type your command here...\" />\r\n            </div>\r\n            `;\n        // <div class=\"console-header\">\n        //         <h2 style=\"margin: 0\">Console <span style=\"opacity: 0.5\">[T]</span></h2>\n        //     </div>\n        return profiler;\n    }\n    clearConsole() {\n        this.buffer = \"\";\n        this.updateConsole();\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.CommandResult(true, \"\", undefined);\n    }\n};\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.cli)(\"clear\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.CommandResult)\n], ConsolePlugin.prototype, \"clearConsole\", null);\nConsolePlugin = __decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_4__.cliPlugin)(\"console\"),\n    __metadata(\"design:paramtypes\", [])\n], ConsolePlugin);\n\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Hud/Console.ts?");

/***/ }),

/***/ "./src/Plugins/Hud/Profiler.ts":
/*!*************************************!*\
  !*** ./src/Plugins/Hud/Profiler.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ProfilerPlugin: () => (/* binding */ ProfilerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Keyboard */ \"./src/Plugins/Keyboard.ts\");\n\n\nclass ProfilerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"ProfilerPlugin\";\n    size = 250;\n    isVisible = true;\n    profilerWrapper = document.createElement(\"div\");\n    usage = new Map();\n    constructor() {\n        super();\n    }\n    start() {\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_1__.KeyboardPlugin).KeyDownEvent.subscribe(this, \"keydown\");\n        document.body.appendChild(this.profilerWrapper);\n        this.addRecord(\"Fps\", 0);\n    }\n    lastTime = performance.now();\n    frames = 0;\n    fpsHistory = [];\n    update(delta) {\n        const fps = 1 / delta;\n        this.addRecord(\"Fps\", fps);\n        this.frames++;\n        const now = performance.now();\n        if (now - this.lastTime >= 250) {\n            this.fpsHistory.push(this.frames * 4);\n            if (this.fpsHistory.length > 100)\n                this.fpsHistory.shift();\n            this.frames = 0;\n            this.lastTime = now;\n        }\n        let i = 0;\n        let values = [];\n        for (const element of this.usage) {\n            let key = element[0];\n            let len = element[1].length;\n            let mean = 0;\n            for (const v of element[1])\n                mean += v;\n            mean /= len;\n            i++;\n            values.push(`${key}: ` + (mean).toFixed(2).toString());\n        }\n        this.profilerWrapper.innerHTML = this.getInnerHtml(values);\n    }\n    event(args, alias) {\n        if (alias == \"keydown\") {\n            const kargs = args;\n            if (kargs.key == \"p\")\n                this.isVisible = !this.isVisible;\n        }\n    }\n    addRecord(key, value) {\n        if (!this.usage.has(key)) {\n            this.usage.set(key, [value]);\n        }\n        else {\n            let usage = this.usage.get(key);\n            let len = usage.length;\n            if (len >= this.size) {\n                usage.shift();\n                usage.push(value);\n            }\n            else {\n                usage.push(value);\n            }\n        }\n    }\n    getChartHtml(values) {\n        values = values.slice(Math.max(0, values.length - 100), values.length);\n        const max = 200; //Math.max(...values);\n        let html = `<div class=\"profiler-chart\">`;\n        for (let i = 0; i < values.length; i++) {\n            html += `<div class=\"profiler-chart-item\" style=\"height: ${values[i] / max * 100}px\"></div>`;\n        }\n        html += `</div>`;\n        return html;\n    }\n    getElementsHtml(values) {\n        let html = \"\";\n        for (let i = 0; i < values.length; i++) {\n            if (i > 0)\n                html += `<hr class=\"profiler-item-separator\">`;\n            html +=\n                `<div class=\"profiler-item\">\r\n                <span class=\"profiler-item-key\">${values[i].split(\": \")[0]}:</span>\r\n                <span class=\"profiler-item-value\">${values[i].split(\": \")[1]}</span>\r\n            </div>`;\n        }\n        return html;\n    }\n    getInnerHtml(values) {\n        const profiler = `\r\n            <style>\r\n                .profiler{\r\n                    ${this.isVisible ? \"\" : \"display: none;\"}\r\n                    position: fixed;\r\n                    top: 20px;\r\n                    left: 20px;\r\n                    \r\n                    width: 400px;\r\n                    padding: 20px;\r\n                    border-radius: 20px;\r\n                    background-color: rgba(42, 43, 46, 0.382);\r\n                    color: white;\r\n                    pointer-events: none;\r\n                }\r\n                .profiler-header{\r\n                    font-size: 20px;\r\n                    font-weight: bold;\r\n                    color: white;\r\n                    margin-bottom: 10px;\r\n                }\r\n                .profiler-item{\r\n                    // display: flex;\r\n                    // justify-content: space-between;\r\n                    padding: 5px 0;\r\n                    color:rgba(240, 240, 240, 0.85)\r\n                }\r\n                .profiler-item-key{\r\n                    margin-right: 10px;\r\n                }\r\n                .profiler-item-value{\r\n                    color: #f0f0f0;\r\n                }\r\n                .profiler-item-separator{\r\n                    border: none;\r\n                    border-top: 1px dashed gray;\r\n                    opacity: 0.75;\r\n                    margin: 2px 0;\r\n                }\r\n                .profiler-chart{\r\n                    display: flex;\r\n                    flex-direction: row;\r\n                    justify-content: space-between;\r\n                    align-items: flex-end;\r\n                    height: 100px;\r\n                    width: 100%;\r\n                    margin-bottom: 10px;\r\n                    border-radius: 10px;\r\n                    overflow: hidden;\r\n                    opacity: 0.25;\r\n                }\r\n                .profiler-chart-item{\r\n                    background-color: rgb(240, 240, 240);\r\n                    width: 100%;\r\n                    margin: 0;\r\n                }\r\n            </style>\r\n\r\n            <div class=\"profiler\">\r\n                <div class=\"profiler-header\">\r\n                    <h2 style=\"margin: 0\">Profiler <span style=\"opacity: 0.5\">[P]</span></h2>\r\n                </div>\r\n                ${this.getChartHtml(this.fpsHistory)}\r\n                ${this.getElementsHtml(values)}\r\n            </div>\r\n            `;\n        return profiler;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Hud/Profiler.ts?");

/***/ }),

/***/ "./src/Plugins/Keyboard.ts":
/*!*********************************!*\
  !*** ./src/Plugins/Keyboard.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   KeyboardEventArgs: () => (/* binding */ KeyboardEventArgs),\n/* harmony export */   KeyboardPlugin: () => (/* binding */ KeyboardPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\n\nclass KeyboardEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.EventArgs {\n    key;\n    constructor(key) {\n        super();\n        this.key = key;\n    }\n}\nclass KeyboardPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"KeyboardPlugin\";\n    KeyDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.GameEvent();\n    BlockedKeyDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_0__.GameEvent();\n    block = false;\n    NowPressedKeys = new Set();\n    pressedKeys = new Set();\n    constructor() {\n        super();\n        this.pressedKeys = new Set();\n        document.onkeydown = (event) => {\n            const key = event.key.toLowerCase();\n            this.pressedKeys.add(key);\n            this.NowPressedKeys.add(key);\n        };\n        document.onkeyup = (event) => {\n            const key = event.key.toLowerCase();\n            this.pressedKeys.delete(key);\n        };\n    }\n    isPressed(key) {\n        return this.enabled && !this.block && this.pressedKeys.has(key);\n    }\n    start() {\n        this.KeyDownEvent.register(this.gameWorld);\n        this.BlockedKeyDownEvent.register(this.gameWorld);\n    }\n    update(delta) {\n        this.NowPressedKeys.forEach(key => {\n            if (this.block)\n                this.BlockedKeyDownEvent.emit(new KeyboardEventArgs(key));\n            else\n                this.KeyDownEvent.emit(new KeyboardEventArgs(key));\n        });\n        this.NowPressedKeys.clear();\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Keyboard.ts?");

/***/ }),

/***/ "./src/Plugins/Mouse.ts":
/*!******************************!*\
  !*** ./src/Plugins/Mouse.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MouseClickEventArgs: () => (/* binding */ MouseClickEventArgs),\n/* harmony export */   MousePlugin: () => (/* binding */ MousePlugin),\n/* harmony export */   MouseScrollEventArgs: () => (/* binding */ MouseScrollEventArgs)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Core/GameEvent */ \"./src/Core/GameEvent.ts\");\n\n\n\nclass MouseScrollEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    delta;\n    constructor(delta) {\n        super();\n        this.delta = delta;\n    }\n}\nclass MouseClickEventArgs extends _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.EventArgs {\n    button;\n    constructor(button) {\n        super();\n        this.button = button;\n    }\n}\nclass MousePlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"MousePlugin\";\n    mouseScrollYEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    mouseDownEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    mouseUpEvent = new _Core_GameEvent__WEBPACK_IMPORTED_MODULE_2__.GameEvent();\n    pressedKeys = new Set();\n    canvas;\n    position = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector.zero();\n    constructor(canvas) {\n        super();\n        this.canvas = canvas;\n        this.trackMouse(canvas);\n    }\n    start() {\n        this.mouseScrollYEvent.register(this.gameWorld);\n        this.mouseDownEvent.register(this.gameWorld);\n        this.mouseUpEvent.register(this.gameWorld);\n    }\n    isKeyDown(key = 0) {\n        return this.pressedKeys.has(key);\n    }\n    getMouseScreenPosition() {\n        const scale = window.devicePixelRatio || 1;\n        // const canvasSize = new Vector(this.canvas.width, this.canvas.height);\n        let screenPosition = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector((this.position.x * scale), (this.position.y * scale));\n        return screenPosition;\n    }\n    trackMouse(canvas) {\n        canvas.addEventListener(\"mousemove\", (event) => {\n            const rect = canvas.getBoundingClientRect();\n            let x = event.clientX - rect.left;\n            let y = event.clientY - rect.top;\n            this.position = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_0__.Vector(x, y);\n        });\n        canvas.addEventListener(\"mousedown\", (event) => {\n            this.pressedKeys.add(event.button);\n            this.mouseDownEvent.emit(new MouseClickEventArgs(event.button));\n        });\n        canvas.addEventListener(\"mouseup\", (event) => {\n            this.pressedKeys.delete(event.button);\n            this.mouseUpEvent.emit(new MouseClickEventArgs(event.button));\n        });\n        canvas.addEventListener(\"wheel\", (event) => {\n            this.mouseScrollYEvent.emit(new MouseScrollEventArgs(event.deltaY));\n        });\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Mouse.ts?");

/***/ }),

/***/ "./src/Plugins/Physics.ts":
/*!********************************!*\
  !*** ./src/Plugins/Physics.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhysicsPlugin: () => (/* binding */ PhysicsPlugin)\n/* harmony export */ });\n/* harmony import */ var _Components_Body__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/Body */ \"./src/Components/Body.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var planck_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! planck-js */ \"./node_modules/planck-js/dist/planck.mjs\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n\n\n\n\nclass PhysicsPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"PhysicsPlugin\";\n    world = new planck_js__WEBPACK_IMPORTED_MODULE_3__.World();\n    update(delta) {\n        const totalDelta = this.gameWorld.getWorldTime();\n        for (let body of this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_2__.GOManagerPlugin).getComponents(_Components_Body__WEBPACK_IMPORTED_MODULE_0__.BodyC))\n            body.update(delta);\n        this.world.step(delta);\n    }\n    getWorld() {\n        return this.world;\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Physics.ts?");

/***/ }),

/***/ "./src/Plugins/Player.ts":
/*!*******************************!*\
  !*** ./src/Plugins/Player.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PlayerPlugin: () => (/* binding */ PlayerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../GameObjectFactory */ \"./src/GameObjectFactory.ts\");\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Keyboard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Mouse__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Helpers/Commands */ \"./src/Helpers/Commands.ts\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (undefined && undefined.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n// import { CanonC } from \"../Components/Canon\";\n\n\n\n\n\n\n\n\n\n\n\nclass PlayerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_4__.Plugin {\n    name = \"PlayerPlugin\";\n    playerName = \"player\";\n    player = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__.GameObjectFactory.playerGO();\n    getPlayerPosition() {\n        return this.player.getBody().getPosition();\n    }\n    getPlayerColor() {\n        return this.player.getComponent(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__.PolygonRendererC).color.clone();\n    }\n    start() {\n        this.respawn();\n        this.player.getComponent(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_0__.PolygonRendererC).color = this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.get(\"playerColor\") ?? new _Helpers_Color__WEBPACK_IMPORTED_MODULE_2__.rgb(53, 110, 58);\n        this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_5__.KeyboardPlugin)?.KeyDownEvent.subscribe(this, \"KeyDownEvent\");\n    }\n    event(args, alias) {\n        if (alias === \"KeyDownEvent\") {\n            let keyArgs = args;\n            if (keyArgs.key === \"r\") {\n                this.respawn();\n            }\n            else if (keyArgs.key === \"c\") {\n                let displayColliders = this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.get(\"displayColliders\") ?? false;\n                if (displayColliders !== undefined)\n                    this.getPlugin(_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin)?.set(\"displayColliders\", !displayColliders);\n            }\n        }\n    }\n    // color: rgb = new rgb(53, 110, 58);\n    // target: rgb = new rgb(53, 110, 58);\n    update(delta) {\n        const body = this.player.getBody();\n        const camera = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_9__.CameraPlugin);\n        const mouse = this.getPlugin(_Mouse__WEBPACK_IMPORTED_MODULE_6__.MousePlugin);\n        const keyboard = this.getPlugin(_Keyboard__WEBPACK_IMPORTED_MODULE_5__.KeyboardPlugin);\n        const ra = -25;\n        const a = keyboard.isPressed(\"shift\") ? 120 : 60;\n        const vmax = 50.0;\n        const rotation = body.getRotation();\n        const direction = _Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__.Vector.fromRad(rotation);\n        const turnSpeed = 2.5;\n        //   const gun = this.player.getComponent(CanonC);\n        // if (Math.random() < 0.05){\n        //   this.target=rgb.randomColor2();\n        //   // this.getPlugin(CliPlugin)?.execute(\"player:setcolor {randomcolor}\");\n        // }\n        // this.color = this.color.blend(this.target, 0.02);\n        // this.player.getComponent(PolygonRendererC).color = this.color;\n        camera.targetCameraPosition = body.getPosition();\n        if (!this.player.enabled)\n            return;\n        //   if (!gun) return;\n        //   gun.targetDirection = camera.getWorldPosition(mouse.getMouseScreenPosition()).sub(this.player.getTransform().position);\n        //   gun.range = camera.getWorldPosition(mouse.getMouseScreenPosition()).sub(this.player.getTransform().position.add(gun.getGlobalOffset())).magnitude();\n        //   if (keyboard.isPressed(\"e\")||mouse.isKeyDown(0)) \n        //     gun.shoot();\n        let velocity = body.getVelocity();\n        // Przyspieszanie\n        if (keyboard.isPressed(\"w\")) {\n            body.setForce(direction.toUnit().mul(a));\n            if (keyboard.isPressed(\"s\"))\n                body.setForce(direction.toUnit().mul(-ra));\n        }\n        else if (keyboard.isPressed(\"s\"))\n            body.setForce(direction.toUnit().mul(ra));\n        else\n            body.setForce(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_3__.Vector.zero());\n        velocity = velocity.sub(velocity.perpendicular(direction));\n        if (velocity.length() > vmax)\n            velocity.setLength(vmax);\n        if (keyboard.isPressed(\"a\"))\n            body.setAngularVelocity(turnSpeed);\n        else if (keyboard.isPressed(\"d\"))\n            body.setAngularVelocity(-turnSpeed);\n        else\n            body.setAngularVelocity(0);\n    }\n    cliGetName() {\n        return \"player\";\n    }\n    //   @cli(\"setname\", \"<name: string>\")\n    //   private setname(newName: string): CommandResult {\n    //       this.playerName = newName;\n    //       this.player.name = newName;\n    //       return new CommandResult(true, `Player name set to ${newName}`, undefined);\n    //   }\n    //   @cli(\"setcolor\", \"<color: string | rgb>\")\n    //   private setcolor(color: string | rgb): CommandResult {\n    //       try{\n    //         let newColor = rgb.tryParseCssColor(color.toString());\n    //         if (newColor)\n    //           this.player.getComponent(PolygonRendererC).color = newColor;\n    //       } catch {}\n    //       return new CommandResult(true, `Player color set`, undefined);\n    //   }\n    respawn() {\n        const gom = this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_10__.GOManagerPlugin);\n        if (this.player && gom.isSpawned(this.player))\n            gom.destroy(this.player);\n        this.player = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_1__.GameObjectFactory.playerGO();\n        this.player.name = this.playerName;\n        gom.spawn(this.player);\n        return new _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.CommandResult(true, `Player respawned`, undefined);\n    }\n}\n__decorate([\n    (0,_Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.cli)(\"respawn\"),\n    __metadata(\"design:type\", Function),\n    __metadata(\"design:paramtypes\", []),\n    __metadata(\"design:returntype\", _Helpers_Commands__WEBPACK_IMPORTED_MODULE_8__.CommandResult)\n], PlayerPlugin.prototype, \"respawn\", null);\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Player.ts?");

/***/ }),

/***/ "./src/Plugins/Renderer.ts":
/*!*********************************!*\
  !*** ./src/Plugins/Renderer.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   RendererPlugin: () => (/* binding */ RendererPlugin)\n/* harmony export */ });\n/* harmony import */ var _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Helpers/Color */ \"./src/Helpers/Color.ts\");\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n/* harmony import */ var _Camera__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Components/Renderers/PolygonRenderer */ \"./src/Components/Renderers/PolygonRenderer.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _GOManager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GOManager */ \"./src/Plugins/GOManager.ts\");\n/* harmony import */ var _Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Components/Renderers/TextRenderer */ \"./src/Components/Renderers/TextRenderer.ts\");\n/* harmony import */ var _Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../Components/Renderers/BarRenderer */ \"./src/Components/Renderers/BarRenderer.ts\");\n/* harmony import */ var _Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../Components/Renderers/ChasisRenderer */ \"./src/Components/Renderers/ChasisRenderer.ts\");\n\n\n\n// import { ImageRendererC } from \"../Components/Renderers/ImageRenderer\";\n\n// import { CanonRendererC } from \"../Components/Renderers/CanonRenderer\";\n\n\n\n\n\n// import { TracesRendererC } from \"../Components/Renderers/TracesRenderer\";\nclass RendererPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_1__.Plugin {\n    name = \"RendererPlugin\";\n    context;\n    renderDistance = 150;\n    constructor(context) {\n        super();\n        this.context = context;\n    }\n    addVignetteEffect(context, color) {\n        const centerX = context.canvas.width / 2;\n        const centerY = context.canvas.height / 2;\n        const maxRadius = Math.sqrt(centerX * centerX + centerY * centerY);\n        const gradient = context.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);\n        gradient.addColorStop(0.025, 'rgba(0, 0, 0, 0)');\n        gradient.addColorStop(1, color);\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, context.canvas.width, context.canvas.height);\n    }\n    gridCanvas = [];\n    start() {\n        ////\n        this.context.imageSmoothingEnabled = true;\n        this.context.strokeStyle = \"rgb(43,43,44)\";\n        this.context.lineWidth = 0.175;\n        this.context.lineJoin = \"round\";\n        this.context.shadowColor = 'rgba(0, 0, 0, 0.75)';\n        this.context.fillStyle = \"#716f6b\";\n        this.context.fillStyle = \"rgb(85, 106, 86)\";\n        this.context.fillStyle = \"rgb(66, 85, 68)\";\n        ////\n        let worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u(\"src_Components_Renderers_BackgroundRenderer_ts\"), __webpack_require__.b), { type: \"module\" }); //this.drawDotGrid(ctx, new Vector(2.5, 2.5), 0.175, rgb.stroke.toString(), new Vector(i*4+5, i*4+5));\n        for (let i = 0; i < 10; i++) {\n            this.gridCanvas[i] = document.createElement(\"canvas\");\n            this.gridCanvas[i].width = 3440;\n            this.gridCanvas[i].height = 1440;\n            document.createElement(\"canvas\");\n            const offscreen = this.gridCanvas[i].transferControlToOffscreen();\n            worker.postMessage({ canvas: offscreen, args: [new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(2, 2), 0.175, _Helpers_Color__WEBPACK_IMPORTED_MODULE_0__.rgb.stroke.toString(), new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(i * 5 + 5, i * 5 + 5)] }, [offscreen]);\n        }\n    }\n    clip(position) {\n        const width = this.context.canvas.width;\n        const height = this.context.canvas.height;\n        const scale = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).scaleV;\n        const cameraPositon = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraPosition;\n        const xClip = Math.abs(width / 2 / scale.x);\n        const yClip = Math.abs(height / 2 / scale.y);\n        return Math.abs(position.x - cameraPositon.x) > xClip || Math.abs(position.y - cameraPositon.y) > yClip;\n    }\n    update(delta) {\n        const width = this.context.canvas.width;\n        const height = this.context.canvas.height;\n        // this.context.fillStyle =\"rgb(66, 85, 68)\";\n        // this.context.fillStyle =\"rgb(105, 111, 105)\";\n        this.context.fillStyle = \"rgba(80, 100, 81, 1)\";\n        this.context.fillRect(0, 0, width, height);\n        this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraScreenOffset = new _Helpers_Vector__WEBPACK_IMPORTED_MODULE_4__.Vector(this.context.canvas.width / 2, this.context.canvas.height / 2);\n        // let gx = Math.sqrt(3);\n        // let gy = 3;\n        let gx = 2;\n        let gy = 2;\n        const offset = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraScreenOffset;\n        const scale = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).scaleV;\n        const cpos = this.getPlugin(_Camera__WEBPACK_IMPORTED_MODULE_2__.CameraPlugin).cameraPosition;\n        let i = Math.max(0, Math.min(9, Math.round(scale.x / 10)));\n        let c = i * 5 + 5;\n        this.context.translate(offset.x, offset.y);\n        this.context.scale(scale.x, scale.y);\n        this.context.translate((-cpos.x) % gx, (-cpos.y) % gy);\n        this.context.scale(1 / c, 1 / c);\n        this.context.drawImage(this.gridCanvas[i], -this.gridCanvas[i].width / 2, -this.gridCanvas[i].height / 2, this.gridCanvas[i].width, this.gridCanvas[i].height);\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_TextRenderer__WEBPACK_IMPORTED_MODULE_6__.TextRendererC)\n            // .concat(this.app.getComponents(ColliderRendererC) as RendererC[])\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_PolygonRenderer__WEBPACK_IMPORTED_MODULE_3__.PolygonRendererC))\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_BarRenderer__WEBPACK_IMPORTED_MODULE_7__.BarRendererC))\n            // .concat(this.app.getComponents(ImageRendererC)as RendererC[])\n            .filter(renderer => !this.clip(renderer.gameObject.getBody().getPosition()))\n            // .concat(this.app.getComponents(CanonRendererC)as RendererC[])\n            // .concat(this.app.getComponents(TracesRendererC)as RendererC[])\n            .concat(this.getPlugin(_GOManager__WEBPACK_IMPORTED_MODULE_5__.GOManagerPlugin).getComponents(_Components_Renderers_ChasisRenderer__WEBPACK_IMPORTED_MODULE_8__.ChasisRendererC))\n            .filter(renderer => !this.clip(renderer.gameObject.getBody().getPosition()))\n            .sort((a, b) => a.zindex - b.zindex).forEach(renderer => renderer.render(this.context));\n        // this.gameWorld.getAllComponents<RendererC>(RendererC.name).forEach(renderer => renderer.render(this.context));\n        this.addVignetteEffect(this.context, 'rgba(0, 0, 0, 0.35)');\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Renderer.ts?");

/***/ }),

/***/ "./src/Plugins/Scheduler.ts":
/*!**********************************!*\
  !*** ./src/Plugins/Scheduler.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SchedulerPlugin: () => (/* binding */ SchedulerPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass SchedulerPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"SchedulerPlugin\";\n    schedule = [];\n    addInvoke(subscriber, totalTime, topic) {\n        let sub = new WeakRef(subscriber);\n        this.schedule.push({ totalTime, subscriber: sub, topic });\n        this.schedule.sort((a, b) => b.totalTime - a.totalTime);\n    }\n    update(delta) {\n        const totalDelta = this.gameWorld.getWorldTime();\n        if (this.schedule.length != 0)\n            while (this.schedule.length != 0 && this.schedule[this.schedule.length - 1].totalTime <= totalDelta) {\n                let last = this.schedule.pop();\n                last.subscriber.deref()?.onInvoke(last.topic);\n            }\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/Scheduler.ts?");

/***/ }),

/***/ "./src/Plugins/StandaloneComponent.ts":
/*!********************************************!*\
  !*** ./src/Plugins/StandaloneComponent.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandaloneComponentPlugin: () => (/* binding */ StandaloneComponentPlugin)\n/* harmony export */ });\n/* harmony import */ var _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Core/Plugin */ \"./src/Core/Plugin.ts\");\n\nclass StandaloneComponentPlugin extends _Core_Plugin__WEBPACK_IMPORTED_MODULE_0__.Plugin {\n    name = \"StandaloneComponentPlugin\";\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Plugins/StandaloneComponent.ts?");

/***/ }),

/***/ "./src/Worlds/MyWorld.ts":
/*!*******************************!*\
  !*** ./src/Worlds/MyWorld.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MyWorld: () => (/* binding */ MyWorld)\n/* harmony export */ });\n/* harmony import */ var _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../GameObjectFactory */ \"./src/GameObjectFactory.ts\");\n/* harmony import */ var _Core_GameWorld__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Core/GameWorld */ \"./src/Core/GameWorld.ts\");\n/* harmony import */ var _Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Helpers/Vector */ \"./src/Helpers/Vector.ts\");\n/* harmony import */ var _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Helpers/Math */ \"./src/Helpers/Math.ts\");\n/* harmony import */ var _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Plugins/GOManager */ \"./src/Plugins/GOManager.ts\");\n// import { RigidBodyC } from \"../Components/RigidBody\";\n\n\n\n// import { CanonC } from \"../Components/Canon\";\n// import { NpcC } from \"../Components/Npc\";\n\n\n// import { CanonRendererC } from \"../Components/Renderers/CanonRenderer\";\nclass MyWorld extends _Core_GameWorld__WEBPACK_IMPORTED_MODULE_1__.GameWorld {\n    Start() {\n        console.log(\"Hello, MyWorld!\");\n        const r = 350;\n        for (let i = 0; i < 550; i++) {\n            const radius = 3 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let sqr = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, 4);\n            sqr.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            sqr.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(sqr);\n        }\n        for (let i = 0; i < 250; i++) {\n            const radius = 3.5 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let triangle = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, 3);\n            triangle.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            triangle.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(triangle);\n        }\n        for (let i = 0; i < 350; i++) {\n            const radius = 4 + _Helpers_Math__WEBPACK_IMPORTED_MODULE_3__.GMath.symRand(0.25);\n            let polygon = _GameObjectFactory__WEBPACK_IMPORTED_MODULE_0__.GameObjectFactory.polygonGO(radius / 2, Math.round(Math.random() * 3) + 5);\n            polygon.getBody().setPosition(_Helpers_Vector__WEBPACK_IMPORTED_MODULE_2__.Vector.randomPos(r));\n            polygon.getBody().setAngularVelocity(Math.random() * 2 - 1);\n            this.getPlugin(_Plugins_GOManager__WEBPACK_IMPORTED_MODULE_4__.GOManagerPlugin).spawn(polygon);\n        }\n        // for(let i = 0; i < 225; i++){\n        //     const radius = 3+GMath.symRand(0.25);\n        //     let polygon = GameObjectFactory.polygonGO(\n        //         radius/2, \n        //         Math.round(Math.random()*3)+5,\n        //         new ImageRendererC(Vector.zero(), undefined, undefined, 12)\n        //     );\n        //     polygon.getTransform().position = new Vector(Math.random()*2*r-r, Math.random()*2*r-r);\n        //     polygon.getComponent(RigidBodyC).angularVelocity = Math.random()*2-1;\n        //     polygon.getComponent(PolygonRendererC).enable(false);\n        //     this.spawn(polygon);\n        // }\n        // for(let i = 0; i < 25; i++){\n        //     let follower = GameObjectFactory.enemyGO(2.5, \"Enemy nr.\"+i, 4,\n        //         new CanonC(undefined, undefined, 10+Math.random()*5),\n        //         new CanonRendererC(4-0.1),\n        //         new NpcC()\n        //     );\n        //     follower.getTransform().position = Vector.randomPos(r);\n        //     follower.spawn(this);\n        // }\n    }\n    Update(delta) {\n    }\n}\n\n\n//# sourceURL=webpack://gameengine/./src/Worlds/MyWorld.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   main: () => (/* binding */ main)\n/* harmony export */ });\n/* harmony import */ var _Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Worlds/MyWorld */ \"./src/Worlds/MyWorld.ts\");\n/* harmony import */ var _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Plugins/Renderer */ \"./src/Plugins/Renderer.ts\");\n/* harmony import */ var _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Plugins/Physics */ \"./src/Plugins/Physics.ts\");\n/* harmony import */ var _Plugins_Keyboard__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Plugins/Keyboard */ \"./src/Plugins/Keyboard.ts\");\n/* harmony import */ var _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Plugins/Mouse */ \"./src/Plugins/Mouse.ts\");\n/* harmony import */ var _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Plugins/Player */ \"./src/Plugins/Player.ts\");\n/* harmony import */ var _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Plugins/Camera */ \"./src/Plugins/Camera.ts\");\n/* harmony import */ var _Plugins_Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Plugins/Config */ \"./src/Plugins/Config.ts\");\n/* harmony import */ var _Plugins_CollisionDetection__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Plugins/CollisionDetection */ \"./src/Plugins/CollisionDetection.ts\");\n/* harmony import */ var _Plugins_StandaloneComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Plugins/StandaloneComponent */ \"./src/Plugins/StandaloneComponent.ts\");\n/* harmony import */ var _Plugins_Scheduler__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Plugins/Scheduler */ \"./src/Plugins/Scheduler.ts\");\n/* harmony import */ var _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Plugins/Hud/Profiler */ \"./src/Plugins/Hud/Profiler.ts\");\n/* harmony import */ var _Plugins_Client__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./Plugins/Client */ \"./src/Plugins/Client.ts\");\n/* harmony import */ var _Plugins_Cli__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./Plugins/Cli */ \"./src/Plugins/Cli.ts\");\n/* harmony import */ var _Plugins_Hud_Console__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Plugins/Hud/Console */ \"./src/Plugins/Hud/Console.ts\");\n/* harmony import */ var _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Plugins/GOManager */ \"./src/Plugins/GOManager.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nasync function main(canvas) {\n    const world = new _Worlds_MyWorld__WEBPACK_IMPORTED_MODULE_0__.MyWorld(new _Plugins_Config__WEBPACK_IMPORTED_MODULE_7__.ConfigPlugin(), new _Plugins_Client__WEBPACK_IMPORTED_MODULE_12__.ClientPlugin(), new _Plugins_Cli__WEBPACK_IMPORTED_MODULE_13__.CliPlugin(), new _Plugins_Keyboard__WEBPACK_IMPORTED_MODULE_3__.KeyboardPlugin(), new _Plugins_Mouse__WEBPACK_IMPORTED_MODULE_4__.MousePlugin(canvas), new _Plugins_Scheduler__WEBPACK_IMPORTED_MODULE_10__.SchedulerPlugin(), new _Plugins_GOManager__WEBPACK_IMPORTED_MODULE_15__.GOManagerPlugin(), new _Plugins_Player__WEBPACK_IMPORTED_MODULE_5__.PlayerPlugin(), new _Plugins_Physics__WEBPACK_IMPORTED_MODULE_2__.PhysicsPlugin(), new _Plugins_Camera__WEBPACK_IMPORTED_MODULE_6__.CameraPlugin(), new _Plugins_Hud_Console__WEBPACK_IMPORTED_MODULE_14__.ConsolePlugin(), new _Plugins_Hud_Profiler__WEBPACK_IMPORTED_MODULE_11__.ProfilerPlugin(), new _Plugins_CollisionDetection__WEBPACK_IMPORTED_MODULE_8__.CollisionDetectionPlugin(), new _Plugins_StandaloneComponent__WEBPACK_IMPORTED_MODULE_9__.StandaloneComponentPlugin(), new _Plugins_Renderer__WEBPACK_IMPORTED_MODULE_1__.RendererPlugin(canvas.getContext(\"2d\")));\n    console.log(world.getAllPlugins());\n    function tick() {\n        world.tick();\n        requestAnimationFrame(tick);\n    }\n    tick();\n}\nmain(document.getElementById(\"gameCanvas\"));\n\n\n//# sourceURL=webpack://gameengine/./src/index.ts?");

/***/ })

/******/ });
/************************************************************************/
/******/ // The module cache
/******/ var __webpack_module_cache__ = {};
/******/ 
/******/ // The require function
/******/ function __webpack_require__(moduleId) {
/******/ 	// Check if module is in cache
/******/ 	var cachedModule = __webpack_module_cache__[moduleId];
/******/ 	if (cachedModule !== undefined) {
/******/ 		return cachedModule.exports;
/******/ 	}
/******/ 	// Create a new module (and put it into the cache)
/******/ 	var module = __webpack_module_cache__[moduleId] = {
/******/ 		// no module.id needed
/******/ 		// no module.loaded needed
/******/ 		exports: {}
/******/ 	};
/******/ 
/******/ 	// Execute the module function
/******/ 	__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 
/******/ 	// Return the exports of the module
/******/ 	return module.exports;
/******/ }
/******/ 
/******/ // expose the modules object (__webpack_modules__)
/******/ __webpack_require__.m = __webpack_modules__;
/******/ 
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__webpack_require__.d = (exports, definition) => {
/******/ 		for(var key in definition) {
/******/ 			if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 			}
/******/ 		}
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/get javascript chunk filename */
/******/ (() => {
/******/ 	// This function allow to reference async chunks
/******/ 	__webpack_require__.u = (chunkId) => {
/******/ 		// return url for filenames based on template
/******/ 		return "" + chunkId + ".bundle.js";
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ })();
/******/ 
/******/ /* webpack/runtime/make namespace object */
/******/ (() => {
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = (exports) => {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/ })();
/******/ 
/******/ /* webpack/runtime/publicPath */
/******/ (() => {
/******/ 	var scriptUrl;
/******/ 	if (typeof import.meta.url === "string") scriptUrl = import.meta.url
/******/ 	// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 	// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 	if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 	scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 	__webpack_require__.p = scriptUrl;
/******/ })();
/******/ 
/******/ /* webpack/runtime/import chunk loading */
/******/ (() => {
/******/ 	__webpack_require__.b = new URL("./", import.meta.url);
/******/ 	
/******/ 	// object to store loaded and loading chunks
/******/ 	// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 	// [resolve, Promise] = chunk loading, 0 = chunk loaded
/******/ 	var installedChunks = {
/******/ 		"main": 0
/******/ 	};
/******/ 	
/******/ 	// no install chunk
/******/ 	
/******/ 	// no chunk on demand loading
/******/ 	
/******/ 	// no prefetching
/******/ 	
/******/ 	// no preloaded
/******/ 	
/******/ 	// no external install chunk
/******/ 	
/******/ 	// no on chunks loaded
/******/ })();
/******/ 
/************************************************************************/
/******/ 
/******/ // startup
/******/ // Load entry module and return exports
/******/ // This entry module can't be inlined because the eval devtool is used.
/******/ var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 
